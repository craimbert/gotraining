<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-6298089572270107210</id><updated>2015-07-31T15:13:09.437-04:00</updated><title type='text'>Going Go Programming</title><subtitle type='html'>Golang For Everyone : https://github.com/goinggo</subtitle><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='http://www.goinggo.net/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/'/><link rel='hub' href='http://pubsubhubbub.appspot.com/'/><link rel='next' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default?start-index=26&amp;max-results=25'/><author><name>William Kennedy</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>67</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-3707264680032475251</id><published>2015-03-15T11:04:00.000-04:00</published><updated>2015-03-15T11:21:09.934-04:00</updated><title type='text'>Object Oriented Programming Mechanics</title><content type='html'>&lt;div class=&quot;p1&quot;&gt;Go is an object oriented programming language. It may not have inheritance, but in this 20 minute video from the Bangalore meetup, I will show you how object oriented programming practices and techniques can be applied to your Go programs. From an object oriented standpoint, Go does provides the ability to add behavior to your types via methods, allows you to implement polymorphic behavior via interfaces and gives you a way to extend the state and behavior of any existing type via type embedding. Go also provides a form of encapsulation that allows your types, including their fields and methods, to be visible or invisible. Everything you need to write object oriented programs is available in Go.&lt;/div&gt;&lt;br /&gt;&lt;iframe allowfullscreen=&quot;&quot; frameborder=&quot;0&quot; height=&quot;510&quot; src=&quot;https://www.youtube.com/embed/gRpUfjTwSOo&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt; &lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;b&gt;Example 1 - Methods: &lt;/b&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/hfRkC6nKag&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/hfRkC6nKag&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Example 2 - Interfaces:&lt;/b&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/F1UyKlTh3k&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/F1UyKlTh3k&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Example 3 - Extending Types:&lt;/b&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/JJ811lBwoz&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/JJ811lBwoz&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Example 4 - Overriding Inner Types:&lt;/b&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/-xQFBv9_82&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/-xQFBv9_82&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/3707264680032475251/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2015/03/object-oriented-programming-mechanics.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/3707264680032475251'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/3707264680032475251'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2015/03/object-oriented-programming-mechanics.html' title='Object Oriented Programming Mechanics'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://img.youtube.com/vi/gRpUfjTwSOo/default.jpg" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-9092823878976582889</id><published>2015-02-23T20:56:00.000-05:00</published><updated>2015-02-24T00:25:23.436-05:00</updated><title type='text'>Scheduler Tracing In Go</title><content type='html'>&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;br /&gt;One of the things I love about Go is the profiling and debug information you can generate. There is a special environmental variable named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GODEBUG&lt;/span&gt; that will emit debugging information about the runtime as your program executes. You can request summary and detailed information for both the garbage collector and the scheduler. What’s great is you don&#39;t need to build your program with any special switches for it to work.&lt;br /&gt;&lt;br /&gt;In this post, I will show you how to interpret the scheduler trace information from a sample concurrent Go program. It will help if you have a basic understanding of the scheduler. I recommend reading these two posts before continuing:&lt;br /&gt;&lt;br /&gt;Concurrency, Goroutines and GOMAXPROCS&lt;br /&gt;&lt;a href=&quot;http://www.goinggo.net/2014/01/concurrency-goroutines-and-gomaxprocs.html&quot; target=&quot;_blank&quot;&gt;http://www.goinggo.net/2014/01/concurrency-goroutines-and-gomaxprocs.html&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Go Scheduler&lt;br /&gt;&lt;a href=&quot;http://morsmachine.dk/go-scheduler&quot; target=&quot;_blank&quot;&gt;http://morsmachine.dk/go-scheduler&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The Code&lt;/span&gt;&lt;br /&gt;This is the sample program we will use to inspect and interpret the results from &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GODEBUG&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 import (&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; &quot;sync&quot;&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; &quot;time&quot;&lt;br /&gt;06 )&lt;br /&gt;07&lt;br /&gt;08 func main() {&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; var wg sync.WaitGroup&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; wg.Add(10)&lt;br /&gt;11&lt;br /&gt;12 &amp;nbsp; &amp;nbsp; for i := 0; i &amp;lt; 10; i++ {&lt;br /&gt;13 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; go work(&amp;amp;wg)&lt;br /&gt;14 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;15&lt;br /&gt;16 &amp;nbsp; &amp;nbsp; wg.Wait()&lt;br /&gt;17&lt;br /&gt;18 &amp;nbsp; &amp;nbsp; // Wait to see the global run queue deplete.&lt;br /&gt;19 &amp;nbsp; &amp;nbsp; time.Sleep(3 * time.Second)&lt;br /&gt;20 }&lt;br /&gt;21&lt;br /&gt;22 func work(wg *sync.WaitGroup) {&lt;br /&gt;23 &amp;nbsp; &amp;nbsp; time.Sleep(time.Second)&lt;br /&gt;24&lt;br /&gt;25 &amp;nbsp; &amp;nbsp; var counter int&lt;br /&gt;26 &amp;nbsp; &amp;nbsp; for i := 0; i &amp;lt; 1e10; i++ {&lt;br /&gt;27 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; counter++&lt;br /&gt;28 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;29&lt;br /&gt;30 &amp;nbsp; &amp;nbsp; wg.Done()&lt;br /&gt;31 } &lt;/div&gt;&lt;br /&gt;The code in listing 1 is designed to be predictable against the debug information we expect to see emitted by the runtime. On line 12, a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;for&lt;/span&gt; loop is declared to create ten goroutines. Then the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt; function waits on line 16 for all the goroutines to finish their work. The work function on line 22 sleeps for one second and then increments a local variable ten billion times. Once the incrementing is done, the function calls &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Done&lt;/span&gt; on the wait group and returns.&lt;br /&gt;&lt;br /&gt;It is a good idea to build your program with &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;go build&lt;/span&gt; first, before setting the options for &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GODEBUG&lt;/span&gt;. This variable is picked up by the runtime, so running Go commands will produce tracing output as well. If you use &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GODEBUG&lt;/span&gt; in conjunction with &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;go run&lt;/span&gt; for example, then you will see trace information for the build prior to your program running.&lt;br /&gt;&lt;br /&gt;Now let’s build the program so we can run it with the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GODEBUG&lt;/span&gt; scheduler option:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;go build example.go &lt;/div&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Scheduler Summary Trace&lt;/span&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;schedtrace&lt;/span&gt; option causes the runtime to emit a single summary line about the scheduler’s state to standard error every X milliseconds. Let’s run the program, setting the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GODEBUG&lt;/span&gt; option at the same time:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;GODEBUG=schedtrace=1000 ./example &lt;/div&gt;&lt;br /&gt;Once the program starts running we will see the tracing begin. The program itself does not output anything to standard out or standard error, so we can just focus on the traces. Let’s look at the first two traces that are emitted:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;SCHED 0ms&lt;/b&gt;: gomaxprocs=1 idleprocs=0 threads=2 spinningthreads=0 idlethreads=0&lt;br /&gt;runqueue=0 [1]&lt;br /&gt;&lt;br /&gt;&lt;b&gt;SCHED 1009ms&lt;/b&gt;: gomaxprocs=1 idleprocs=0 threads=3 spinningthreads=0 idlethreads=1&lt;br /&gt;runqueue=0 [9] &lt;/div&gt;&lt;br /&gt;Let’s break down what each field represents and then understand the values based on the sample program:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;1009ms &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;: Time in milliseconds since the program started.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; This is the trace for the 1 second mark.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;gomaxprocs=1 &amp;nbsp;: Number of processors configured.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Only one processor is configured for this program.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;&lt;i&gt;Advanced Note:&lt;br /&gt;Think of a processor in this context as a logical processor and not a physical&amp;nbsp;processor. The scheduler&lt;/i&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;&lt;i&gt;runs goroutines on these logical processors which are&amp;nbsp;bound to a physical processor via the operating&lt;/i&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;&lt;i&gt;system thread that is attached.&amp;nbsp;The operating system will schedule the thread against any physical&lt;/i&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;&lt;i&gt;processor&amp;nbsp;that is available.&lt;/i&gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;threads=3 &amp;nbsp; &amp;nbsp; : Number of threads that the runtime is managing.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Three threads exist. One for the processor and 2 others&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; used by the runtime.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;idlethreads=1 : Number of threads that are not busy.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 1 thread idle (2 threads running).&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;idleprocs=0 &amp;nbsp; : Number of processors that are not busy.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 0 processors are idle (1 processor is busy).&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;runqueue=0 &amp;nbsp; &amp;nbsp;: Number of goroutines in the global run queue.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; All runnable goroutines have been moved to a local run queue.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;[9] &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : Number of goroutines in the local run queue.&lt;/div&gt;&lt;div style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 9 goroutines are waiting inside the local run queue. &lt;/div&gt;&lt;/div&gt;&lt;br /&gt;The runtime is giving us a lot of great information at the summary level. When we look at the information for the trace at the 1 second mark, we can see how one goroutine is running and the other nine goroutines are waiting inside the local run queue.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Diagram 1&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://4.bp.blogspot.com/-K4PmWQE_IEM/VOwJ3kczuMI/AAAAAAAANq4/SNo2CVNs9A0/s1600/diagram1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://4.bp.blogspot.com/-K4PmWQE_IEM/VOwJ3kczuMI/AAAAAAAANq4/SNo2CVNs9A0/s1600/diagram1.png&quot; height=&quot;404&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;In diagram 1, the processor is represented by the letter P, threads by the letter M and goroutines by the letter G. We can see how the global run queue is empty based on the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;runqueue&lt;/span&gt; value being 0. The processor is executing a goroutine based on the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;idleprocs&lt;/span&gt; value being 0 and the remaining goroutines we created are in the local run queue based on the value of 9 being inside the brackets.&lt;br /&gt;&lt;br /&gt;How does the trace change when we have more than one processor configured? Let’s run the program again adding &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GOMAXPROCS&lt;/span&gt; and look at the output traces that change:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;GOMAXPROCS=2 GODEBUG=schedtrace=1000 ./example&lt;br /&gt;&lt;br /&gt;&lt;b&gt;SCHED 0ms&lt;/b&gt;: gomaxprocs=2 idleprocs=1 threads=2 spinningthreads=0&lt;br /&gt;idlethreads=0 runqueue=0 [0 0]&lt;br /&gt;&lt;br /&gt;&lt;b&gt;SCHED 1002ms&lt;/b&gt;: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1&lt;br /&gt;idlethreads=1 runqueue=0 [0 4]&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;b&gt;SCHED 2006ms&lt;/b&gt;: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0&lt;br /&gt;idlethreads=1 runqueue=0 [4 4]&lt;br /&gt;&lt;br /&gt;...&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;b&gt;SCHED 6024ms&lt;/b&gt;: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0&lt;br /&gt;idlethreads=1 runqueue=2 [3 3]&lt;br /&gt;&lt;br /&gt;...&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;b&gt;SCHED 10049ms&lt;/b&gt;: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0&lt;br /&gt;idlethreads=1 runqueue=4 [2 2]&lt;br /&gt;...&lt;br /&gt;&lt;br /&gt;&lt;b&gt;SCHED 13067ms&lt;/b&gt;: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0&lt;br /&gt;idlethreads=1 runqueue=6 [1 1]&lt;br /&gt;&lt;br /&gt;...&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;b&gt;SCHED 17084ms&lt;/b&gt;: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0&lt;br /&gt;idlethreads=1 runqueue=8 [0 0]&lt;br /&gt;&lt;br /&gt;...&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;b&gt;SCHED 21100ms&lt;/b&gt;: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0&lt;br /&gt;idlethreads=2 runqueue=0 [0 0]&lt;/div&gt;&lt;br /&gt;Let’s focus on the trace for the 2 second mark when we run with two processors:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;SCHED 2002ms&lt;/b&gt;: gomaxprocs=2 &lt;b&gt;idleprocs=0&lt;/b&gt; threads=4 spinningthreads=0&lt;br /&gt;idlethreads=1&amp;nbsp;&lt;b&gt;runqueue=0 [4 4]&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;2002ms &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;: This is the trace for the 2 second mark.&lt;br /&gt;gomaxprocs=2 &amp;nbsp;: 2 processors are configured for this program.&lt;br /&gt;threads=4 &amp;nbsp; &amp;nbsp; : 4 threads exist. 2 for processors and 2 for the runtime.&lt;br /&gt;idlethreads=1 : 1 idle thread (3 threads running).&lt;br /&gt;idleprocs=0 &amp;nbsp; : 0 processors are idle (2 processors busy).&lt;br /&gt;runqueue=0 &amp;nbsp; &amp;nbsp;: All runnable goroutines have been moved to a local run queue.&lt;br /&gt;[4 4] &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 4 goroutines are waiting inside each local run queue. &lt;/div&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Diagram 2&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://4.bp.blogspot.com/-dsH00uAaRZA/VOwJ3rFZ0ZI/AAAAAAAANq0/kXV42KdoChM/s1600/diagram2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://4.bp.blogspot.com/-dsH00uAaRZA/VOwJ3rFZ0ZI/AAAAAAAANq0/kXV42KdoChM/s1600/diagram2.png&quot; height=&quot;640&quot; width=&quot;586&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;Let’s look at the information in diagram 2 for the trace at the 2 second mark. We can see how a goroutine is running in each processor. We can also see that eight goroutines are waiting inside of the local run queues, four goroutines inside each of the two local run queues.&lt;br /&gt;&lt;br /&gt;Things change when we get to the 6 second mark:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;SCHED 6024ms&lt;/b&gt;: gomaxprocs=2 &lt;b&gt;idleprocs=0&lt;/b&gt; threads=4 spinningthreads=0&lt;br /&gt;idlethreads=1 &lt;b&gt;runqueue=2 [3 3]&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;idleprocs=0 : 0 processors are idle (2 processors busy).&lt;br /&gt;runqueue=2 &amp;nbsp;: 2 goroutines returned and are waiting to be terminated.&lt;br /&gt;[3 3] &amp;nbsp; &amp;nbsp; &amp;nbsp; : 3 goroutines are waiting inside each local run queue.&lt;/div&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Diagram 3&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://4.bp.blogspot.com/-oPIGgdAkK4E/VOwJ3ph0uyI/AAAAAAAANq8/0eg9a941Wvo/s1600/diagram3.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://4.bp.blogspot.com/-oPIGgdAkK4E/VOwJ3ph0uyI/AAAAAAAANq8/0eg9a941Wvo/s1600/diagram3.png&quot; height=&quot;640&quot; width=&quot;586&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;When we get to the 6 second mark things change. Now in diagram 3, two of the goroutines we created completed their work and have been moved to the global run queue. We still have two goroutines running, one in each of the existing processors and three are waiting in each of the respective local run queues.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;Advanced Note:&lt;/span&gt;&lt;/i&gt;&lt;br /&gt;&lt;i&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;In many cases, goroutines are not moved back to the global run queue prior to being terminated. This program has created a special situation because the for loop is performing logic that runs for more than 10ms and is not calling into any functions. 10ms is the scheduling quant in the scheduler. After 10ms of execution, the scheduler tries to preempt goroutines. These goroutines can’t be preempted because they do not call into any functions. In this case, once the goroutines reach the wg.Done call, the goroutines are instantly preempted and moved to the global run queue for termination.&lt;/span&gt;&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;When the 17 second mark hits, we see the last two goroutines are now running:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;SCHED 17084ms&lt;/b&gt;: gomaxprocs=2 &lt;b&gt;idleprocs=0&lt;/b&gt; threads=4 spinningthreads=0&lt;br /&gt;idlethreads=1 &lt;b&gt;runqueue=8 [0 0]&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;idleprocs=0 : 0 processors are idle (2 processors busy).&lt;br /&gt;runqueue=8 &amp;nbsp;: 8 goroutines returned and are waiting to be terminated.&lt;br /&gt;[0 0] &amp;nbsp; &amp;nbsp; &amp;nbsp; : No goroutines are waiting inside any local run queue. &lt;/div&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Diagram 4&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/-dwY6yqyPxlE/VOwLC2EqP_I/AAAAAAAANrc/8dJPUjLgPiU/s1600/diagram4.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-dwY6yqyPxlE/VOwLC2EqP_I/AAAAAAAANrc/8dJPUjLgPiU/s1600/diagram4.png&quot; height=&quot;640&quot; width=&quot;586&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;In diagram 4, we see how eight goroutines are in the global run queue and the remaining last two goroutines are running. This leaves each of the respective local run queues empty.&lt;br /&gt;&lt;br /&gt;The final trace is at the 21 second mark:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;SCHED 21100ms&lt;/b&gt;: gomaxprocs=2 &lt;b&gt;idleprocs=2&lt;/b&gt; threads=4 spinningthreads=0&lt;br /&gt;idlethreads=2 &lt;b&gt;runqueue=0 [0 0]&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;idleprocs=2 : 2 processors are idle (0 processors busy).&lt;br /&gt;runqueue=0 &amp;nbsp;: All the goroutines that were in the queue have been terminated.&lt;br /&gt;[0 0] &amp;nbsp; &amp;nbsp; &amp;nbsp; : No goroutines are waiting inside any local run queue. &lt;/div&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Diagram 5&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://1.bp.blogspot.com/-Fl0_ZXFz3oQ/VOwJ4NG8rbI/AAAAAAAANrE/Ll97jiJOKyE/s1600/diagram5.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://1.bp.blogspot.com/-Fl0_ZXFz3oQ/VOwJ4NG8rbI/AAAAAAAANrE/Ll97jiJOKyE/s1600/diagram5.png&quot; height=&quot;640&quot; width=&quot;586&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;At this point, all the goroutines have finished their work and have been terminated.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Detailed Scheduler Trace&lt;/span&gt;&lt;br /&gt;The scheduler summary information is very helpful, but sometimes you need an even deeper view. In those cases, we can add the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;scheddetail&lt;/span&gt; option which will provide detailed trace information about each processor, thread and goroutine. Let’s run the program again, setting the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GODEBUG&lt;/span&gt; option to emit detailed trace information:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;GOMAXPROCS=2 GODEBUG=schedtrace=1000,scheddetail=1 ./example &lt;/div&gt;&lt;br /&gt;Here is the output at the 4 second mark:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;SCHED 4028ms&lt;/b&gt;: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=0&lt;br /&gt;idlethreads=1 runqueue=2 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0&lt;br /&gt;&lt;b&gt;P0&lt;/b&gt;: status=1 schedtick=10 syscalltick=0 m=3 runqsize=3 gfreecnt=0&lt;br /&gt;&lt;b&gt;P1&lt;/b&gt;: status=1 schedtick=10 syscalltick=1 m=2 runqsize=3 gfreecnt=0&lt;br /&gt;&lt;b&gt;M3&lt;/b&gt;: p=0 curg=4 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0 spinning=0 blocked=0 lockedg=-1&lt;br /&gt;&lt;b&gt;M2&lt;/b&gt;: p=1 curg=10 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0 spinning=0 blocked=0 lockedg=-1&lt;br /&gt;&lt;b&gt;M1&lt;/b&gt;: p=-1 curg=-1 mallocing=0 throwing=0 gcing=0 locks=1 dying=0 helpgc=0 spinning=0 blocked=0 lockedg=-1&lt;br /&gt;&lt;b&gt;M0&lt;/b&gt;: p=-1 curg=-1 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0 spinning=0 blocked=0 lockedg=-1&lt;br /&gt;&lt;b&gt;G1&lt;/b&gt;: status=4(semacquire) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G2&lt;/b&gt;: status=4(force gc (idle)) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G3&lt;/b&gt;: status=4(GC sweep wait) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G4&lt;/b&gt;: status=2(sleep) m=3 lockedm=-1&lt;br /&gt;&lt;b&gt;G5&lt;/b&gt;: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G6&lt;/b&gt;: status=1(stack growth) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G7&lt;/b&gt;: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G8&lt;/b&gt;: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G9&lt;/b&gt;: status=1(stack growth) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G10&lt;/b&gt;: status=2(sleep) m=2 lockedm=-1&lt;br /&gt;&lt;b&gt;G11&lt;/b&gt;: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G12&lt;/b&gt;: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G13&lt;/b&gt;: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;&lt;b&gt;G17&lt;/b&gt;: status=4(timer goroutine (idle)) m=-1 lockedm=-1 &lt;/div&gt;&lt;br /&gt;The summary section is similar but now we have detailed lines for the processors, threads and goroutines. Let’s start with the processors:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;P0&lt;/b&gt;: status=1 schedtick=10 syscalltick=0 m=3 runqsize=3 gfreecnt=0&lt;br /&gt;&lt;br /&gt;&lt;b&gt;P1&lt;/b&gt;: status=1 schedtick=10 syscalltick=1 m=2 runqsize=3 gfreecnt=0 &lt;/div&gt;&lt;br /&gt;P’s represents a processor. Since &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GOMAXPROCS&lt;/span&gt; is set to 2, we see two P’s listed in the trace. Next, let’s look at the threads:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;M3&lt;/b&gt;: p=0 curg=4 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0&lt;br /&gt;spinning=0 blocked=0 lockedg=-1&lt;br /&gt;&lt;br /&gt;&lt;b&gt;M2&lt;/b&gt;: p=1 curg=10 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0&lt;br /&gt;spinning=0 blocked=0 lockedg=-1&lt;br /&gt;&lt;br /&gt;&lt;b&gt;M1&lt;/b&gt;: p=-1 curg=-1 mallocing=0 throwing=0 gcing=0 locks=1 dying=0 helpgc=0&lt;br /&gt;spinning=0 blocked=0 lockedg=-1&lt;br /&gt;&lt;br /&gt;&lt;b&gt;M0&lt;/b&gt;: p=-1 curg=-1 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0&lt;br /&gt;spinning=0 blocked=0 lockedg=-1 &lt;/div&gt;&lt;br /&gt;M’s represents a thread. Since the threads value is set to 4 in the summary trace, we see four M’s listed in the detail. The detailed trace information shows which threads belong to which processors:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;P0&lt;/b&gt;: status=1 schedtick=10 syscalltick=0 &lt;b&gt;m=3&lt;/b&gt; runqsize=3 gfreecnt=0&lt;br /&gt;&lt;br /&gt;&lt;b&gt;M3&lt;/b&gt;: &lt;b&gt;p=0&lt;/b&gt; curg=4 mallocing=0 throwing=0 gcing=0 locks=0 dying=0 helpgc=0&lt;br /&gt;spinning=0 blocked=0 lockedg=-1 &lt;/div&gt;&lt;br /&gt;Here we see how thread M3 is attached to processor P0. This information is in both the P and M trace records.&lt;br /&gt;&lt;br /&gt;A G represents a goroutine. At the 4 second mark we see that there are fourteen goroutines that currently exist and seventeen goroutines have been created since the program started. We know the total number of goroutines created because of the number attached to the last G listed in the trace:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;G17&lt;/b&gt;: status=4(timer goroutine (idle)) m=-1 lockedm=-1 &lt;/div&gt;&lt;br /&gt;If this program continued to create goroutines, we would see this number increase linearly. If this program was handling web requests for example, we could use this number to get a general idea of the number of requests that have been handled. This estimate would only be close if the program didn’t create any other goroutines during the handling of the request.&lt;br /&gt;&lt;br /&gt;Next, let’s look at the goroutine the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt; function is running against:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;G1&lt;/b&gt;: status=4(semacquire) m=-1 lockedm=-1&lt;br /&gt;&lt;br /&gt;30 &amp;nbsp; &amp;nbsp; wg.Done()&lt;/div&gt;&lt;br /&gt;We can see that the goroutine for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt; function is in a status of 4, blocked on a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;semacquire&lt;/span&gt; which represents the wait group &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Wait&lt;/span&gt; call.&lt;br /&gt;&lt;br /&gt;To better understand the rest of the goroutines in this trace, it is helpful to know what the status numbers represent. Here is a list of status codes that are declared in the header file for the runtime:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;status: http://golang.org/src/runtime/runtime.h&lt;br /&gt;Gidle, &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 0 &lt;br /&gt;Grunnable, &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 1 runnable and on a run queue&lt;br /&gt;Grunning, &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 2 running&lt;br /&gt;Gsyscall, &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 3 performing a syscall&lt;br /&gt;Gwaiting, &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 4 waiting for the runtime&lt;br /&gt;Gmoribund_unused,      // 5 currently unused, but hardcoded in gdb scripts&lt;br /&gt;Gdead, &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 6 goroutine is dead&lt;br /&gt;Genqueue, &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 7 only the Gscanenqueue is used&lt;br /&gt;Gcopystack, &amp;nbsp; &amp;nbsp; &amp;nbsp; // 8 in this state when newstack is moving the stack &lt;/div&gt;&lt;br /&gt;When we look at the ten goroutines we created, we can now look at their state and better understand what each is doing:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;// Goroutines running in a processor. (idleprocs=0)&lt;/b&gt;&lt;br /&gt;G4: status=2(sleep) &lt;b&gt;m=3&lt;/b&gt; lockedm=-1 &amp;nbsp; -- Thread M3 / Processor P0&lt;br /&gt;G10: status=2(sleep)&lt;b&gt; m=2&lt;/b&gt; lockedm=-1 &amp;nbsp;-- Thread M2 / Processor P1&lt;br /&gt;&lt;br /&gt;&lt;b&gt;// Goroutines waiting to be run on a particular processor. (runqsize=3)&lt;/b&gt;&lt;br /&gt;G5: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;G7: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;G8: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;&lt;br /&gt;&lt;b&gt;// Goroutines waiting to be run on a particular processor. (runqsize=3)&lt;/b&gt;&lt;br /&gt;G11: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;G12: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;G13: status=1(sleep) m=-1 lockedm=-1&lt;br /&gt;&lt;br /&gt;&lt;b&gt;// Goroutines waiting on the global run queue. (runqueue=2)&lt;/b&gt;&lt;br /&gt;G6: status=1(stack growth) m=-1 lockedm=-1&lt;br /&gt;G9: status=1(stack growth) m=-1 lockedm=-1&lt;/div&gt;&lt;br /&gt;With a basic understanding of the scheduler and knowing the behavior of our program, we can get a detailed view of how things are being scheduled and the state of each processor, thread and goroutine in our program.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;: &lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;GODEBUG&lt;/span&gt; variable is a great way to peek into the mind of the scheduler while your program runs. It can tell you a lot about how your program is behaving. If you want to learn more, start by writing some simple programs that you can use to predict the traces coming from the scheduler. Learn what to expect before trying to look at a trace for more complicated programs.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/9092823878976582889/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2015/02/scheduler-tracing-in-go.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/9092823878976582889'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/9092823878976582889'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2015/02/scheduler-tracing-in-go.html' title='Scheduler Tracing In Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://4.bp.blogspot.com/-K4PmWQE_IEM/VOwJ3kczuMI/AAAAAAAANq4/SNo2CVNs9A0/s72-c/diagram1.png" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-2470174020865580115</id><published>2015-01-11T09:33:00.000-05:00</published><updated>2015-01-11T13:46:11.509-05:00</updated><title type='text'>Stack Traces In Go</title><content type='html'>&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;br /&gt;Having some basic skills in debugging Go programs can save any programmer a good amount of time trying to identify problems. I believe in logging as much information as you can, but sometimes a panic occurs and what you logged is not enough. Understanding the information in a stack trace can sometimes mean the difference between finding the bug now or needing to add more logging and waiting for it to happen again.&lt;br /&gt;&lt;br /&gt;I have been seeing stack traces since I started writing Go. At some point we all do something silly that causes the runtime to kill our program and throw a stack trace. I am going to show you the information the stack trace provides, including how to identify the value for each parameter that was passed into each function.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Functions&lt;/span&gt;&lt;br /&gt;Let’s start with a small piece of code that will produce a stack trace:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 func main() {&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; slice := make([]string, 2, 4)&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; Example(slice, &quot;hello&quot;, 10)&lt;br /&gt;06 }&lt;br /&gt;07&lt;br /&gt;08 func Example(slice []string, str string, i int) {&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; panic(&quot;Want stack trace&quot;)&lt;br /&gt;10 } &lt;/div&gt;&lt;br /&gt;Listing 1 shows a program where the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt; function calls the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; function on line 05. The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; function is declared on line 08 and accepts three parameters, a slice of strings, a string and an integer. The only code &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; executes is a call to the built-in function &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;panic&lt;/span&gt; on line 09, which immediately produces a stack trace:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 2&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Panic: Want stack trace&lt;br /&gt;&lt;br /&gt;goroutine 1 [running]:&lt;br /&gt;main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; temp/main.go:9 +0x64&lt;br /&gt;main.main()&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; temp/main.go:5 +0x85&lt;br /&gt;&lt;br /&gt;goroutine 2 [runnable]:&lt;br /&gt;runtime.forcegchelper()&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /Users/bill/go/src/runtime/proc.go:90&lt;br /&gt;runtime.goexit()&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /Users/bill/go/src/runtime/asm_amd64.s:2232 +0x1&lt;br /&gt;&lt;br /&gt;goroutine 3 [runnable]:&lt;br /&gt;runtime.bgsweep()&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /Users/bill/go/src/runtime/mgc0.go:82&lt;br /&gt;runtime.goexit()&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /Users/bill/go/src/runtime/asm_amd64.s:2232 +0x1&lt;/div&gt;&lt;br /&gt;The stack trace in listing 2 shows all the goroutines that existed at the time of the panic, the status of each routine and the call stack under that respective goroutine. The goroutines that were running and the one that caused the stack trace will be at the top. Let’s focus on the goroutine that panicked.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 3&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 goroutine 1 [running]:&lt;br /&gt;02 main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;temp/main.go:9 +0x64&lt;br /&gt;03 main.main()&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;temp/main.go:5 +0x85&lt;/div&gt;&lt;br /&gt;The stack trace on line 01 in listing 3 is showing that goroutine 1 was running prior to the panic. On line 02, we see that the code that panicked was in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; function in package &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt;. The line indented shows the code file and path this function is located in, plus the line of code that was executing. In this case, the code on line 09 was running which is the call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;panic&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;Line 03 shows the name of the function that called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt;. This is the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt; function in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt; package. Underneath the function name once again, the line that is indented shows the code file, path and line of code where the call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; was made.&lt;br /&gt;&lt;br /&gt;The stack trace is showing the chain of function calls in the scope of that goroutine up to the time the panic occurred. Now, let’s focus on the values for each parameter that was passed into the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; function:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 4&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Declaration&lt;br /&gt;main.Example(slice []string, str string, i int)&lt;br /&gt;&lt;br /&gt;// Call to Example by main.&lt;br /&gt;slice := make([]string, 2, 4)&lt;br /&gt;Example(slice, &quot;hello&quot;, 10)&lt;br /&gt;&lt;br /&gt;// Stack trace&lt;br /&gt;main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)&lt;/div&gt;&lt;br /&gt;Listing 4 shows the values from the stack trace that were passed into the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; function when the call was made by &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt; and the declaration of the function. When you compare the values from the stack trace with the function declaration, it doesn’t seem to match up. The declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; function accepts three parameters but the stack trace is showing six hexadecimal values. The key to understanding how the values do match up with the parameters requires knowing the implementation for each parameter type.&lt;br /&gt;&lt;br /&gt;Let’s start with the first parameter which is a slice of strings. A &lt;a href=&quot;http://www.goinggo.net/2013/08/understanding-slices-in-go-programming.html&quot; target=&quot;_blank&quot;&gt;slice&lt;/a&gt; is a reference type in Go. This means the value for a slice is a header value with a pointer to some underlying data. In the case of a slice, the header value is a three &lt;a href=&quot;http://en.wikipedia.org/wiki/Word_%28computer_architecture%29&quot; target=&quot;_blank&quot;&gt;word&lt;/a&gt; structure that contains a pointer to an underlying array, the length of the slice and the capacity. The values associated with the slice header are represented by the first three values in the stack trace:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 5&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Slice parameter value&lt;br /&gt;slice := make([]string, 2, 4)&lt;br /&gt;&lt;br /&gt;// Slice header values&lt;br /&gt;Pointer: &amp;nbsp;0x2080c3f50&lt;br /&gt;Length: &amp;nbsp; 0x2&lt;br /&gt;Capacity: 0x4&lt;br /&gt;&lt;br /&gt;// Declaration&lt;br /&gt;main.Example(&lt;b&gt;slice []string&lt;/b&gt;, str string, i int)&lt;br /&gt;&lt;br /&gt;// Stack trace&lt;br /&gt;main.Example(&lt;b&gt;0x2080c3f50, 0x2, 0x4&lt;/b&gt;, 0x425c0, 0x5, 0xa)&lt;/div&gt;&lt;br /&gt;Listing 5 shows how the first three values in the stack trace do match up with the slice parameter. The first value represents the pointer to the underlying array of strings. The length and capacity numbers used to initialize the slice match with the second and third values. Those three values represent each value of the slice header, the first parameter. &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;b&gt;Figure 1&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://2.bp.blogspot.com/-kYOH7WdUTl4/VLKHpOjGpTI/AAAAAAAANlM/C-wTljPDpWA/s1600/image02.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://2.bp.blogspot.com/-kYOH7WdUTl4/VLKHpOjGpTI/AAAAAAAANlM/C-wTljPDpWA/s1600/image02.png&quot; height=&quot;329&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;i&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;figure provided by Georgi Knox&lt;/span&gt;&lt;/i&gt;&lt;br /&gt;&lt;i&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/i&gt;Now let’s look at the second parameter which is a string. A &lt;a href=&quot;http://blog.golang.org/strings&quot; target=&quot;_blank&quot;&gt;string&lt;/a&gt; is also a reference type but this header value is immutable. The header value for a string is declared as a two word structure that contains a pointer to an underlying byte array and the length of the string:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 6&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// String parameter value&lt;br /&gt;&quot;hello&quot;&lt;br /&gt;&lt;br /&gt;// String header values&lt;br /&gt;Pointer: 0x425c0&lt;br /&gt;Length: &amp;nbsp;0x5&lt;br /&gt;&lt;br /&gt;// Declaration&lt;br /&gt;main.Example(slice []string, &lt;b&gt;str string&lt;/b&gt;, i int)&lt;br /&gt;&lt;br /&gt;// Stack trace&lt;br /&gt;main.Example(0x2080c3f50, 0x2, 0x4, &lt;b&gt;0x425c0, 0x5&lt;/b&gt;, 0xa) &lt;/div&gt;&lt;br /&gt;Listing 6 shows how the fourth and fifth values in the stack trace do match up with the string parameter. The fourth value represents the pointer to the underlying array of bytes and the fifth value is the length of the string which was 5. The string &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;&quot;hello&quot;&lt;/span&gt; requires 5 bytes. Those two values represent each value of the string header, the second parameter.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;b&gt;Figure 2&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://4.bp.blogspot.com/-7AaBsITFEZ4/VLKHpYulXsI/AAAAAAAANlI/-q9z2QHsYc4/s1600/image01.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://4.bp.blogspot.com/-7AaBsITFEZ4/VLKHpYulXsI/AAAAAAAANlI/-q9z2QHsYc4/s1600/image01.png&quot; height=&quot;252&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;i&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;figure provided by Georgi Knox&lt;/span&gt;&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;The third parameter is an integer which is a single word value:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 7&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Integer parameter value&lt;br /&gt;10&lt;br /&gt;&lt;br /&gt;// Integer value&lt;br /&gt;Base 16: 0xa&lt;br /&gt;&lt;br /&gt;// Declaration&lt;br /&gt;main.Example(slice []string, str string, &lt;b&gt;i int&lt;/b&gt;)&lt;br /&gt;&lt;br /&gt;// Stack trace&lt;br /&gt;main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, &lt;b&gt;0xa&lt;/b&gt;) &lt;/div&gt;&lt;br /&gt;Listing 7 shows how the last value in the stack trace matches up with the integer parameter. The very last value in the trace is hexadecimal number &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;0xa&lt;/span&gt;, which is the value of 10. The same value that was passed in for that parameter. That value represents the third parameter.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;b&gt;Figure 3&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://4.bp.blogspot.com/-yg82d5vc7ao/VLKHpJkNAAI/AAAAAAAANlQ/gVSOHwlbFGs/s1600/image00.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://4.bp.blogspot.com/-yg82d5vc7ao/VLKHpJkNAAI/AAAAAAAANlQ/gVSOHwlbFGs/s1600/image00.png&quot; height=&quot;160&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;i&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;figure provided by Georgi Knox&lt;/span&gt;&lt;/i&gt;&lt;br /&gt;&lt;i&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Methods&lt;/span&gt;&lt;br /&gt;Let’s change the program so the Example function is now a method:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 8&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 import &quot;fmt&quot;&lt;br /&gt;04&lt;br /&gt;05 type trace struct{}&lt;br /&gt;06&lt;br /&gt;07 func main() {&lt;br /&gt;08 &amp;nbsp; &amp;nbsp; slice := make([]string, 2, 4)&lt;br /&gt;09&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; var t trace&lt;br /&gt;11 &amp;nbsp; &amp;nbsp; t.Example(slice, &quot;hello&quot;, 10)&lt;br /&gt;12 }&lt;br /&gt;13&lt;br /&gt;14 func (t *trace) Example(slice []string, str string, i int) {&lt;br /&gt;15 &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;Receiver Address: %p\n&quot;, t)&lt;br /&gt;16 &amp;nbsp; &amp;nbsp; panic(&quot;Want stack trace&quot;)&lt;br /&gt;17 } &lt;/div&gt;&lt;br /&gt;Listing 8 changes the original program by declaring a new type named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;trace&lt;/span&gt; on line 05 and converting the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; function into a method on line 14. The conversion is accomplished by re-declaring the function with a pointer receiver of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;trace&lt;/span&gt;. Then on line 10, a variable named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;t&lt;/span&gt; is declared of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;trace&lt;/span&gt; and the method call is made with the variable on line 11.&lt;br /&gt;&lt;br /&gt;Since the method is declared with a pointer receiver, Go will take the address of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;t&lt;/span&gt; variable to support the receiver type, even though the &lt;a href=&quot;http://www.goinggo.net/2014/05/methods-interfaces-and-embedded-types.html&quot; target=&quot;_blank&quot;&gt;method call&lt;/a&gt; is made with a value. This time when the program is run, the stack trace is a little different:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 9&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Receiver Address: &lt;b&gt;0x1553a8&lt;/b&gt;&lt;br /&gt;panic: Want stack trace&lt;br /&gt;&lt;br /&gt;01 goroutine 1 [running]:&lt;br /&gt;02 main.&lt;b&gt;(*trace)&lt;/b&gt;.Example(&lt;b&gt;0x1553a8&lt;/b&gt;, 0x2081b7f50, 0x2, 0x4, 0xdc1d0, 0x5, 0xa)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;temp/main.go:16 +0x116&lt;br /&gt;&lt;br /&gt;03 main.main()&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;temp/main.go:11 +0xae &lt;/div&gt;&lt;br /&gt;The first thing you should notice in listing 9 is that the stack trace on line 02 is making it clear this was a method call using a pointer receiver. The name of the function is now displayed with &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;(*trace)&lt;/span&gt; between the package name and the method name. The second thing to notice is how the value list now shows the value of the receiver first. Method calls are really function calls with the first parameter being the receiver value. We are seeing this implementation detail in action from the stack trace.&lt;br /&gt;&lt;br /&gt;Since nothing else changed with the declaration or call to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; method, all the other values remain the same. The line numbers where the call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; is made and where the panic occurred changed and reflects the new code.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Packing&lt;/span&gt;&lt;br /&gt;When you have multiple parameters that fit inside of a single word, then the values for the parameters in the stack trace will be packed together:&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;b&gt;Listing 10&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 func main() {&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; Example(true, false, true, 25)&lt;br /&gt;05 }&lt;br /&gt;06 &lt;br /&gt;07 func Example(b1, b2, b3 bool, i uint8) {&lt;br /&gt;08 &amp;nbsp; &amp;nbsp; panic(&quot;Want stack trace&quot;)&lt;br /&gt;09 } &lt;/div&gt;&lt;br /&gt;Listing 10 shows a new sample program that changes the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt; function to accept four parameters. The first three are booleans and the last one is an eight bit unsigned integer. A boolean value is also an eight bit value, so all four parameters fit inside of a single word on both 32 and 64 bit architectures. When the program runs, it produces an interesting stack trace:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;b&gt;Listing 11&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 goroutine 1 [running]:&lt;br /&gt;02 main.Example(&lt;b&gt;0x19010001&lt;/b&gt;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;temp/main.go:8 +0x64&lt;br /&gt;03 main.main()&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;temp/main.go:4 +0x32&lt;/div&gt;&lt;br /&gt;Instead of there being four values in the stack trace for the call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Example&lt;/span&gt;, there is a single value. All four individual 8 bit values were packed together into a single word:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;b&gt;Listing 12&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Parameter values&lt;br /&gt;true, false, true, 25&lt;br /&gt;&lt;br /&gt;// Word value&lt;br /&gt;Bits &amp;nbsp; &amp;nbsp;Binary &amp;nbsp; &amp;nbsp; &amp;nbsp;Hex &amp;nbsp; Value&lt;br /&gt;00-07 &amp;nbsp; 0000 0001 &amp;nbsp; &lt;b&gt;01&lt;/b&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;true&lt;br /&gt;08-15 &amp;nbsp; 0000 0000 &amp;nbsp; &lt;b&gt;00&lt;/b&gt;&amp;nbsp; &amp;nbsp; false&lt;br /&gt;16-23 &amp;nbsp; 0000 0001 &amp;nbsp; &lt;b&gt;01&lt;/b&gt;&amp;nbsp; &amp;nbsp; true&lt;br /&gt;24-31 &amp;nbsp; 0001 1001 &amp;nbsp; &lt;b&gt;19&lt;/b&gt;&amp;nbsp; &amp;nbsp; 25&lt;br /&gt;&lt;br /&gt;// Declaration&lt;br /&gt;main.Example(&lt;b&gt;b1, b2, b3 bool, i uint8&lt;/b&gt;)&lt;br /&gt;&lt;br /&gt;// Stack trace&lt;br /&gt;main.Example(&lt;b&gt;0x19010001&lt;/b&gt;)&lt;/div&gt;&lt;br /&gt;Listing 12 shows how the value in the stack trace matches up with all four parameter values that were passed in. The value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;true&lt;/span&gt; is an 8 bit value that is represented with the value of 1 and the value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;false&lt;/span&gt; is represented with the value of 0. The value of 25 in binary is 11001 which converts to 19 in hexadecimal. Now when we look at the hexadecimal value represented in the stack trace, we see how it does represent the values that were passed in.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;br /&gt;The Go runtime provides a great deal of information to help us debug our programs. In this post we concentrated on stack traces. The ability to decode the values that were passed into each function throughout the call stack is huge. It has helped me more than once to identify my bug very quickly. Now that you know how to read stack traces, hopefully you can leverage this knowledge the next time a stack trace happens to you.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/2470174020865580115/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2015/01/stack-traces-in-go.html#comment-form' title='3 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/2470174020865580115'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/2470174020865580115'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2015/01/stack-traces-in-go.html' title='Stack Traces In Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://2.bp.blogspot.com/-kYOH7WdUTl4/VLKHpOjGpTI/AAAAAAAANlM/C-wTljPDpWA/s72-c/image02.png" height="72" width="72"/><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-5789843912452440288</id><published>2014-12-16T19:58:00.001-05:00</published><updated>2014-12-16T19:58:20.452-05:00</updated><title type='text'>Using Pointers In *Go</title><content type='html'>&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;br /&gt;I am asked quite a bit about when and when not to use pointers in Go. The problem most people have, is that they try to make this decision based on what they think the performance tradeoff will be. Hence the problem, don’t make coding decisions based on unfounded thoughts you may have about performance. Make coding decisions based on the code being idiomatic, simple, readable and reasonable.&lt;br /&gt;&lt;br /&gt;My use of pointers is based on discoveries I have made looking at code from the standard library. There are always exceptions to these rules, but what I will show you is common practice. It starts with classifying the type of value that needs to be shared. These type classifications are built-in, struct and reference types. Let’s look at each one individually.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Built-In Types&lt;/span&gt;&lt;br /&gt;Go’s &lt;a href=&quot;http://golang.org/ref/spec#Types&quot; target=&quot;_blank&quot;&gt;built-in types&lt;/a&gt; represent primitive data values that are the building blocks for managing and working with data. I group these types collectively as the set of boolean, numeric and string types. When declaring functions and methods that accept values of these types, the standard library rarely shares them with a pointer.&lt;br /&gt;&lt;br /&gt;Let’s start by looking at the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;isShellSpecialVar&lt;/span&gt; function from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;env&lt;/span&gt; package:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/os/env.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/os/env.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;38 func isShellSpecialVar(c uint8) bool {&lt;br /&gt;39 &amp;nbsp; &amp;nbsp; switch c {&lt;br /&gt;40 &amp;nbsp; &amp;nbsp; case &#39;*&#39;, &#39;#&#39;, &#39;$&#39;, &#39;@&#39;, &#39;!&#39;, &#39;?&#39;, &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;:&lt;br /&gt;41 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return true&lt;br /&gt;42 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;43 &amp;nbsp; &amp;nbsp; return false&lt;br /&gt;44 } &lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;isShellSpecialVar&lt;/span&gt; function in listing 1 is declared to accept a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;uint8&lt;/span&gt; and return a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bool&lt;/span&gt;. For the caller to use this function, they must pass a copy of their &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;uint8&lt;/span&gt; type value into the function. This is the same for the return value. A copy of the function’s &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bool&lt;/span&gt; type value is being returned back to the caller.&lt;br /&gt;&lt;br /&gt;Next, let’s look at the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;getShellName&lt;/span&gt; function from the same &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;env&lt;/span&gt; package:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 2&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/os/env.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/os/env.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;54 func getShellName(s string) (string, int) {&lt;br /&gt;55 &amp;nbsp; &amp;nbsp; switch {&lt;br /&gt;56 &amp;nbsp; &amp;nbsp; case s[0] == &#39;{&#39;:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;. . .&lt;br /&gt;66 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return &quot;&quot;, 1 // Bad syntax; just eat the brace.&lt;br /&gt;67 &amp;nbsp; &amp;nbsp; case isShellSpecialVar(s[0]):&lt;br /&gt;68 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return s[0:1], 1&lt;br /&gt;69 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;. . .&lt;br /&gt;74 &amp;nbsp; &amp;nbsp; return s[:i], i&lt;br /&gt;75 } &lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;getShellName&lt;/span&gt; function in listing 2 is declared to accept a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; and return two values, one of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; and the other of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;int&lt;/span&gt;. A &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; is a special built-in type in Go that represents an immutable slice of bytes. Since this slice can’t grow, the capacity value is not associated with its &lt;a href=&quot;http://www.goinggo.net/2013/08/understanding-slices-in-go-programming.html&quot; target=&quot;_blank&quot;&gt;slice header&lt;/a&gt;. It is best to treat values of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; the same way you treat boolean and numeric type values, as a primitive data value.&lt;br /&gt;&lt;br /&gt;When a call is made to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;getShellName&lt;/span&gt;, the caller passes a copy of its &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; value into the function. The function generates a new &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; value and returns a copy of that value back to the caller. All the values being passed in and out of this function are copies of the original values.&lt;br /&gt;&lt;br /&gt;This practice of sharing copies of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; values is very prevalent in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;strings&lt;/span&gt; package:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 3&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/strings/strings.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/strings/strings.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;620 func Trim(s string, cutset string) string {&lt;br /&gt;621 &amp;nbsp; &amp;nbsp; if s == &quot;&quot; || cutset == &quot;&quot; {&lt;br /&gt;622 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return s&lt;br /&gt;623 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;624 &amp;nbsp; &amp;nbsp; return TrimFunc(s, makeCutsetFunc(cutset))&lt;br /&gt;625 }&lt;/div&gt;&lt;br /&gt;All of the functions in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;strings&lt;/span&gt; package accept copies of the caller’s &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; values and return copies of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; values they create. Listing 3 shows the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Trim&lt;/span&gt; function. The function accepts copies of two &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; values, and returns a copy of either the first &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; value that is passed in or a copy of a new &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; value that has trimmed out the cutset.&lt;br /&gt;&lt;br /&gt;If you review more code from the standard library that share built-in type values, you will see how these values are rarely shared with a pointer. If a function or method needs to change the value of a built-in type, a new value reflecting that change is often returned back to the caller.&lt;br /&gt;&lt;br /&gt;In general, don’t share built-in type values with a pointer.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Struct Types&lt;/span&gt;&lt;br /&gt;&lt;a href=&quot;http://golang.org/ref/spec#Struct_types&quot; target=&quot;_blank&quot;&gt;Struct&lt;/a&gt; types allow for the creation of complex data types by composing different types together. This is accomplished by composing a sequence of fields, each which with a name and a type. They also support &lt;a href=&quot;http://www.goinggo.net/2014/05/methods-interfaces-and-embedded-types.html&quot; target=&quot;_blank&quot;&gt;embedding&lt;/a&gt;, which adds to the way struct types can be composed.&lt;br /&gt;&lt;br /&gt;Struct types can be implemented to behave like built-in types. When they are, you should treat them as such. To see a struct type that behaves as a primitive data value, we can look at the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;time&lt;/span&gt; package:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 4&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/time/time.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/time/time.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;39 type Time struct {&lt;br /&gt;40 &amp;nbsp; &amp;nbsp; // sec gives the number of seconds elapsed since&lt;br /&gt;41 &amp;nbsp; &amp;nbsp; // January 1, year 1 00:00:00 UTC.&lt;br /&gt;42 &amp;nbsp; &amp;nbsp; sec int64&lt;br /&gt;43&lt;br /&gt;44 &amp;nbsp; &amp;nbsp; // nsec specifies a non-negative nanosecond&lt;br /&gt;45 &amp;nbsp; &amp;nbsp; // offset within the second named by Seconds.&lt;br /&gt;46 &amp;nbsp; &amp;nbsp; // It must be in the range [0, 999999999].&lt;br /&gt;47 &amp;nbsp; &amp;nbsp; nsec int32&lt;br /&gt;48&lt;br /&gt;49 &amp;nbsp; &amp;nbsp; // loc specifies the Location that should be used to&lt;br /&gt;50 &amp;nbsp; &amp;nbsp; // determine the minute, hour, month, day, and year&lt;br /&gt;51 &amp;nbsp; &amp;nbsp; // that correspond to this Time.&lt;br /&gt;52 &amp;nbsp; &amp;nbsp; // Only the zero Time has a nil Location.&lt;br /&gt;53 &amp;nbsp; &amp;nbsp; // In that case it is interpreted to mean UTC.&lt;br /&gt;54 &amp;nbsp; &amp;nbsp; loc *Location&lt;br /&gt;55 } &lt;/div&gt;&lt;br /&gt;Listing 4 shows the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt; struct type. This type represents time and has been implemented to behave as a primitive data value. If you look at the factory function &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Now&lt;/span&gt;, you will see it returns a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt;, not a pointer:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 5&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/time/time.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/time/time.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;781 func Now() Time {&lt;br /&gt;782 &amp;nbsp; &amp;nbsp; sec, nsec := now()&lt;br /&gt;783 &amp;nbsp; &amp;nbsp; return Time{sec + unixToInternal, nsec, Local}&lt;br /&gt;784 } &lt;/div&gt;&lt;br /&gt;Listing 5 shows how the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Now&lt;/span&gt; function returns a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt;. This is an indication that values of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt; are safe to copy and is the preferred way to share them. Next, let’s look at a method that is used to change the value of a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt; value:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 6&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/time/time.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/time/time.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;610 func (t Time) Add(d Duration) Time {&lt;br /&gt;611 &amp;nbsp; &amp;nbsp; t.sec += int64(d / 1e9)&lt;br /&gt;612 &amp;nbsp; &amp;nbsp; nsec := int32(t.nsec) + int32(d%1e9)&lt;br /&gt;613 &amp;nbsp; &amp;nbsp; if nsec &amp;gt;= 1e9 {&lt;br /&gt;614 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t.sec++&lt;br /&gt;615 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nsec -= 1e9&lt;br /&gt;616 &amp;nbsp; &amp;nbsp; } else if nsec &amp;lt; 0 {&lt;br /&gt;617 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t.sec--&lt;br /&gt;618 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nsec += 1e9&lt;br /&gt;619 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;620 &amp;nbsp; &amp;nbsp; t.nsec = nsec&lt;br /&gt;621 &amp;nbsp; &amp;nbsp; return t&lt;br /&gt;622 } &lt;/div&gt;&lt;br /&gt;Just like we saw when working with built-in types, listing 6 shows how the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Add&lt;/span&gt; method is called against a copy of the caller’s &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt; value. The method changes the local copy of the receiver value and returns a copy of that change back to the caller.&lt;br /&gt;&lt;br /&gt;Functions that accept &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt; values also accept copies of these values:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 7&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/time/time.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/time/time.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;1118 func div(t Time, d Duration) (qmod2 int, r Duration) { &lt;/div&gt;&lt;br /&gt;Listing 7 shows the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;div&lt;/span&gt; function which accepts a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Duration&lt;/span&gt;. Again, values of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt; are treated like a primitive data type and are copied when shared.&lt;br /&gt;&lt;br /&gt;Most of the time struct types are not created to behave like a primitive data type. In these cases, sharing the value by using a pointer is a better way to go. Let’s look at an example from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;os&lt;/span&gt; package:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 8&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/os/file.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/os/file.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;238 func Open(name string) (file *File, err error) {&lt;br /&gt;239 &amp;nbsp; &amp;nbsp; return OpenFile(name, O_RDONLY, 0)&lt;br /&gt;240 } &lt;/div&gt;&lt;br /&gt;In listing 8 we see the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Open&lt;/span&gt; function from the os package. It opens a file for reading and returns a pointer to a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt;. Next, let’s look at the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; struct type for the UNIX platform:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 9&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/os/file_unix.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/os/file_unix.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;15 // File represents an open file descriptor.&lt;br /&gt;16 type File struct {&lt;br /&gt;17 &amp;nbsp; &amp;nbsp; *file&lt;br /&gt;18 }&lt;br /&gt;19&lt;br /&gt;20 // file is the real representation of *File.&lt;br /&gt;21 // The extra level of indirection ensures that no clients of os&lt;br /&gt;22 // can overwrite this data, which could cause the finalizer&lt;br /&gt;23 // to close the wrong file descriptor.&lt;br /&gt;24 type file struct {&lt;br /&gt;25 &amp;nbsp; &amp;nbsp; fd      int&lt;br /&gt;26 &amp;nbsp; &amp;nbsp; name    string&lt;br /&gt;27 &amp;nbsp; &amp;nbsp; dirinfo *dirInfo // nil unless directory being read&lt;br /&gt;28 &amp;nbsp; &amp;nbsp; nepipe  int32    // number of consecutive EPIPE in Write&lt;br /&gt;29 } &lt;/div&gt;&lt;br /&gt;I left the comments for these type declarations in listing 9 because they really bring home the point I want to make. When you have a factory function like &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Open&lt;/span&gt; that is providing you a pointer, it is a good sign that you should not be making copies of the referenced value being returned. &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Open&lt;/span&gt; is returning a pointer because it is not safe to make copies of the referenced &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; value being returned. The value should always be used and shared through the pointer.&lt;br /&gt;&lt;br /&gt;Even if a function or method is not changing the state of a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; struct type value, it still needs to be shared with a pointer. Let’s look at the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;epipecheck&lt;/span&gt; function from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;os&lt;/span&gt; package for the UNIX platform:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 10&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/os/file_unix.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/os/file_unix.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;58 func epipecheck(file *File, e error) {&lt;br /&gt;59 &amp;nbsp; &amp;nbsp; if e == syscall.EPIPE {&lt;br /&gt;60 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if atomic.AddInt32(&amp;amp;file.nepipe, 1) &amp;gt;= 10 {&lt;br /&gt;61 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sigpipe()&lt;br /&gt;62 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;63 &amp;nbsp; &amp;nbsp; } else {&lt;br /&gt;64 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; atomic.StoreInt32(&amp;amp;file.nepipe, 0)&lt;br /&gt;65 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;66 } &lt;/div&gt;&lt;br /&gt;Here in listing 10, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;epipecheck&lt;/span&gt; function accepts a pointer of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt;. The caller therefore shares its &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; type value with the function via a pointer. Notice the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;epipecheck&lt;/span&gt; function is not changing the state of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; value but using it to perform its operation.&lt;br /&gt;&lt;br /&gt;This applies as well for the methods declared for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; type:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 11&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/os/file.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/os/file.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;224 func (f *File) Chdir() error {&lt;br /&gt;225 &amp;nbsp; &amp;nbsp; if f == nil {&lt;br /&gt;226 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return ErrInvalid&lt;br /&gt;227 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;228 &amp;nbsp; &amp;nbsp; if e := syscall.Fchdir(f.fd); e != nil {&lt;br /&gt;229 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return &amp;amp;PathError{&quot;chdir&quot;, f.name, e}&lt;br /&gt;230 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;231 &amp;nbsp; &amp;nbsp; return nil&lt;br /&gt;232 }  &lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Chdir&lt;/span&gt; method in listing 11 is using a pointer receiver to implement the method and does not change the state of the receiver value. In all these cases, to share a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt;, it must be done with a pointer. A &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; value is not a primitive data value.&lt;br /&gt;&lt;br /&gt;If you review more code from the standard library, you will see how struct types are either implemented as a primitive data value like the built-in types or implemented as a value that needs to be shared with a pointer and never copied. The factory functions for a given struct type will give you a great clue as to how the type is implemented.&lt;br /&gt;&lt;br /&gt;In general, share struct type values with a pointer unless the struct type has been implemented to behave like a primitive data value.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;If you are still not sure, this is another way to think about. Think of every struct as having a nature. If the nature of the struct is something that should not be changed, like a time, a color or a coordinate, then implement the struct as a primitive data value. If the nature of the struct is something that can be changed, even if it never is in your program, it is not a primitive data value and should be implemented to be shared with a pointer. Don’t create structs that have a duality of nature&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Reference Types&lt;/span&gt;&lt;br /&gt;Reference types are slices, maps, channels, interface and function values. These are values that contain a header value that references an underlying data structure via a pointer and other meta-data. We rarely share reference type values with a pointer because the header value is designed to be copied. The header value already contains a pointer which is sharing the underlying data structure for us by default.&lt;br /&gt;&lt;br /&gt;Let’s look at an example from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;net&lt;/span&gt; package:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 12&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/net/ip.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/net/ip.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;32 type IP []byte&lt;/div&gt;&lt;br /&gt;Listing 12 shows a named type from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;net&lt;/span&gt; package called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;IP&lt;/span&gt; with a base type that is a slice of bytes. There is value in using a named type when you need to declare behavior around a built-in or reference type. Let’s look at the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;MarshalText&lt;/span&gt; method for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;IP&lt;/span&gt; named type:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 13&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/net/ip.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/net/ip.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;329 func (ip IP) MarshalText() ([]byte, error) {&lt;br /&gt;330 &amp;nbsp; &amp;nbsp; if len(ip) == 0 {&lt;br /&gt;331 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return []byte(&quot;&quot;), nil&lt;br /&gt;332 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;333 &amp;nbsp; &amp;nbsp; if len(ip) != IPv4len &amp;amp;&amp;amp; len(ip) != IPv6len {&lt;br /&gt;334 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return nil, errors.New(&quot;invalid IP address&quot;)&lt;br /&gt;335 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;336 &amp;nbsp; &amp;nbsp; return []byte(ip.String()), nil&lt;br /&gt;337 } &lt;/div&gt;&lt;br /&gt;Here in listing 13, we can see how the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;MarshalText&lt;/span&gt; method is using a value receiver. This is exactly what I would expect to see because we don’t share reference types with a pointer. If you look at the rest of the methods declared for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;IP&lt;/span&gt; named type in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;net&lt;/span&gt; package, you will see the use of more value receivers.&lt;br /&gt;&lt;br /&gt;This applies to sharing reference type values as parameters to functions and methods:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 14&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/net/ip.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/net/ip.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;318 // ipEmptyString is like ip.String except that it returns&lt;br /&gt;319 // an empty string when ip is unset.&lt;br /&gt;320 func ipEmptyString(ip IP) string {&lt;br /&gt;321 &amp;nbsp; &amp;nbsp; if len(ip) == 0 {&lt;br /&gt;322 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return &quot;&quot;&lt;br /&gt;323 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;324 &amp;nbsp; &amp;nbsp; return ip.String()&lt;br /&gt;325 } &lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ipEmptyString&lt;/span&gt; function in listing 14 accepts a value of named type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;IP&lt;/span&gt;. No pointer is used to share this value since the base type for &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;IP&lt;/span&gt; is a slice of bytes and therefore a reference type.&lt;br /&gt;&lt;br /&gt;There is one common exception to the rule of not sharing a reference type with a pointer:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 15&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;a href=&quot;http://golang.org/src/net/ip.go&quot; target=&quot;_blank&quot;&gt;http://golang.org/src/net/ip.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;341 func (ip *IP) UnmarshalText(text []byte) error {&lt;br /&gt;342 &amp;nbsp; &amp;nbsp; if len(text) == 0 {&lt;br /&gt;343 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; *ip = nil&lt;br /&gt;344 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return nil&lt;br /&gt;345 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;346 &amp;nbsp; &amp;nbsp; s := string(text)&lt;br /&gt;347 &amp;nbsp; &amp;nbsp; x := ParseIP(s)&lt;br /&gt;348 &amp;nbsp; &amp;nbsp; if x == nil {&lt;br /&gt;349 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return &amp;amp;ParseError{&quot;IP address&quot;, s}&lt;br /&gt;350 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;351 &amp;nbsp; &amp;nbsp; *ip = x&lt;br /&gt;352 &amp;nbsp; &amp;nbsp; return nil&lt;br /&gt;353 } &lt;/div&gt;&lt;br /&gt;Anytime you are unmarshaling data into a reference type, you will need to share that reference type value with a pointer. Listing 15 shows the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;UnmarshalText&lt;/span&gt; method that is performing an unmarshal operation and is declared with a pointer receiver. The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Decode&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Unmarshal&lt;/span&gt; functions from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;encoding&lt;/span&gt; packages would also expect to receive a pointer to a reference type.&lt;br /&gt;&lt;br /&gt;If you review more code from the standard library, you will see how values from reference types in most cases are not shared with a pointer. Since the reference type contains a header value whose purpose is to share an underlying data structure, sharing these values with a pointer is unnecessary. There is already a pointer in use.&lt;br /&gt;&lt;br /&gt;In general, don’t share reference type values with a pointer unless you are implementing an unmarshal type of functionality.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Slices Of Values&lt;/span&gt;&lt;br /&gt;One thing I avoid when I can is storing data with a slice of pointers. When I retrieve data from a database, the web or even a file, I store that data in a slice of values:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 16&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;10 func FindRegion(s *Service, region string) ([]BuoyStation, error) {&lt;br /&gt;11 &amp;nbsp; &amp;nbsp; var bs []BuoyStation&lt;br /&gt;12 &amp;nbsp; &amp;nbsp; f := func(c *mgo.Collection) error {&lt;br /&gt;13 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; queryMap := bson.M{&quot;region&quot;: region}&lt;br /&gt;14 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return c.Find(queryMap).All(&amp;amp;bs)&lt;br /&gt;15 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;16&lt;br /&gt;17 &amp;nbsp; &amp;nbsp; if err := s.DBAction(cfg.Database, &quot;buoy_stations&quot;, f); err != nil {&lt;br /&gt;18 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return nil, err&lt;br /&gt;19 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;20&lt;br /&gt;21 &amp;nbsp; &amp;nbsp; return bs, nil&lt;br /&gt;22 } &lt;/div&gt;&lt;br /&gt;Here is some code in listing 16 from one of my projects that makes a call to a MongoDB database via the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;mgo&lt;/span&gt; package. On line 14, I pass the address of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bs&lt;/span&gt; slice to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;All&lt;/span&gt; method. The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;All&lt;/span&gt; method performs an unmarshal call underneath to create the values for the slice. Then the slice of data values is returned by passing a copy of the slice header value back to the caller.&lt;br /&gt;&lt;br /&gt;Using a slice of values allows the data for the program to be stored in a contiguous block of memory. This means that more of the core data I am using can be cached by the CPU at once and hopefully stays in the cache longer. If I create a slice of pointers, there is no guarantee the memory for these core data values would be contiguous, only the pointers to those values would be stored contiguously. Though I am thinking about performance in this case, I would argue that it is more idiomatic.&lt;br /&gt;&lt;br /&gt;There are times when this is not possible. Imagine if I needed a slice of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; type values. Since I can’t make copies of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; type values, I would need to create a slice of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;File&lt;/span&gt; type pointers. This situation occurs often when working with struct types from the standard library and not your own.&lt;br /&gt;&lt;br /&gt;In general, create slices and maps of values when you can.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;br /&gt;The standard library is fairly consistent in how it shares values based on the type of value it is working with. Don’t use pointers with built-in data types unless you have a special need to do so. Struct types have a duality. If the struct type is implemented as a primitive data type, then don’t use a pointer. If not, then share those values with a pointer. Finally, reference types should not be shared with a pointer with very few exceptions.&lt;br /&gt;&lt;br /&gt;I would like to re-iterate three other thoughts as I close. First, make coding decisions based on the code being idiomatic, simple, readable and reasonable. Second, this is not about right and wrong, think about the code you are writing and there being reason behind the decisions you are making. Lastly, take each situation and scenario as an individual case, and try not to apply a blanket pattern or solution.&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/5789843912452440288/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/12/using-pointers-in-go.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/5789843912452440288'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/5789843912452440288'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/12/using-pointers-in-go.html' title='Using Pointers In *Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-572784698232773605</id><published>2014-11-10T15:37:00.000-05:00</published><updated>2014-11-16T12:53:39.251-05:00</updated><title type='text'>Error Handling In Go, Part II</title><content type='html'>&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;br /&gt;In &lt;a href=&quot;http://www.goinggo.net/2014/10/error-handling-in-go-part-i.html&quot; target=&quot;_blank&quot;&gt;part I&lt;/a&gt; of this post, we learned about the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface and how the standard library provides support for creating &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface values via the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt; package. We also learned how to work with &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface values and use them to identify when an error has occured. Finally, we saw how some packages in the standard library export &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface variables to help us identify specific errors.&lt;br /&gt;&lt;br /&gt;Knowing when to create and use custom error types in Go can sometimes be confusing. In most cases, the traditional &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value provided by the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt; package is enough for reporting and handling errors. However, sometimes the caller needs extra context in order to make a more informed error handling decision. For me, that is when custom error types make sense.&lt;br /&gt;&lt;br /&gt;In this post, we are going to learn about custom error types and look at two use cases from the standard library where they are used. Each use case provides an interesting perspective for when and how to implement a custom error type. Then we will learn how to identify the concrete type of the value or pointer stored within an &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value, and see how that can help us make more informed error handling decisions.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The net Package&lt;/span&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;net&lt;/span&gt; package has declared a custom error type called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;OpError&lt;/span&gt;. Pointers of this struct are used by many of the functions and methods inside the package as the concrete type stored within the returned &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.1&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;http://golang.org/src/pkg/net/dial.go&lt;br /&gt;&lt;br /&gt;01 func Listen(net, laddr string) (Listener, error) {&lt;br /&gt;02 &amp;nbsp; &amp;nbsp; la, err := resolveAddr(&quot;listen&quot;, net, laddr, noDeadline)&lt;br /&gt;03 &amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return nil, &amp;amp;OpError{Op: &quot;listen&quot;, Net: net, Addr: nil, Err: err}&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;06 &amp;nbsp; &amp;nbsp; var l Listener&lt;br /&gt;07 &amp;nbsp; &amp;nbsp; switch la := la.toAddr().(type) {&lt;br /&gt;08 &amp;nbsp; &amp;nbsp; case *TCPAddr:&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; l, err = ListenTCP(net, la)&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; case *UnixAddr:&lt;br /&gt;11 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; l, err = ListenUnix(net, la)&lt;br /&gt;12 &amp;nbsp; &amp;nbsp; default:&lt;br /&gt;13 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return nil, &amp;amp;OpError{Op: &quot;listen&quot;, Net: net, Addr: la, Err: &amp;amp;AddrError{Err: &quot;unexpected address type&quot;, Addr: laddr}}&lt;br /&gt;14 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;15 &amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;16 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return nil, err // l is non-nil interface containing nil pointer&lt;br /&gt;17 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;18 &amp;nbsp; &amp;nbsp; return l, nil&lt;br /&gt;19 } &lt;/div&gt;&lt;br /&gt;Listing 1.1 shows the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Listen&lt;/span&gt; function from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;net&lt;/span&gt; package. We can see that on lines 04 and 13, pointers of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;OpError&lt;/span&gt; struct are created and passed in the return statement for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value. Since pointers of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;OpError&lt;/span&gt; struct implement the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface, the pointer can be stored in an &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value and returned. What you don’t see is that on lines 09 and 11, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ListenTCP&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ListenUnix&lt;/span&gt; functions can also return pointers of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;OpError&lt;/span&gt; struct, which are stored in the returned &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value.&lt;br /&gt;&lt;br /&gt;Next, let’s look at the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;OpError&lt;/span&gt; struct:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.2&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;http://golang.org/pkg/net/#OpError&lt;br /&gt;&lt;br /&gt;01 // OpError is the error type usually returned by functions in the net&lt;br /&gt;02 // package. It describes the operation, network type, and address of&lt;br /&gt;03 // an error.&lt;br /&gt;04 type OpError struct {&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; // Op is the operation which caused the error, such as&lt;br /&gt;06 &amp;nbsp; &amp;nbsp; // &quot;read&quot; or &quot;write&quot;.&lt;br /&gt;07 &amp;nbsp; &amp;nbsp; Op string&lt;br /&gt;08&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; // Net is the network type on which this error occurred,&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; // such as &quot;tcp&quot; or &quot;udp6&quot;.&lt;br /&gt;11 &amp;nbsp; &amp;nbsp; Net string&lt;br /&gt;12&lt;br /&gt;13 &amp;nbsp; &amp;nbsp; // Addr is the network address on which this error occurred.&lt;br /&gt;14 &amp;nbsp; &amp;nbsp; Addr Addr&lt;br /&gt;15&lt;br /&gt;16 &amp;nbsp; &amp;nbsp; // Err is the error that occurred during the operation.&lt;br /&gt;17 &amp;nbsp; &amp;nbsp; Err error&lt;br /&gt;18 } &lt;/div&gt;&lt;br /&gt;Listing 1.2 shows the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;OpError&lt;/span&gt; struct. The first three fields on lines 07, 11 and 14 provide context about the network operation being performed when an error occurs. The fourth field on line 17 is declared as an &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface type. This field will contain the actual error that occurred and the value of the concrete type in many cases will be a pointer of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;Another thing to note is the naming convention for custom error types. It is idiomatic in Go to postfix the name of a custom error type with the word &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Error&lt;/span&gt;. We will see this naming convention used again in other packages.&lt;br /&gt;&lt;br /&gt;Next, let’s look at the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;OpError&lt;/span&gt; struct:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.3&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;http://golang.org/src/pkg/net/net.go&lt;br /&gt;&lt;br /&gt;01 func (e *OpError) Error() string {&lt;br /&gt;02 &amp;nbsp; &amp;nbsp; if e == nil {&lt;br /&gt;03 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return &quot;&amp;lt;nil&amp;gt;&quot;&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; s := e.Op&lt;br /&gt;06 &amp;nbsp; &amp;nbsp; if e.Net != &quot;&quot; {&lt;br /&gt;07 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; s += &quot; &quot; + e.Net&lt;br /&gt;08 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; if e.Addr != nil {&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; s += &quot; &quot; + e.Addr.String()&lt;br /&gt;11 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;12 &amp;nbsp; &amp;nbsp; s += &quot;: &quot; + e.Err.Error()&lt;br /&gt;13 &amp;nbsp; &amp;nbsp; return s&lt;br /&gt;14 } &lt;/div&gt;&lt;br /&gt;The implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface in listing 1.3 shows how the context associated with the error is used to generate a contextual error message. Binding context with the error provides extended error information and can help the caller make more informed decisions about how to handle the error.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The json Package&lt;/span&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;json&lt;/span&gt; package performs the decoding of data from JSON to native Go types and vice versa. All possible errors that can be returned from the package are generated internally. Maintaining the context associated with an error is critical for this package or it wouldn’t be able to properly report what has happened. There are several custom error types in the json package and these types can be returned by the same functions and methods.&lt;br /&gt;&lt;br /&gt;Let’s look at one of these custom error types:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.4&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;http://golang.org/src/pkg/encoding/json/decode.go&lt;br /&gt;&lt;br /&gt;01 // An UnmarshalTypeError describes a JSON value that was&lt;br /&gt;02 // not appropriate for a value of a specific Go type.&lt;br /&gt;03 type UnmarshalTypeError struct {&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; Value string       // description of JSON value&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; Type  reflect.Type // type of Go value it could not be assigned to&lt;br /&gt;06 }&lt;br /&gt;07&lt;br /&gt;08 func (e *UnmarshalTypeError) Error() string {&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; return &quot;json: cannot unmarshal &quot; + e.Value + &quot; into Go value of type &quot; + e.Type.String()&lt;br /&gt;10 } &lt;/div&gt;&lt;br /&gt;Listing 1.4 shows the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;UnmarshalTypeError&lt;/span&gt; struct and the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface. This struct is used to report errors that occur when a value can’t be decoded into a specific Go type. The struct contains two fields, one called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Value&lt;/span&gt; on line 04 that contains the value attempted to be decoded and one called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Type&lt;/span&gt; on line 05 which contains the Go type that the value could not be converted to. The implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface on line 08 takes the context of the error and produces a proper error message.&lt;br /&gt;&lt;br /&gt;In this case, the type itself provides the context for the error. The name of this type is called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;UnmarshalTypeError&lt;/span&gt; and that is the context in which it is used. When there are errors associated with unmarshaling types, pointers of this struct are stored within the returned &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value.&lt;br /&gt;&lt;br /&gt;When there are invalid arguments passed into an unmarshal call, a pointer of concrete type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;InvalidUnmarshalError&lt;/span&gt; is stored within the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value that is returned:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.5&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;http://golang.org/src/pkg/encoding/json/decode.go&lt;br /&gt;&lt;br /&gt;01 // An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.&lt;br /&gt;02 // (The argument to Unmarshal must be a non-nil pointer.)&lt;br /&gt;03 type InvalidUnmarshalError struct {&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; Type reflect.Type&lt;br /&gt;05 }&lt;br /&gt;06&lt;br /&gt;07 func (e *InvalidUnmarshalError) Error() string {&lt;br /&gt;08 &amp;nbsp; &amp;nbsp; if e.Type == nil {&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return &quot;json: Unmarshal(nil)&quot;&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;11&lt;br /&gt;12 &amp;nbsp; &amp;nbsp; if e.Type.Kind() != reflect.Ptr {&lt;br /&gt;13 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return &quot;json: Unmarshal(non-pointer &quot; + e.Type.String() + &quot;)&quot;&lt;br /&gt;14 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;15 &amp;nbsp; &amp;nbsp; return &quot;json: Unmarshal(nil &quot; + e.Type.String() + &quot;)&quot;&lt;br /&gt;16 } &lt;/div&gt;&lt;br /&gt;Listing 1.5 shows the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;InvalidUnmarshalError&lt;/span&gt; struct and the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface. Once again, the type itself provides the context for the error. The state being maintained helps to produce a proper error message and provides context to help the caller make more informed error handling decision.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Concrete Type Identification&lt;/span&gt;&lt;br /&gt;In the case of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Unmarshal&lt;/span&gt; function from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;json&lt;/span&gt; package, there is the potential for a pointer of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;UnmarshalTypeError&lt;/span&gt;, &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;InvalidUnmarshalError&lt;/span&gt; or &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; to be stored within the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value that is returned:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.6&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;http://golang.org/src/pkg/encoding/json/decode.go&lt;br /&gt;&lt;br /&gt;01 func Unmarshal(data []byte, v interface{}) error {&lt;br /&gt;02 &amp;nbsp; &amp;nbsp; // Check for well-formedness.&lt;br /&gt;03 &amp;nbsp; &amp;nbsp; // Avoids filling out half a data structure&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; // before discovering a JSON syntax error.&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; var d decodeState&lt;br /&gt;06 &amp;nbsp; &amp;nbsp; err := checkValid(data, &amp;amp;d.scan)&lt;br /&gt;07 &amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;08 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return err&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;10&lt;br /&gt;11 &amp;nbsp; &amp;nbsp; d.init(data)&lt;br /&gt;12 &amp;nbsp; &amp;nbsp; return d.unmarshal(v)&lt;br /&gt;13 }&lt;br /&gt;14&lt;br /&gt;15 func (d *decodeState) unmarshal(v interface{}) (err error) {&lt;br /&gt;16 &amp;nbsp; &amp;nbsp; defer func() {&lt;br /&gt;17 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if r := recover(); r != nil {&lt;br /&gt;18 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if _, ok := r.(runtime.Error); ok {&lt;br /&gt;19 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(r)&lt;br /&gt;20 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;21 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; err = r.(error)&lt;br /&gt;22 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;23 &amp;nbsp; &amp;nbsp; }()&lt;br /&gt;24&lt;br /&gt;25 &amp;nbsp; &amp;nbsp; rv := reflect.ValueOf(v)&lt;br /&gt;26 &amp;nbsp; &amp;nbsp; if rv.Kind() != reflect.Ptr || rv.IsNil() {&lt;br /&gt;27 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return &amp;amp;InvalidUnmarshalError{reflect.TypeOf(v)}&lt;br /&gt;28 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;29&lt;br /&gt;30 &amp;nbsp; &amp;nbsp; d.scan.reset()&lt;br /&gt;31 &amp;nbsp; &amp;nbsp; // We decode rv not rv.Elem because the Unmarshaler interface&lt;br /&gt;32 &amp;nbsp; &amp;nbsp; // test must be applied at the top level of the value.&lt;br /&gt;33 &amp;nbsp; &amp;nbsp; d.value(rv)&lt;br /&gt;34 &amp;nbsp; &amp;nbsp; return d.savedError&lt;br /&gt;35 } &lt;/div&gt;&lt;br /&gt;Listing 1.6 shows how the returned &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Unmarshal&lt;/span&gt; call can potentially store pointers of different concrete types. On line 27, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;unmarshal&lt;/span&gt; method returns a pointer of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;InvalidUnmarshalError&lt;/span&gt; and then on line 34, the value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;savedError&lt;/span&gt; field from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;decodeState&lt;/span&gt; variable is returned. This value can be pointers of several different concrete types.&lt;br /&gt;&lt;br /&gt;Knowing that the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;json&lt;/span&gt; package is using the custom error type as the context for the error, how can we identify the type of the concrete value to make a more informed decision about handling the error?&lt;br /&gt;&lt;br /&gt;Let’s start with a program that causes the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Unmarshal&lt;/span&gt; function to return an &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value with a concrete pointer type of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;UnmarshalTypeError&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.7&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;http://play.golang.org/p/FVFo8mJLBV&lt;br /&gt;&lt;br /&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 import (&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; &quot;encoding/json&quot;&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; &quot;fmt&quot;&lt;br /&gt;06 &amp;nbsp; &amp;nbsp; &quot;log&quot;&lt;br /&gt;07 )&lt;br /&gt;08&lt;br /&gt;09 type user struct {&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; Name int&lt;br /&gt;11 }&lt;br /&gt;12&lt;br /&gt;13 func main() {&lt;br /&gt;14 &amp;nbsp; &amp;nbsp; var u user&lt;br /&gt;15 &amp;nbsp; &amp;nbsp; err := json.Unmarshal([]byte(`{&quot;name&quot;:&quot;bill&quot;}`), &amp;amp;u)&lt;br /&gt;16 &amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;17 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Println(err)&lt;br /&gt;18 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;19 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;20&lt;br /&gt;21 &amp;nbsp; &amp;nbsp; fmt.Println(&quot;Name:&quot;, u.Name)&lt;br /&gt;22 }&lt;br /&gt;&lt;br /&gt;Output:&lt;br /&gt;2009/11/10 23:00:00 json: cannot unmarshal string into Go value of type int &lt;/div&gt;&lt;br /&gt;Listing 1.7 shows a sample program that attempts to unmarshal a JSON document into a Go type. The JSON document on line 15 contains a field named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;name&lt;/span&gt; with a string value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bill&lt;/span&gt;. Since the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Name&lt;/span&gt; field in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;user&lt;/span&gt; type declared on line 09 is declared as an integer, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Unmarshal&lt;/span&gt; function returns an &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value stored with a concrete pointer type of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;UnmarshalTypeError&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;Now let’s make some changes to the program in listing 1.7 so the same &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Unmarshal&lt;/span&gt; call returns an &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&amp;nbsp;&lt;/span&gt;interface value that is storing a different concrete pointer type:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.8&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;http://play.golang.org/p/n8dQFeHYVp&lt;br /&gt;&lt;br /&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 import (&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; &quot;encoding/json&quot;&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; &quot;fmt&quot;&lt;br /&gt;06 &amp;nbsp; &amp;nbsp; &quot;log&quot;&lt;br /&gt;07 )&lt;br /&gt;08&lt;br /&gt;09 type user struct {&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; Name int&lt;br /&gt;11 }&lt;br /&gt;12&lt;br /&gt;13 func main() {&lt;br /&gt;14 &amp;nbsp; &amp;nbsp; var u user&lt;br /&gt;15 &amp;nbsp; &amp;nbsp; err := json.Unmarshal([]byte(`{&quot;name&quot;:&quot;bill&quot;}`), u)&lt;br /&gt;16 &amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;17 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; switch e := err.(type) {&lt;br /&gt;18 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case *json.UnmarshalTypeError:&lt;br /&gt;19 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Printf(&quot;UnmarshalTypeError: Value[%s] Type[%v]\n&quot;, e.Value, e.Type)&lt;br /&gt;20 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case *json.InvalidUnmarshalError:&lt;br /&gt;21 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Printf(&quot;InvalidUnmarshalError: Type[%v]\n&quot;, e.Type)&lt;br /&gt;22 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; default:&lt;br /&gt;23 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Println(err)&lt;br /&gt;24 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;25 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;26 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;27&lt;br /&gt;28 &amp;nbsp; &amp;nbsp; fmt.Println(&quot;Name:&quot;, u.Name)&lt;br /&gt;29 }&lt;br /&gt;&lt;br /&gt;Output:&lt;br /&gt;2009/11/10 23:00:00 json: Unmarshal(non-pointer main.user)&lt;br /&gt;2009/11/10 23:00:00 InvalidUnmarshalError: Type[main.user] &lt;/div&gt;&lt;br /&gt;The sample program in listing 1.8 has a few changes from listing 1.7. On line 15, we now pass the value of the variable &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;u&lt;/span&gt; instead of its address to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Unmarshal&lt;/span&gt; function. This change causes the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Unmarshal&lt;/span&gt; function to return an &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value that is storing a concrete pointer type of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;InvalidUnmarshalError&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;Then we do something interesting on lines 17 through 24:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.9&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;17 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; switch e := err.(type) {&lt;br /&gt;18 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case *json.UnmarshalTypeError:&lt;br /&gt;19 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Printf(&quot;UnmarshalTypeError: Value[%s] Type[%v]\n&quot;, e.Value, e.Type)&lt;br /&gt;20 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case *json.InvalidUnmarshalError:&lt;br /&gt;21 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Printf(&quot;InvalidUnmarshalError: Type[%v]\n&quot;, e.Type)&lt;br /&gt;22 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; default:&lt;br /&gt;23 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Println(err)&lt;br /&gt;24 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/div&gt;&lt;br /&gt;A&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;switch&lt;/span&gt;&amp;nbsp;statement on line 17 is added to identify the concrete type of the pointer that was stored inside the returned&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;&amp;nbsp;interface value. Notice how the keyword&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;type&lt;/span&gt;&amp;nbsp;is used within the interface value conversion syntax. We are also able to extract the value of the concrete type at the same time and use it in each case statement.&lt;br /&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;case&lt;/span&gt; statements on lines 18 and 20 check for the specific concrete types and perform logic associated with handling those errors. This is the idiomatic way in Go to identify the concrete type of the value or pointer stored within an &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value from a set of concrete types.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface values we return should contain information about a specific negative condition that has occurred within the scope of a function or method that impacts the caller. It must provide enough information so the caller can act in an informed way. Usually a simple message is enough, but sometimes the caller needs more.&lt;br /&gt;&lt;br /&gt;We saw one case from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;net&lt;/span&gt; package where a custom error type was declared to wrap the original error and the context associated with that error. In the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;json&lt;/span&gt; package, we saw the use of custom error types that provide both the context of the error and associated state. In both cases, the need to maintain context associated with an error was a deciding factor.&lt;br /&gt;&lt;br /&gt;When the traditional &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value created by the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt; package provides enough context for the error, use it. It is used throughout the standard library and is usually all you need. When extra context is required to help the caller make a more informed decision, take a cue from the standard library and build your own custom error types.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/572784698232773605/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/11/error-handling-in-go-part-ii.html#comment-form' title='1 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/572784698232773605'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/572784698232773605'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/11/error-handling-in-go-part-ii.html' title='Error Handling In Go, Part II'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-2884039813150453695</id><published>2014-10-13T13:46:00.000-04:00</published><updated>2014-10-14T09:04:14.618-04:00</updated><title type='text'>Error Handling In Go, Part I</title><content type='html'>&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;br /&gt;It is idiomatic in Go to use the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface type as the return type for any error that is going to be returned from a function or method. This interface is used by all the functions and methods in the standard library that return errors. For example, here is the declaration for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Get&lt;/span&gt; method from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;http&lt;/span&gt; package: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.1&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://golang.org/pkg/net/http/#Client.Get&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;func (c *Client) Get(url string) (resp *Response, &lt;b&gt;err error&lt;/b&gt;) &lt;/div&gt;&lt;br /&gt;Listing 1.1 shows how the second return argument for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Get&lt;/span&gt; method is an interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;. Handling errors that are returned from functions and methods starts by checking if the returned interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; is not &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.2&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;resp, err := c.Get(&quot;http://goinggo.net/feeds/posts/default&quot;)&lt;br /&gt;if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; log.Println(err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; return&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;In listing 1.2, a call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Get&lt;/span&gt; is performed and the return values are assigned to local variables. Then the value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;err&lt;/span&gt; variable is compared to the value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt;. If the value is not &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt;, then there was an error.&lt;br /&gt;&lt;br /&gt;Because an interface is being used to handle error values, a concrete type needs to be declared that implements the interface. The standard library has declared and implemented this concrete type for us in the form of a struct called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt;. In this post, we will explore the implementation and use of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; struct from the standard library. &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Error Interface and errorString Struct&lt;/span&gt;&lt;br /&gt;The declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface is provided to us by the language directly: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.3&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://golang.org/pkg/builtin/#error&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;type error interface {&lt;br /&gt;&amp;nbsp; &amp;nbsp; Error() string&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;In listing 1.3, we can see how the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface is declared with a single method called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Error&lt;/span&gt; that returns a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt;. Therefore, any type that implements the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Error&lt;/span&gt; method will implement the interface and can be used as an interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;. If you are not familiar with how interfaces work in Go, read my post about &lt;a href=&quot;http://www.goinggo.net/2014/05/methods-interfaces-and-embedded-types.html&quot; target=&quot;_blank&quot;&gt;Interfaces, Methods and Embedded Types&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;The standard library has also declared a struct type called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; that can be found in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt; package: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.4&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://golang.org/src/pkg/errors/errors.go&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;type errorString struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; s string&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;In listing 1.4, we can see how the declaration of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; shows a single field named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;s&lt;/span&gt; of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt;. Both the type and its single field are unexported, which means we can’t directly access the type or its field. To learn more about unexported identifiers in Go, read my post about &lt;a href=&quot;http://www.goinggo.net/2014/03/exportedunexported-identifiers-in-go.html&quot; target=&quot;_blank&quot;&gt;Exported/Unexported Identifiers in Go&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; struct implements the error interface: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.5&lt;/b&gt; &amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://golang.org/src/pkg/errors/errors.go&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;func (e *errorString) Error() string {&lt;br /&gt;&amp;nbsp; &amp;nbsp; return e.s&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface is implemented with a pointer receiver as seen in listing 1.5. This means only pointers of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; can be used as an interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;. Also, since the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; type and its single field are unexported, we can’t perform a type assertion or conversion of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface value. Our only access to the value of the concrete type is with the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Error&lt;/span&gt; method.&lt;br /&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; type is the most common type of error that is returned as an interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; within the standard library. Now that we know what these types look like, let’s learn how the standard library gives us the ability to create an interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; using the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; struct.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Creating Error Values&lt;/span&gt;&lt;br /&gt;The standard library provides two ways to create pointers of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; for use as an interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;. When all you need for your error is a string with no special formatting, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt; function from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt; package is the way to go: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.6&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;var ErrInvalidParam = errors.New(“mypackage: invalid parameter”) &lt;/div&gt;&lt;br /&gt;Listing 1.6 shows a typical call to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt; function from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt; package. In this example, an interface variable of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; is declared and initialized after the call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt;. Let’s look at the declaration and implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt; function:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.7&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://golang.org/src/pkg/errors/errors.go&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;// New returns an error that formats as the given text.&lt;br /&gt;func New(text string) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; return &amp;amp;errorString{text}&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;In the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt; function in listing 1.7, we see the function takes a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; as a parameter and returns an interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;. In the implementation of the function, a pointer of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; is created. Then on the return statement, an interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; is created by the compiler and bound to the pointer to satisfy the return argument. The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; pointer becomes the underlying data value and type for the interface &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; value that is returned.&lt;br /&gt;&lt;br /&gt;When you have an error message that requires formatting, use the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Errorf&lt;/span&gt; function from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;fmt&lt;/span&gt; package: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.8&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;var ErrInvalidParam = fmt.Errorf(“invalid parameter [%s]”, param) &lt;/div&gt;&lt;br /&gt;Listing 1.8 shows a typical call to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Errorf&lt;/span&gt; function. If you are familiar with using the other format functions from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;fmt&lt;/span&gt; package, then you will notice this works the same. Once again, an interface variable of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; is declared and initialized after the call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Errorf&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;Let’s look at the declaration and implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Errorf&lt;/span&gt; function: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.9&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://golang.org/src/pkg/fmt/print.go&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;// Errorf formats according to a format specifier and returns the string&lt;br /&gt;// as a value that satisfies error.&lt;br /&gt;func Errorf(format string, a ...interface{}) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; return errors.New(Sprintf(format, a…))&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;In the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Errorf&lt;/span&gt; function in listing 1.9, we see the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface type is being used once again as the return type. In the implementation of the function, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt; function from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt; package is used to create an interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; for the message that is formatted. So whether you use the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt; or &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;fmt&lt;/span&gt; package to create your interface value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;, the value underneath is always a pointer of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;Now we know the two different ways we can create interface values of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; using a pointer of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt;. Next, let’s learn how packages in the standard library provide support for comparing unique errors that are returned from API calls. &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Comparing Error Values&lt;/span&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bufio&lt;/span&gt; package, like many other packages in the standard library, uses the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt; function from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt; package to create package level error variables: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.10&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://golang.org/src/pkg/bufio/bufio.go&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;var (&lt;br /&gt;&amp;nbsp; &amp;nbsp; ErrInvalidUnreadByte = errors.New(&quot;bufio: invalid use of UnreadByte&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; ErrInvalidUnreadRune = errors.New(&quot;bufio: invalid use of UnreadRune&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; ErrBufferFull &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;= errors.New(&quot;bufio: buffer full&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; ErrNegativeCount &amp;nbsp; &amp;nbsp; = errors.New(&quot;bufio: negative count&quot;)&lt;br /&gt;) &lt;/div&gt;&lt;br /&gt;Listing 1.10 shows four package level error variables that are declared and initialized in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bufio&lt;/span&gt; package. Notice each error variable starts with the prefix &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Err&lt;/span&gt;. This is a convention in Go. Since these variables are declared as interface type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;, we can use these variables to identify specific errors that are returned by the different &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bufio&lt;/span&gt; package API’s:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.11&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;data, err := b.Peek(1)&lt;br /&gt;if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; switch &lt;b&gt;err&lt;/b&gt; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; case &lt;b&gt;bufio.ErrNegativeCount&lt;/b&gt;:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Do something specific.&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; case &lt;b&gt;bufio.ErrBufferFull&lt;/b&gt;:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Do something specific.&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; default:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Do something generic.&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;In listing 1.11, the code example calls into the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Peek&lt;/span&gt; method from a pointer variable of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bufio.Reader&lt;/span&gt;. The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Peek&lt;/span&gt; method has the potential of returning both the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ErrNegativeCount&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ErrBufferFull&lt;/span&gt; error variables. Because these variables have been exported by the package, we now have the ability to use the variables to identify which specific error message was returned. These variable become part of the packages API for error handling.&lt;br /&gt;&lt;br /&gt;Imagine if the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bufio&lt;/span&gt; package did not declare these error variables. Now we would need to compare the actual error messages to determine which error we received: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.12&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;data, err := b.Peek(1)&lt;br /&gt;if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; switch &lt;b&gt;err.Error()&lt;/b&gt; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; case &lt;b&gt;&quot;bufio: negative count&quot;&lt;/b&gt;:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Do something specific.&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; case &lt;b&gt;&quot;bufio: buffer full&quot;&lt;/b&gt;:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Do something specific.&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; default:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Do something specific.&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;There are two problems with the code example in listing 1.12. First, the call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Error()&lt;/span&gt; requires a copy of the error message to be made for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;switch&lt;/span&gt; statement. Second, if the package author ever changes these messages, this code breaks.&lt;br /&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;io&lt;/span&gt; package is another example of a package that declares interface type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; variables for the errors that can be returned: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.13&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://golang.org/src/pkg/io/io.go&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;var ErrShortWrite &amp;nbsp; &amp;nbsp;= errors.New(&quot;short write&quot;)&lt;br /&gt;var ErrShortBuffer &amp;nbsp; = errors.New(&quot;short buffer&quot;)&lt;br /&gt;var EOF &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;= errors.New(&quot;EOF&quot;)&lt;br /&gt;var ErrUnexpectedEOF = errors.New(&quot;unexpected EOF&quot;)&lt;br /&gt;var ErrNoProgress &amp;nbsp; &amp;nbsp;= errors.New(&quot;multiple Read calls return no data or error&quot;) &lt;/div&gt;&lt;br /&gt;Listing 1.13 shows six package level error variables that are declared in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;io&lt;/span&gt; package. The third variable is the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;EOF&lt;/span&gt; error variable that is returned to indicate when there is no more input available. It is common to compare the error value from functions in this package with the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;EOF&lt;/span&gt; variable.&lt;br /&gt;&lt;br /&gt;Here is the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ReadAtLeast&lt;/span&gt; function from inside &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;io&lt;/span&gt; package: &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp; &lt;b&gt;Listing 1.14&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://golang.org/src/pkg/io/io.go&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; if len(buf) &amp;lt; min {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return 0, &lt;b&gt;ErrShortBuffer&lt;/b&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; for n &amp;lt; min &amp;amp;&amp;amp; err == nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var nn int&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nn, err = r.Read(buf[n:])&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; n += nn&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; if n &amp;gt;= min {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; err = nil&lt;br /&gt;&amp;nbsp; &amp;nbsp; } else if n &amp;gt; 0 &amp;amp;&amp;amp; &lt;b&gt;err == EOF&lt;/b&gt; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; err = &lt;b&gt;ErrUnexpectedEOF&lt;/b&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; return&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ReadAtLeast&lt;/span&gt; function in listing 1.14 shows the use of these error variables in action. Notice how the error variables &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ErrShortBuffer&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ErrUnexpectedEOF&lt;/span&gt; are used as a return value. Also notice how the function compares the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;err&lt;/span&gt; variable against the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;EOF&lt;/span&gt; variable, just like we do in our own code.&lt;br /&gt;&lt;br /&gt;This pattern of creating error variables for the errors your API’s are going to return is something you should consider implementing yourself. It helps provide an API for errors and keeps error handling performant. &lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Why Not a Named Type&lt;/span&gt;&lt;br /&gt;One question that comes up is why didn’t the language designers use a named type for&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt;?&lt;br /&gt;&lt;br /&gt;Let’s take a look at the implementation using a named type and compare it to using the struct type:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;b&gt;Listing 1.15&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://play.golang.org/p/uZPi4XKMF9&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;01 package main&lt;br /&gt;02 &lt;br /&gt;03 import (&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; &quot;errors&quot;&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; &quot;fmt&quot;&lt;br /&gt;06 )&lt;br /&gt;07&lt;br /&gt;08 // Create a named type for our new error type.&lt;br /&gt;09 type errorString string&lt;br /&gt;10&lt;br /&gt;11 // Implement the error interface.&lt;br /&gt;12 func (e errorString) Error() string {&lt;br /&gt;13 &amp;nbsp; &amp;nbsp; return string(e)&lt;br /&gt;14 }&lt;br /&gt;15&lt;br /&gt;16 // New creates interface values of type error.&lt;br /&gt;17 func New(text string) error {&lt;br /&gt;18 &amp;nbsp; &amp;nbsp; return errorString(text)&lt;br /&gt;19 }&lt;br /&gt;20&lt;br /&gt;21 var ErrNamedType = New(&quot;EOF&quot;)&lt;br /&gt;22 var ErrStructType = errors.New(&quot;EOF&quot;)&lt;br /&gt;23&lt;br /&gt;24 func main() {&lt;br /&gt;25 &amp;nbsp; &amp;nbsp; if ErrNamedType == New(&quot;EOF&quot;) {&lt;br /&gt;26 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Println(&quot;Named Type Error&quot;)&lt;br /&gt;27 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;28&lt;br /&gt;29 &amp;nbsp; &amp;nbsp; if ErrStructType == errors.New(&quot;EOF&quot;) {&lt;br /&gt;30 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Println(&quot;Struct Type Error&quot;)&lt;br /&gt;31 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;32 } &lt;br /&gt;&lt;br /&gt;Output:&lt;br /&gt;Named Type Error&lt;/div&gt;&lt;br /&gt;Listing 1.15 provides a sample program to show a problem surrounding the use of a named type for&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt;.&amp;nbsp;The program on line 09 declares a named typed called&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt;&amp;nbsp;of type&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt;. Then on line 12, the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;&amp;nbsp;interface is implemented for the named type. To simulate the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt;&amp;nbsp;function from the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors&lt;/span&gt;&amp;nbsp;package, a function called&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt;&amp;nbsp;is implemented on line 17.&lt;br /&gt;&lt;br /&gt;Then on lines 21 and 22, two error variables are declared and initialized. The&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ErrNamedType&lt;/span&gt;&amp;nbsp;variable is initialized using the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;New&lt;/span&gt;&amp;nbsp;function and the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;ErrStructType&lt;/span&gt;&amp;nbsp;is initialized using the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors.New&lt;/span&gt;&amp;nbsp;function. Finally in&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main()&lt;/span&gt;, the variables are compared to new values created by the same functions.&lt;br /&gt;&lt;br /&gt;When you run the program, the output is interesting. The&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;if&lt;/span&gt;&amp;nbsp;statement on line 25 is&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;true&lt;/span&gt;&amp;nbsp;and the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;if&lt;/span&gt;&amp;nbsp;statement on line 29 is &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;false&lt;/span&gt;. By using the named type, we are able to create new interface values of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; with the same error message and they match. This poses the same problem as in listing 1.12. We could create our own versions of the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt;&amp;nbsp;values and use them. If at any time the package author changes the messages, our code will break.&lt;br /&gt;&lt;br /&gt;The same problem can occur when&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt;&amp;nbsp;is a struct type. Look at what happens when a value receiver is used for the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface:&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: #eeeeee;&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;b&gt;Listing 1.16&lt;/b&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;i&gt;http://play.golang.org/p/EMWPT-tWp4&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 import (&lt;br /&gt;04 &amp;nbsp; &amp;nbsp;&quot;fmt&quot;&lt;br /&gt;05 )&lt;br /&gt;06&lt;br /&gt;07 type errorString struct {&lt;br /&gt;08 &amp;nbsp; &amp;nbsp;s string&lt;br /&gt;09 }&lt;br /&gt;10&lt;br /&gt;11 func (e errorString) Error() string {&lt;br /&gt;12 &amp;nbsp; &amp;nbsp;return e.s&lt;br /&gt;13 }&lt;br /&gt;14&lt;br /&gt;15 func NewError(text string) error {&lt;br /&gt;16 &amp;nbsp; &amp;nbsp;return errorString{text}&lt;br /&gt;17 }&lt;br /&gt;18&lt;br /&gt;19 var ErrType = NewError(&quot;EOF&quot;)&lt;br /&gt;20&lt;br /&gt;21 func main() {&lt;br /&gt;22 &amp;nbsp; &amp;nbsp;if ErrType == NewError(&quot;EOF&quot;) {&lt;br /&gt;23 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;fmt.Println(&quot;Error:&quot;, ErrType)&lt;br /&gt;24 &amp;nbsp; &amp;nbsp;}&lt;br /&gt;25 } &lt;br /&gt;&lt;br /&gt;Output:&lt;br /&gt;Error: EOF&lt;/div&gt;&lt;br /&gt;In listing 1.16 we have implemented the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; struct type using a value receiver for the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface. This time we experience the same behavior as we did in listing 1.15 with the named type. When interface type values are compared, the values of the concrete type are compared underneath.&lt;br /&gt;&lt;br /&gt;By the standard library using a pointer receiver for the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; struct, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors.New&lt;/span&gt; function is forced to return a pointer value. This pointer is what is bound to the interface value and will be unique every time. In these cases, pointer values are being compared and not the actual error messages.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;br /&gt;In this post we created a foundation for understanding what the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; interface is and how it is used in conjunction with the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errorString&lt;/span&gt; struct. Using the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;errors.New&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;fmt.Errorf&lt;/span&gt; functions for creating interface values of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;error&lt;/span&gt; is a very common practice in Go and highly recommended. Usually a simple string based error message with some basic formatting is all we need to handle errors. &lt;br /&gt;&lt;br /&gt;We also explored a pattern that is used by the standard library to help us identify the different errors that are returned by API calls. Many packages in the standard library create these exported error variables which usually provide enough granularity to identify one particular error over the other. &lt;br /&gt;&lt;br /&gt;There are times when creating your own custom error types make sense. This is something we will explore in part II of this post. For now, use the support provided to us by the standard library for handling errors and follow its example.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/2884039813150453695/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/10/error-handling-in-go-part-i.html#comment-form' title='3 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/2884039813150453695'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/2884039813150453695'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/10/error-handling-in-go-part-i.html' title='Error Handling In Go, Part I'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-2683252434189590822</id><published>2014-09-01T18:51:00.001-04:00</published><updated>2014-09-02T09:01:37.350-04:00</updated><title type='text'>Go Compiler nil Pointer Checks</title><content type='html'>&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;br /&gt;I was thinking about how the compiler looks to protect the code we write when it can. Invalid memory access checks are one type of safety check the compiler adds to our code. We might think that this &quot;extra code&quot; is hurting our performance and maybe over billions of iterative operations it is. However, these checks can prevent our code from causing damage to the systems we are running on. The compiler is essentially reporting and finding bugs, making the code we write safer to run.&lt;br /&gt;&lt;br /&gt;Even with this in mind, Go wants to be fast and if the hardware can catch a problem, it will let it. One of these cases is with the detection of invalid memory access. There are times when the compiler will add a&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer check into our code and times when it doesn&#39;t. In this post we will explore one case where the compiler leaves it up to the hardware to detect invalid memory access and one case where the compiler adds a&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt;&amp;nbsp;pointer check.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Hardware Only Checks&lt;/span&gt;&lt;br /&gt;When the compiler can depend on the hardware to check for and report invalid memory access, the compiler can produce less code which helps with performance. If our code attempts to read or write to address &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;0x0&lt;/span&gt;, the hardware will throw an exception that will be caught by the Go runtime and reported back up to our program in the form of a panic. If the panic is not recovered, a stack trace is produced.&lt;br /&gt;&lt;br /&gt;Here is an example that attempts to write to memory address &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;0x0&amp;nbsp;&lt;/span&gt;and the corresponding panic/stack trace:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 func main() {&lt;br /&gt;04 &amp;nbsp; &amp;nbsp;var p *int &amp;nbsp;// Declare a nil value pointer&lt;br /&gt;05 &amp;nbsp; &amp;nbsp;*p = 10 &amp;nbsp; &amp;nbsp; // Write the value 10 to address 0x0&lt;br /&gt;06 }&lt;br /&gt;&lt;br /&gt;panic: runtime error: invalid memory address or nil pointer dereference&lt;br /&gt;[signal 0xb code=0x1 addr=0x0 pc=0x2007]&lt;br /&gt;&lt;br /&gt;goroutine 16 [running]:&lt;br /&gt;runtime.panic(0x28600, 0x51744)&lt;br /&gt;&amp;nbsp; &amp;nbsp; /go/src/pkg/runtime/panic.c:279 +0xf5&lt;br /&gt;main.main()&lt;br /&gt;&amp;nbsp; &amp;nbsp; /Go/Projects/src/github.com/goinaction/code/temp/main.go:5 +0x7&lt;br /&gt;&lt;br /&gt;goroutine 17 [runnable]:&lt;br /&gt;runtime.MHeap_Scavenger()&lt;br /&gt;&amp;nbsp; &amp;nbsp; /go/src/pkg/runtime/mheap.c:507&lt;br /&gt;runtime.goexit()&lt;br /&gt;&amp;nbsp; &amp;nbsp; /go/src/pkg/runtime/proc.c:1445&lt;/div&gt;&lt;br /&gt;Let&#39;s look at the assembly produced by the 6g compiler on darwin/amd64 for this example:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;go tool 6g -S main.go&lt;br /&gt;&lt;br /&gt;&lt;b&gt;04 &amp;nbsp;var p *int&lt;/b&gt;&lt;br /&gt;0x0004 00004 (main.go:4) &amp;nbsp; MOVQ $0,AX&lt;br /&gt;&lt;br /&gt;&lt;b&gt;05 &amp;nbsp;*p = 10&lt;/b&gt;&lt;br /&gt;0x0007 00007 (main.go:5) &amp;nbsp; NOP ,&lt;br /&gt;0x0007 00007 (main.go:5) &amp;nbsp; MOVQ $10,(AX) &lt;/div&gt;&lt;br /&gt;In the assembly above we see the value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;0&lt;/span&gt;&amp;nbsp;is assigned to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;AX&lt;/span&gt; register and then the code attempts to write the value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;10&lt;/span&gt; to the memory that the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;AX&lt;/span&gt; register points to. This results in the panic and corresponding stack trace. There is no &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer check in this assembly so the compiler has left this up to the hardware to detect and report.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Compiler Checks&lt;/span&gt;&lt;br /&gt;Let&#39;s look at an example that produces a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer check by the compiler:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 package main&lt;br /&gt;02 &lt;br /&gt;03 type S struct {&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; b [4096]byte&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; i int&lt;br /&gt;06 }&lt;br /&gt;07&lt;br /&gt;08 func main() {&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; s := new(S)&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; s.i++&lt;br /&gt;11 }&lt;/div&gt;&lt;br /&gt;On lines 03 through 06 we have a struct type named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;S&lt;/span&gt;. This type has two fields. The first field is an array of 4096 bytes and the second field is an integer. Then in &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt; on line 09, we create a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;S&lt;/span&gt; and assign the address of that value to a pointer variable named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;s&lt;/span&gt;. Finally on line 10, we increment the value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;i&lt;/span&gt;&amp;nbsp;field by one, which is a field inside our value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;S&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;Let&#39;s look at the assembly&amp;nbsp;produced by the 6g compiler on darwin/amd64&amp;nbsp;for lines 09 and 10:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;go tool 6g -S main.go&lt;br /&gt;&lt;br /&gt;&lt;b&gt;09 &amp;nbsp;s := new(S)&lt;/b&gt;&lt;br /&gt;0x0036 00054 (main.go:9) &amp;nbsp; LEAQ &quot;&quot;.autotmp_0001+0(SP),DI&lt;br /&gt;0x003a 00058 (main.go:9) &amp;nbsp; MOVL $0,AX&lt;br /&gt;0x003c 00060 (main.go:9) &amp;nbsp; MOVQ $513,CX&lt;br /&gt;0x0043 00067 (main.go:9) &amp;nbsp; REP ,&lt;br /&gt;0x0044 00068 (main.go:9) &amp;nbsp; STOSQ ,&lt;br /&gt;0x0046 00070 (main.go:9) &amp;nbsp; LEAQ &quot;&quot;.autotmp_0001+0(SP),BX&lt;br /&gt;&lt;br /&gt;&lt;b&gt;10 &amp;nbsp;s.i++&lt;/b&gt;&lt;br /&gt;0x004a 00074 (main.go:10) &amp;nbsp;CMPQ BX,$0&lt;br /&gt;0x004e 00078 (main.go:10) &amp;nbsp;JEQ $1,105&lt;br /&gt;0x0050 00080 (main.go:10) &amp;nbsp;MOVQ 4096(BX),BP&lt;br /&gt;0x0057 00087 (main.go:10) &amp;nbsp;NOP ,&lt;br /&gt;0x0057 00087 (main.go:10) &amp;nbsp;INCQ ,BP&lt;br /&gt;0x005a 00090 (main.go:10) &amp;nbsp;MOVQ BP,4096(BX)&lt;br /&gt;0x0061 00097 (main.go:10) &amp;nbsp;NOP ,&lt;/div&gt;&lt;br /&gt;The code on line 10 in our example requires pointer arithmetic underneath to make it work:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;10 &amp;nbsp;s.i++&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;0x004a 00074 (main.go:10) &amp;nbsp;CMPQ BX,$0&lt;br /&gt;0x004e 00078 (main.go:10) &amp;nbsp;JEQ $1,105&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;b&gt;0x0050 00080 (main.go:10) &amp;nbsp;MOVQ 4096(BX),BP&lt;/b&gt;&lt;br /&gt;&lt;b&gt;0x0057 00087 (main.go:10) &amp;nbsp;NOP ,&lt;/b&gt;&lt;br /&gt;&lt;b&gt;0x0057 00087 (main.go:10) &amp;nbsp;INCQ ,BP&lt;/b&gt;&lt;br /&gt;&lt;b&gt;0x005a 00090 (main.go:10) &amp;nbsp;MOVQ BP,4096(BX)&lt;/b&gt;&lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;i&lt;/span&gt;&amp;nbsp;field is located at a 4096 byte offset inside the value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;S&lt;/span&gt;. In the assembly, the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;BP&lt;/span&gt;&amp;nbsp;register is assigned the value at the memory location of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;BX&lt;/span&gt;&amp;nbsp;(value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;s&lt;/span&gt;) plus the offset of 4096. Then the value of&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;BP&amp;nbsp;&lt;/span&gt;is incremented by one and the new value is assigned back to the memory at location&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;BX&lt;/span&gt; + 4096.&lt;br /&gt;&lt;br /&gt;In this example, the Go compiler is adding a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer check prior to the increment code:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;10 &amp;nbsp;s.i++&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;0x004a 00074 (main.go:10) &amp;nbsp;CMPQ BX,$0&lt;/b&gt;&lt;br /&gt;&lt;b&gt;0x004e 00078 (main.go:10) &amp;nbsp;JEQ $1,105&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;0x0050 00080 (main.go:10) &amp;nbsp;MOVQ 4096(BX),BP&lt;br /&gt;0x0057 00087 (main.go:10) &amp;nbsp;NOP ,&lt;br /&gt;0x0057 00087 (main.go:10) &amp;nbsp;INCQ ,BP&lt;br /&gt;0x005a 00090 (main.go:10) &amp;nbsp;MOVQ BP,4096(BX)&lt;/div&gt;&lt;br /&gt;The highlighted code above shows the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer check added by the compiler. The value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;BX&lt;/span&gt; is compared with the value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;0&lt;/span&gt; and if they are equal, the code jumps away from the increment code.&lt;br /&gt;&lt;br /&gt;The question is, why is Go adding a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer check in this example and not in the first example?&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;When Checks Are Added&lt;/span&gt;&lt;br /&gt;Let&#39;s take the last example and make a quick change:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 package main&lt;br /&gt;02 &lt;br /&gt;03 type S struct {&lt;br /&gt;04 &amp;nbsp; &amp;nbsp; i int &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// Switching field order&lt;br /&gt;05 &amp;nbsp; &amp;nbsp; b [4096]byte&lt;br /&gt;06 }&lt;br /&gt;07&lt;br /&gt;08 func main() {&lt;br /&gt;09 &amp;nbsp; &amp;nbsp; s := new(S)&lt;br /&gt;10 &amp;nbsp; &amp;nbsp; s.i++&lt;br /&gt;11 }&lt;/div&gt;&lt;br /&gt;All I have done is switched the fields in the struct. This time the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;i&lt;/span&gt;&amp;nbsp;field of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;int&lt;/span&gt; comes before the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;b&lt;/span&gt; field of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;byte &lt;/span&gt;&lt;span style=&quot;font-family: inherit;&quot;&gt;array&lt;/span&gt; of 4096 elements. Now let&#39;s produce the assembly as see if the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer check is still there:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;09 &amp;nbsp;s := new(S)&lt;/b&gt;&lt;br /&gt;0x0036 00054 (main.go:9) &amp;nbsp; LEAQ &quot;&quot;.autotmp_0001+0(SP),DI&lt;br /&gt;0x003a 00058 (main.go:9) &amp;nbsp; MOVL $0,AX&lt;br /&gt;0x003c 00060 (main.go:9) &amp;nbsp; MOVQ $513,CX&lt;br /&gt;0x0043 00067 (main.go:9) &amp;nbsp; REP ,&lt;br /&gt;0x0044 00068 (main.go:9) &amp;nbsp; STOSQ ,&lt;br /&gt;0x0046 00070 (main.go:9) &amp;nbsp; LEAQ &quot;&quot;.autotmp_0001+0(SP),BX&lt;br /&gt;&lt;br /&gt;&lt;b&gt;10 &amp;nbsp;s.i++&lt;/b&gt;&lt;br /&gt;0x004a 00074 (main.go:10) &amp;nbsp;NOP ,&lt;br /&gt;0x004a 00074 (main.go:10) &amp;nbsp;MOVQ (BX),BP&lt;br /&gt;0x004d 00077 (main.go:10) &amp;nbsp;NOP ,&lt;br /&gt;0x004d 00077 (main.go:10) &amp;nbsp;INCQ ,BP&lt;br /&gt;0x0050 00080 (main.go:10) &amp;nbsp;MOVQ BP,(BX)&lt;br /&gt;0x0053 00083 (main.go:10) &amp;nbsp;NOP , &lt;/div&gt;&lt;br /&gt;If you compare the assembly for the first example for line 10 with the last example you will see a big difference:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;First Example&lt;/b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; | &amp;nbsp; &lt;b&gt;Second Example&lt;/b&gt;&lt;br /&gt;CMPQ BX,$0 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | &amp;nbsp; NOP&lt;br /&gt;JEQ $1,105 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | &amp;nbsp; MOVQ (BX),BP&lt;br /&gt;MOVQ 4096(BX),BP &amp;nbsp; | &amp;nbsp; NOP ,&lt;br /&gt;NOP , &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| &amp;nbsp; INCQ ,BP&lt;br /&gt;INCQ ,BP &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | &amp;nbsp; MOVQ BP,(BX)&lt;br /&gt;MOVQ BP,4096(BX) &amp;nbsp; | &amp;nbsp; NOP ,&lt;/div&gt;&lt;br /&gt;Once we moved the integer field to be first in the struct, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer check has disappeared. Go is now&amp;nbsp;leaving it up to the hardware again to report any invalid memory access with the use of that field.&lt;br /&gt;&lt;br /&gt;The reason is that Go can trust the hardware to identify and report invalid memory access from addresses that may exist between 0x0 and 0xFFF. There is no reason for the compiler to add checks in these cases. Once the code is handling addresses that may be outside of this 4k range, &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer checks are placed back into the assembly.&lt;br /&gt;&lt;br /&gt;When the array of bytes comes first in the struct, the integer field is set at an offset past the 4k boundary. This causes the compiler to add the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;nil&lt;/span&gt; pointer check for the integer field. When the integer field is first, the compiler leaves it up to the hardware to detect because the address is within the 4k range.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;br /&gt;I don&#39;t believe in writing code with a focus on performance. Write code that is idiomatic, clean and simple. Then benchmark your program and make performance tweaks where you need to. As we saw, the design of your structs can play a role in the performance of your programs. Accessing fields within a struct value requires pointer arithmetic. For structs that are larger than 4K, the way you organize your fields could make a difference.&lt;br /&gt;&lt;br /&gt;There is one thing to note. What we are seeing is a compiler implementation detail and not part of the Go specification. This could change with any new release of Go or be different between the 5g, 6g or 8g compilers. Be careful when you performance tune on an implementation detail, these need to be rechecked with each new version. However, it is interesting to see how the compiler wants to make our code safe and yet, when it can trust the hardware it will do so.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Bonus Material&lt;/span&gt;&lt;br /&gt;If you want to see a case in the standard library where a struct was re-ordered to eliminate nil pointer checks for a field, check out this code change by Nigel Tao:&lt;br /&gt;&lt;a href=&quot;https://codereview.appspot.com/6625058&quot; target=&quot;_blank&quot;&gt;https://codereview.appspot.com/6625058&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Here is a document written by Russ Cox in July 2013 titled, &quot;Go 1.2 Field Selectors and Nil Checks&quot;.&lt;br /&gt;&lt;a href=&quot;http://golang.org/s/go12nil&quot;&gt;http://golang.org/s/go12nil&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/2683252434189590822/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/09/go-compiler-nil-pointer-checks.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/2683252434189590822'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/2683252434189590822'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/09/go-compiler-nil-pointer-checks.html' title='Go Compiler nil Pointer Checks'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-4704131148381074141</id><published>2014-08-30T14:59:00.000-04:00</published><updated>2014-08-30T14:59:42.345-04:00</updated><title type='text'>ALS Ice Bucket Challenge - Go Style</title><content type='html'>If you have not heard about the &lt;a href=&quot;http://www.alsa.org/fight-als/ice-bucket-challenge.html&quot; target=&quot;_blank&quot;&gt;ALS Ice Bucket Challenge&lt;/a&gt; I would be surprised. It&#39;s everywhere nowadays, being done by celebrities alike. After being challenged by my children there was only one person, or should I say Gopher, I knew I needed to nominate. The Gopher took to the challenge and here it is:&lt;br /&gt;&lt;br /&gt;&lt;iframe allowfullscreen=&quot;&quot; frameborder=&quot;0&quot; height=&quot;360&quot; src=&quot;//www.youtube.com/embed/FoEB4dI1Gas&quot; width=&quot;640&quot;&gt;&lt;/iframe&gt; &lt;br /&gt;I would like to thank my daughter for spending time today filming and editing the video. She is a senior member of the award winning&amp;nbsp;&lt;a href=&quot;http://vcr3.com/WBTV/TV_Production_Club.html&quot; target=&quot;_blank&quot;&gt;West Broward High School TV Production Club&lt;/a&gt;. They&amp;nbsp;do amazing work so please give them a shot out on twitter at&amp;nbsp;&lt;a href=&quot;https://twitter.com/wbtvclub&quot; target=&quot;_blank&quot;&gt;@wbtvclub&lt;/a&gt;&amp;nbsp;if you enjoyed the video.&lt;br /&gt;&lt;i&gt;&lt;br /&gt;&lt;/i&gt;&lt;i&gt;The Gopher character is based on the Go mascot designed by Renée French and copyrighted under the Creative Commons Attribution 3.0 license.&lt;/i&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/4704131148381074141/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/08/als-ice-bucket-challenge-go-style.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/4704131148381074141'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/4704131148381074141'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/08/als-ice-bucket-challenge-go-style.html' title='ALS Ice Bucket Challenge - Go Style'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-3332669871159299206</id><published>2014-06-27T19:31:00.000-04:00</published><updated>2014-06-27T22:04:31.060-04:00</updated><title type='text'>Ice Cream Makers and Data Races Part II</title><content type='html'>&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;br /&gt;Dave Cheney published a post called &lt;a href=&quot;http://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races&quot; target=&quot;_blank&quot;&gt;Ice Cream Makers and Data Races&lt;/a&gt;. The post showed an example of an interesting data race that can occur when using an interface typed variable to make a method call. If you have not read the post yet please do. Once you read the post you will discover that the problem lies with the fact that an interface value is implemented internally using a two word header and that the Go memory model states only writes to a single word are atomic.&lt;br /&gt;&lt;br /&gt;The program in the post shows a race condition that allows two goroutines to perform a read and write operation at the same time against an interface value. Not synchronizing this read and write allows the read to observe a partial write to the interface value. This allows the method implementation for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; type to operate against a value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; type and visa versa.&lt;br /&gt;&lt;br /&gt;In Dave&#39;s example, the layout of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; structs were identical in memory, so they were in some sense compatible. Dave suggested the chaos that would occur if they had different memory representations. This is because each implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Hello&lt;/span&gt; method assumes the code is operating against values of the receiver type. When this bug surfaces, this is no longer the case. To give you a visual view of this suggested chaos, I am going to change the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; type in two different ways. Both changes will give you some better insight into the interworking of interface types and memory.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;First Code Change&lt;/span&gt;&lt;br /&gt;Let&#39;s review the code and see the first set of changes. My changes to the original code are in bold:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 import &quot;fmt&quot;&lt;br /&gt;04&lt;br /&gt;05 type IceCreamMaker interface {&lt;br /&gt;06 &amp;nbsp; &amp;nbsp;// Great a customer.&lt;br /&gt;07 &amp;nbsp; &amp;nbsp;Hello()&lt;br /&gt;08 }&lt;br /&gt;09&lt;br /&gt;10 type Ben struct {&lt;br /&gt;11 &amp;nbsp; &amp;nbsp;name string&lt;br /&gt;12 }&lt;br /&gt;13&lt;br /&gt;&lt;b&gt;14 func (b *Ben) Hello() {&lt;/b&gt;&lt;br /&gt;&lt;b&gt;15 &amp;nbsp; &amp;nbsp;if b.name != &quot;Ben&quot; {&lt;/b&gt;&lt;br /&gt;&lt;b&gt;16 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;fmt.Printf(&quot;Ben says, \&quot;Hello my name is %s\&quot;\n&quot;, b.name)&lt;/b&gt;&lt;br /&gt;&lt;b&gt;17 &amp;nbsp; &amp;nbsp;}&lt;/b&gt;&lt;br /&gt;&lt;b&gt;18 }&lt;/b&gt;&lt;br /&gt;19&lt;br /&gt;&lt;b&gt;20 type Jerry struct {&lt;/b&gt;&lt;br /&gt;&lt;b&gt;21 &amp;nbsp; &amp;nbsp;field1 *[5]byte&lt;/b&gt;&lt;br /&gt;&lt;b&gt;22 &amp;nbsp; &amp;nbsp;field2 int&lt;/b&gt;&lt;br /&gt;&lt;b&gt;23 }&lt;/b&gt;&lt;br /&gt;24&lt;br /&gt;&lt;b&gt;25 func (j *Jerry) Hello() {&lt;/b&gt;&lt;br /&gt;&lt;b&gt;26 &amp;nbsp; &amp;nbsp;name := string((*j.field1)[:])&lt;/b&gt;&lt;br /&gt;&lt;b&gt;27 &amp;nbsp; &amp;nbsp;if name != &quot;Jerry&quot; {&lt;/b&gt;&lt;br /&gt;&lt;b&gt;28 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;fmt.Printf(&quot;Jerry says, \&quot;Hello my name is %s\&quot;\n&quot;, name)&lt;/b&gt;&lt;br /&gt;&lt;b&gt;29 &amp;nbsp; &amp;nbsp;}&lt;/b&gt;&lt;br /&gt;&lt;b&gt;30 }&lt;/b&gt;&lt;br /&gt;31&lt;br /&gt;32 func main() {&lt;br /&gt;33 &amp;nbsp; &amp;nbsp;var ben = &amp;amp;Ben{&quot;Ben&quot;}&lt;br /&gt;&lt;b&gt;34&lt;/b&gt; &amp;nbsp; &amp;nbsp;&lt;b&gt;var jerry = &amp;amp;Jerry{&amp;amp;[5]byte{&#39;J&#39;, &#39;e&#39;, &#39;r&#39;, &#39;r&#39;, &#39;y&#39;}, 5}&lt;/b&gt;&lt;br /&gt;35 &amp;nbsp; &amp;nbsp;var maker IceCreamMaker = ben&lt;br /&gt;36&lt;br /&gt;37 &amp;nbsp; &amp;nbsp;var loop0, loop1 func()&lt;br /&gt;38&lt;br /&gt;39 &amp;nbsp; &amp;nbsp;loop0 = func() {&lt;br /&gt;40 &amp;nbsp; &amp;nbsp;maker = ben&lt;br /&gt;41 &amp;nbsp; &amp;nbsp;go loop1()&lt;br /&gt;42 &amp;nbsp; &amp;nbsp;}&lt;br /&gt;43&lt;br /&gt;44 &amp;nbsp; &amp;nbsp;loop1 = func() {&lt;br /&gt;45 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;maker = jerry&lt;br /&gt;46 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;go loop0()&lt;br /&gt;47 &amp;nbsp; &amp;nbsp;}&lt;br /&gt;48&lt;br /&gt;49 &amp;nbsp; &amp;nbsp;go loop0()&lt;br /&gt;50&lt;br /&gt;51 &amp;nbsp; &amp;nbsp;for {&lt;br /&gt;52 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;maker.Hello()&lt;br /&gt;53 &amp;nbsp; &amp;nbsp;}&lt;br /&gt;54 } &lt;/div&gt;&lt;br /&gt;In the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Hello&lt;/span&gt; method for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; type on lines 14 through 18, I changed the code to only display the message when the name is not Ben. This is a simple change so we don&#39;t have to go through the results looking for when the bug surfaces.&lt;br /&gt;&lt;br /&gt;Then on lines 20 through 23, I completely changed out the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; type. The declaration is now a manual representation of a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt;. A &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; in Go consists of a header with two words. The first word is a pointer to an array of bytes and the second word is the length of the string. This is similar to a slice but without the third word in the header for the capacity. The declarations of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; structs represent the same memory layout though declared very differently.&lt;br /&gt;&lt;br /&gt;The idea of changing the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; type in this fashion is to show how serious this data race condition Dave created is. When the implementation of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Hello&lt;/span&gt;&amp;nbsp;method for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; type is called, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Printf&lt;/span&gt; function is going to print the characters for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;name&lt;/span&gt; field. When the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Hello&lt;/span&gt; implementation for type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt;&amp;nbsp;is called using a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt;, the memory associated with the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;name&lt;/span&gt; field could be anything. In this case we are guaranteeing that there is a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt;&amp;nbsp;representation so the code does not stack trace, but doing this by unusual means.&lt;br /&gt;&lt;br /&gt;One lines 25 through 30, I changed the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Hello&lt;/span&gt; method for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; type. I convert the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;byte&lt;/span&gt; array to a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; and use the new &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;name&lt;/span&gt; variable to check and display the value. Since the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;name&lt;/span&gt; field in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; type is equivalent to the declaration of the two fields declared in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; type, everything will print out appropriately.&lt;br /&gt;&lt;br /&gt;Finally on line 34, I create and initialize the variable of type Jerry, setting the bytes and length. Then the rest of the code remains as is.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Running The Program&lt;/span&gt;&lt;br /&gt;When we run this new version of the program the output does not change at all:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Jerry says, &quot;Hello my name is Ben&quot;&lt;br /&gt;Ben says, &quot;Hello my name is Jerry&quot;&lt;br /&gt;Ben says, &quot;Hello my name is Jerry&quot;&lt;br /&gt;Jerry says, &quot;Hello my name is Ben&quot;&lt;br /&gt;Ben says, &quot;Hello my name is Jerry&quot;&lt;/div&gt;&lt;br /&gt;Even though the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; types are different, the memory layouts are the same and the program runs as designed:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type Ben struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp;name string&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;type Jerry struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp;field1 *[5]byte&lt;br /&gt;&amp;nbsp; &amp;nbsp;field2 int&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;fmt.Printf(&quot;Ben says, \&quot;Hello my name is %s\&quot;\n&quot;, b.name)&lt;br /&gt;&lt;br /&gt;name := string((*j.field1)[:])&lt;br /&gt;fmt.Printf(&quot;Jerry says, \&quot;Hello my name is %s\&quot;\n&quot;, name)&lt;/div&gt;&lt;br /&gt;In the case of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Printf&lt;/span&gt; function call for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; type implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Hello&lt;/span&gt; method, the code thinks the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;b&lt;/span&gt; pointer is pointing to a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; when it is not. However, since the memory layout is the same between the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; types, the call to the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Printf&lt;/span&gt;&amp;nbsp;function still works.&amp;nbsp;The same is true for the implementation of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Hello&lt;/span&gt; method for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; type. The values of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;field1&lt;/span&gt;&amp;nbsp;and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;field2&lt;/span&gt; are equivalent to declaring a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; field so everything works.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Crashing The Program&lt;/span&gt;&lt;br /&gt;Let&#39;s change the code one more time. This time we will make the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; type incompatible with the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; type:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;01 package main&lt;br /&gt;02&lt;br /&gt;03 import &quot;fmt&quot;&lt;br /&gt;04&lt;br /&gt;05 type IceCreamMaker interface {&lt;br /&gt;06 &amp;nbsp; &amp;nbsp;// Great a customer.&lt;br /&gt;07 &amp;nbsp; &amp;nbsp;Hello()&lt;br /&gt;08 }&lt;br /&gt;09&lt;br /&gt;10 type Ben struct {&lt;br /&gt;11 &amp;nbsp; &amp;nbsp;name string&lt;br /&gt;12 }&lt;br /&gt;13&lt;br /&gt;14 func (b *Ben) Hello() {&lt;br /&gt;15 &amp;nbsp; &amp;nbsp;if b.name != &quot;Ben&quot; {&lt;br /&gt;16 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;fmt.Printf(&quot;Ben says, \&quot;Hello my name is %s\&quot;\n&quot;, b.name)&lt;br /&gt;17 &amp;nbsp; &amp;nbsp;}&lt;br /&gt;18 }&lt;br /&gt;19&lt;br /&gt;&lt;b&gt;20 type Jerry struct {&lt;/b&gt;&lt;br /&gt;&lt;b&gt;21 &amp;nbsp; &amp;nbsp;field2 int&lt;/b&gt;&lt;br /&gt;&lt;b&gt;22 &amp;nbsp; &amp;nbsp;field1 *[5]byte&lt;/b&gt;&lt;br /&gt;&lt;b&gt;23 }&lt;/b&gt;&lt;br /&gt;24&lt;br /&gt;25 func (j *Jerry) Hello() {&lt;br /&gt;26 &amp;nbsp; &amp;nbsp;name := string((*j.field1)[:])&lt;br /&gt;27 &amp;nbsp; &amp;nbsp;if name != &quot;Jerry&quot; {&lt;br /&gt;28 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;fmt.Printf(&quot;Jerry says, \&quot;Hello my name is %s\&quot;\n&quot;, name)&lt;br /&gt;29 &amp;nbsp; &amp;nbsp;}&lt;br /&gt;30 }&lt;br /&gt;31&lt;br /&gt;32 func main() {&lt;br /&gt;33 &amp;nbsp; &amp;nbsp;var ben = &amp;amp;Ben{&quot;Ben&quot;}&lt;br /&gt;&lt;b&gt;34&lt;/b&gt; &amp;nbsp; &amp;nbsp;&lt;b&gt;var jerry = &amp;amp;Jerry{5,&amp;nbsp;&lt;/b&gt;&lt;b&gt;&amp;amp;[5]byte{&#39;J&#39;, &#39;e&#39;, &#39;r&#39;, &#39;r&#39;, &#39;y&#39;}&lt;/b&gt;&lt;b&gt;}&lt;/b&gt;&lt;br /&gt;35 &amp;nbsp; &amp;nbsp;var maker IceCreamMaker = ben&lt;br /&gt;36&lt;br /&gt;37 &amp;nbsp; &amp;nbsp;var loop0, loop1 func()&lt;br /&gt;38&lt;br /&gt;39 &amp;nbsp; &amp;nbsp;loop0 = func() {&lt;br /&gt;40 &amp;nbsp; &amp;nbsp;maker = ben&lt;br /&gt;41 &amp;nbsp; &amp;nbsp;go loop1()&lt;br /&gt;42 &amp;nbsp; &amp;nbsp;}&lt;br /&gt;43&lt;br /&gt;44 &amp;nbsp; &amp;nbsp;loop1 = func() {&lt;br /&gt;45 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;maker = jerry&lt;br /&gt;46 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;go loop0()&lt;br /&gt;47 &amp;nbsp; &amp;nbsp;}&lt;br /&gt;48&lt;br /&gt;&lt;b&gt;49 &amp;nbsp; &amp;nbsp;fmt.Printf(&quot;Ben: %p  Jerry: %p\n&quot;, ben, jerry)&lt;/b&gt;&lt;br /&gt;50&lt;br /&gt;51 &amp;nbsp; &amp;nbsp;go loop0()&lt;br /&gt;52&lt;br /&gt;53 &amp;nbsp; &amp;nbsp;for {&lt;br /&gt;54 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;maker.Hello()&lt;br /&gt;55 &amp;nbsp; &amp;nbsp;}&lt;br /&gt;56 } &lt;/div&gt;&lt;br /&gt;Now the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; type between lines 20 through 23 switches the order of the two field members. The integer value now comes before the byte array pointer. When we run this version of the program we get a stack trace:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;Ben: 0x20817a170  Jerry: 0x20817a180&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;01 panic: runtime error: invalid memory address or nil pointer dereference&lt;br /&gt;02 [signal 0xb code=0x1 addr=0x5 pc=0x294f6]&lt;br /&gt;03&lt;br /&gt;04 goroutine 16 [running]:&lt;br /&gt;05 runtime.panic(0xb90e0, 0x144144)&lt;br /&gt;06 &amp;nbsp; &amp;nbsp;/Users/bill/go/src/pkg/runtime/panic.c:279 +0xf5&lt;br /&gt;07 fmt.(*fmt).padString(0x2081b42d0, 0x5, 0x20817a190)&lt;br /&gt;08 &amp;nbsp; &amp;nbsp;/Users/bill/go/src/pkg/fmt/format.go:130 +0x390&lt;br /&gt;09 fmt.(*fmt).fmt_s(0x2081b42d0, 0x5, 0x20817a190)&lt;br /&gt;10 &amp;nbsp; &amp;nbsp;/Users/bill/go/src/pkg/fmt/format.go:285 +0x67&lt;br /&gt;11 fmt.(*pp).fmtString(0x2081b4270, 0x5, 0x20817a190, 0x73)&lt;br /&gt;12 &amp;nbsp; &amp;nbsp;/Users/bill/go/src/pkg/fmt/print.go:511 +0xe0&lt;br /&gt;13 fmt.(*pp).printArg(0x2081b4270, 0x97760, 0x20817a210, 0x73, 0x0, 0x0)&lt;br /&gt;14 &amp;nbsp; &amp;nbsp;/Users/bill/go/src/pkg/fmt/print.go:780 +0xbb8&lt;br /&gt;15 fmt.(*pp).doPrintf(0x2081b4270, 0xddfd0, 0x20, 0x220832de40, 0x1, 0x1)&lt;br /&gt;16 &amp;nbsp; &amp;nbsp;/Users/bill/go/src/pkg/fmt/print.go:1159 +0x1ecc&lt;br /&gt;17 fmt.Fprintf(0x220818c340, 0x2081c2008, 0xddfd0, 0x20, 0x220832de40, 0x1, 0x1, 0x10, 0x0, 0x0)&lt;br /&gt;18 &amp;nbsp; &amp;nbsp; /Users/bill/go/src/pkg/fmt/print.go:188 +0x7f&lt;br /&gt;19 fmt.Printf(0xddfd0, 0x20, 0x220832de40, 0x1, 0x1, 0x5, 0x0, 0x0)&lt;br /&gt;20 &amp;nbsp; &amp;nbsp;/Users/bill/go/src/pkg/fmt/print.go:197 +0xa2&lt;br /&gt;&lt;b&gt;21 main.(*Ben).Hello(0x20817a180)&lt;/b&gt;&lt;br /&gt;22 &amp;nbsp; &amp;nbsp;/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/temp/main.go:16 +0x118&lt;br /&gt;23 main.main()&lt;br /&gt;24 &amp;nbsp; &amp;nbsp;/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/temp/main.go:54 +0x2c3&lt;/div&gt;&lt;br /&gt;If we look at line 21 of the stack trace we will see how the method call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Hello&lt;/span&gt; is using the implementation for type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; but being passed the address of the value for type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt;. Just before the stack trace I display the addresses of each value to make this clear. If we look at the declaration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Ben&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt; types one more time we can see how they are no longer compatible:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type Ben struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp;name string&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;type Jerry struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp;field2 int&lt;br /&gt;&amp;nbsp; &amp;nbsp;field1 *[5]byte&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;Since this new declaration for type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Jerry&lt;/span&gt;&amp;nbsp;now starts with an integer value, it is not compatible with a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;string&lt;/span&gt; type. This time when the code tries to print the value of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;b.name&lt;/span&gt; on line 16, the program stack traces.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;br /&gt;In the end, a running program manipulates memory without any safeguards from the compiler. Memory is just memory and the CPU will interpret that memory as it is told. In the crash example, thanks to the data race bug, the code asked the CPU to interpret an integer value as a string and the program crashed. So I agree with Dave, there is no such thing as a safe data race.&amp;nbsp;Your program either has no data races, or its operation is undefined.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Cherry On Top&lt;/span&gt;&lt;br /&gt;After reading both posts you might be disappointed that no ice cream was actually used in the writing of these posts. If you&#39;re bummed out now and wished you had some coupons, I found a link to signup for the Ben and Jerry&#39;s &lt;a href=&quot;http://www.benjerry.com/about-us/contact-us?selectedForm=newsletter#selectForm&quot; target=&quot;_blank&quot;&gt;newsletter&lt;/a&gt;. You can also &lt;a href=&quot;http://www.benjerry.com/&quot; target=&quot;_blank&quot;&gt;find a store&lt;/a&gt; near you.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/3332669871159299206/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/06/ice-cream-makers-and-data-races-part-ii.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/3332669871159299206'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/3332669871159299206'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/06/ice-cream-makers-and-data-races-part-ii.html' title='Ice Cream Makers and Data Races Part II'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-5031828978589342939</id><published>2014-06-25T10:20:00.000-04:00</published><updated>2014-06-25T10:27:17.518-04:00</updated><title type='text'>Actionable Data With MongoDB and Go</title><content type='html'>&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;br /&gt;If you are building any kind of application for a consumer based product, it is common to have large amounts of application data being generated about your users. Running reports is a traditional use of this data, but what if you could make this data actionable? What if you could adapt the user experience by aggregating and testing this data against rules that could dictate actions or special messaging?&lt;br /&gt;&lt;br /&gt;In this post I am going to show you a way that could be used to make your application data “actionable”. We are going to review a sample program written in Go that leverages MongoDB&#39;s aggregation pipeline to execute rules that aggregate and test data. The rule the program defines and executes determines what messaging we want to show the user based on their current set of financial transactions in the system.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The Data&lt;/span&gt;&lt;br /&gt;We have two collections of data we will be using which are being hosted in a public &lt;a href=&quot;https://mongolab.com/welcome/&quot; target=&quot;_blank&quot;&gt;MongoLab&lt;/a&gt; database.&amp;nbsp;The first collection contains credit card transactions for users. This data represent application generated data:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Collection: demo_user_transactions&lt;br /&gt;{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;user_id&quot; : &quot;396bc782-6ac6-4183-a671-6e75ca5989a5&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;description&quot; : &quot;Chevron&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;amount&quot; : 23.76,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;date&quot; : ISODate(&quot;2014-04-20T00:00:00.000Z&quot;),&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;category&quot; : &quot;gas&quot;&lt;br /&gt;},&lt;br /&gt;{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;user_id&quot; : &quot;396bc782-6ac6-4183-a671-6e75ca5989a5&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;description&quot; : &quot;Fandango&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;amount&quot; : 15.6,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;date&quot; : ISODate(&quot;2014-04-20T00:00:00.000Z&quot;),&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;category&quot; : &quot;movies&quot;&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;The second collection contains a set of user advice which is presented to the user based on some aspect of their financial transactions. This data represents configuration data:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Collection: demo_user_advice&lt;br /&gt;{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;advice_id&quot; : 1,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;title&quot; : &quot;Dealing with Rising Gas Prices&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;link&quot; : &quot;www.careonecredit.com/knowledge/dealingwithrisinggasprices.aspx&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;desc&quot; : &quot;With gas prices rising, and no relief in sight, looking for...&quot;&lt;br /&gt;},&lt;br /&gt;{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;advice_id&quot; : 2,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;title&quot; : &quot;Ways To Stretch A Dollar&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;link&quot; : &quot;www.careonecredit.com/knowledge/ways-to-stretch-a-dollar.aspx&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;desc&quot; : &quot;Are you looking for ways to make your dollar go further?...&quot;&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;We can imagine the transaction data is changing as the system refreshes user transactions throughout the day. The advice data is configurable and can be changed by marketing or business analyst people throughout the day as well. These two collections will allow us to create rules and adapt the user experience by providing the most relevant advice for the target user.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The Rule&lt;/span&gt;&lt;br /&gt;To make the data actionable we need to define a rule. For this sample program, a rule defines a test expression that is run through the aggregation pipeline to determine a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;true&lt;/span&gt; or &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;false&lt;/span&gt; condition which then results in an action. For this example we are going to create a rule that looks at a user’s purchasing of gasoline. Based on the amount of money the user spends, the action will be to display a piece of advice that is relevant.&lt;br /&gt;&lt;br /&gt;Let’s look at the rule we are going to run and the success and failure actions:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;{&lt;br /&gt;&amp;nbsp; &quot;test&quot; : {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;collection&quot; : &quot;demo_user_transactions&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;expressions&quot; : [&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;{ \&quot;$match\&quot; : { \&quot;user_id\&quot; : \&quot;#userId#\&quot;, \&quot;category\&quot; : \&quot;gas\&quot; }}&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;{ \&quot;$group\&quot; : { \&quot;_id\&quot; : { \&quot;category\&quot; : \&quot;$category\&quot; }, \&quot;amount\&quot; : { \&quot;$sum\&quot; : \&quot;$amount\&quot; }}}&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;{ \&quot;$match\&quot; : { \&quot;amount\&quot; : { \&quot;$gt\&quot; : 20.00}}}&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ]&lt;br /&gt;&amp;nbsp; },&lt;br /&gt;&amp;nbsp; &quot;success&quot; : {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;collection&quot; : &quot;demo_advice&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;expressions&quot; : [&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;{ \&quot;$match\&quot; : { \&quot;advice_id\&quot; : 1 }}&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ]&lt;br /&gt;&amp;nbsp; },&lt;br /&gt;&amp;nbsp; &quot;failed&quot; : {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;collection&quot; : &quot;demo_advice&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;expressions&quot; : [&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;{ \&quot;$match\&quot; : { \&quot;advice_id\&quot; : 2 }}&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ]&lt;br /&gt;&amp;nbsp; }&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;The rule is defined as a JSON document that contains three fields each with a sub-document that contains a collection name and the set of expressions to be run through the aggregation pipeline. When the expressions for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;test&lt;/span&gt; field returns a dataset, then the application will run the expressions defined in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;success&lt;/span&gt; field. When no dataset is returned, then the application will run the expressions in the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;failed&lt;/span&gt; field.&lt;br /&gt;&lt;br /&gt;If we look at the rule a bit closer we can see what we are testing:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;{ &quot;$match&quot; : { &quot;user_id&quot; : &quot;#userId#&quot;, &quot;category&quot; : &quot;gas&quot; }}&lt;br /&gt;{ &quot;$group&quot; : { &quot;_id&quot; : { &quot;category&quot; : &quot;$category&quot; }, &quot;amount&quot; : { &quot;$sum&quot; : &quot;$amount&quot; }}}&lt;br /&gt;{ &quot;$match&quot; : { &quot;amount&quot; : { &quot;$gt&quot; : 20.00}}} &lt;/div&gt;&lt;br /&gt;The first pipeline operation uses a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;$match&lt;/span&gt; command to find all the documents from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;demo_user_transactions&lt;/span&gt; collection for a specific user where the category is &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;gas&lt;/span&gt;. The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;#userId#&lt;/span&gt; tag is replaced with the actual user id by the program before running the expression. Then those &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;gas&lt;/span&gt; transactions are grouped and the total amount spent on gasoline is calculated using the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;$group&lt;/span&gt; command. Finally that total spend on gasoline is tested to see if it is greater than $20. If the total spend on gasoline is greater than $20, there will be a dataset returned signifying the rule is &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;true&lt;/span&gt; else no dataset is returned and the rule is &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;false&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The Code&lt;/span&gt;&lt;br /&gt;Now that we have a brief understanding of the data and the rule, we can examine some of the code that executes this rule against our test MongoDB database. The code is in &lt;a href=&quot;https://github.com/goinggo/mgoaction&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt; and you can use the following Go command if you have Go already installed: &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;go get github.com/goinggo/mgoaction &lt;/div&gt;&lt;br /&gt;If you don&#39;t have Go installed check out these links to get started:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://golang.org/doc/install&quot; target=&quot;_blank&quot;&gt;http://golang.org/doc/install&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://www.goinggo.net/2013/06/installing-go-gocode-gdb-and-liteide.html&quot; target=&quot;_blank&quot;&gt;http://www.goinggo.net/2013/06/installing-go-gocode-gdb-and-liteide.html&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;To make the application dynamic and keep things simple, the rule is being kept in an individual JSON file within a project folder called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;rules&lt;/span&gt;. This allows us to change the rule without needing to change the program. Let’s examine the function that reads and decode the JSON document from within a given file into a Go struct value so the rule can be processed by the program. We have already seen the JSON document for the rule above, so here are the structs that the JSON document will be decoded into:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// operation contains a set of expressions for a collection.&lt;br /&gt;type operation struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; Collection &amp;nbsp;string &amp;nbsp; `json:&quot;collection&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; Expressions []string `json:&quot;expressions&quot;`&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// rule contains a single rule with an action.&lt;br /&gt;type rule struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; Test &amp;nbsp; &amp;nbsp;operation `json:&quot;rule&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; Success operation `json:&quot;success&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; Failed &amp;nbsp;operation `json:&quot;failed&quot;`&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;Support for decoding JSON documents exists within the Go standard library. Here is the function &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;retrieveRule&lt;/span&gt; that decodes the JSON document found in&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;rules/advice.json&lt;/span&gt;&amp;nbsp;into a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;rule&lt;/span&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;:&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&amp;nbsp;92 // retrieveRule reads and unmarshals the specified rule data file.&lt;br /&gt;&amp;nbsp;93 func retrieveRule(ruleName string) (*rule, error) {&lt;br /&gt;&amp;nbsp;94 &amp;nbsp; &amp;nbsp; // Open the file.&lt;br /&gt;&amp;nbsp;95 &amp;nbsp; &amp;nbsp; file, err := os.Open(&quot;rules/&quot; + ruleName + &quot;.json&quot;)&lt;br /&gt;&amp;nbsp;96 &amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;&amp;nbsp;97 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return nil, err&lt;br /&gt;&amp;nbsp;98 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp;99&lt;br /&gt;100 &amp;nbsp; &amp;nbsp; // Schedule the file to be closed once the function returns.&lt;br /&gt;101 &amp;nbsp; &amp;nbsp; defer file.Close()&lt;br /&gt;102&lt;br /&gt;103 &amp;nbsp; &amp;nbsp; // Decode the file into a value of the rule type.&lt;br /&gt;104 &amp;nbsp; &amp;nbsp; var r rule&lt;br /&gt;105 &amp;nbsp; &amp;nbsp; err = json.NewDecoder(file).Decode(&amp;amp;r)&lt;br /&gt;106&lt;br /&gt;107 &amp;nbsp; &amp;nbsp; // We don&#39;t need to check for errors, the caller can do this.&lt;br /&gt;108 &amp;nbsp; &amp;nbsp; return &amp;amp;r, err&lt;br /&gt;109 } &lt;/div&gt;&lt;br /&gt;The function is passed a rule name which is used to form the path to the rule file. On line 95 the file is opened and then on line 104 a variable named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;r&lt;/span&gt; of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;rule&lt;/span&gt; is declared. In combination with the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;json&lt;/span&gt; package&#39;s&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;NewDecoder&lt;/span&gt; function followed by the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Decode&lt;/span&gt; method on line 105, the value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;r&lt;/span&gt; variable is updated to reflect the JSON document’s data. Then the address of the variable is passed out of the function for use on line 108.&lt;br /&gt;&lt;br /&gt;Next let’s look at the rule processing function named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;processRule&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;111 // processRule processes the rule and displays the results.&lt;br /&gt;112 func processRule(session *mgo.Session, r *rule, user string) error {&lt;br /&gt;113 &amp;nbsp; &amp;nbsp; // Process the rule and check for results&lt;br /&gt;114 &amp;nbsp; &amp;nbsp; log.Println(&quot;Test:&quot;)&lt;br /&gt;115 &amp;nbsp; &amp;nbsp; results, err := executeOperation(session, r.Test, user)&lt;br /&gt;116 &amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;117 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Println(&quot;Unable To Process Action&quot;, err)&lt;br /&gt;118 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return err&lt;br /&gt;119 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;120&lt;br /&gt;121 &amp;nbsp; &amp;nbsp; if len(results) == 0 {&lt;br /&gt;122 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // If no result is returned, provide the failed result&lt;br /&gt;123 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Println(&quot;Failed:&quot;)&lt;br /&gt;124 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; _, err = executeOperation(session, r.Failed, user)&lt;br /&gt;125 &amp;nbsp; &amp;nbsp; } else {&lt;br /&gt;126 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Provide the success result&lt;br /&gt;127 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Println(&quot;Succeeded:&quot;)&lt;br /&gt;128 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; _, err = executeOperation(session, r.Success, user)&lt;br /&gt;129 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;130&lt;br /&gt;131 &amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;132 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Println(&quot;Unable To Process Action&quot;, err)&lt;br /&gt;133 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;134&lt;br /&gt;135 &amp;nbsp; &amp;nbsp; return err&lt;br /&gt;136 } &lt;/div&gt;&lt;br /&gt;This function on line 115 executes the expressions for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Test&lt;/span&gt; field using the aggregation pipeline and then on line 116 checks for errors. If there are no errors, the determination if a result was returned is tested on line 121. If there is no result, the function executes the set of expressions for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Failed&lt;/span&gt; field on line 124, else the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Success&lt;/span&gt; field expressions are executed on line 128. A test for an error value occurs one more time on line 131 for logging purposes and then the function returns.&lt;br /&gt;&lt;br /&gt;Let’s look at one more function named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;executeOperation&lt;/span&gt; to see how the expressions are actually sent to the aggregation pipeline for processing:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;138 // executeOperation builds an aggregation pipeline query based on the&lt;br /&gt;139 // configured expressions for the operation.&lt;br /&gt;140 func executeOperation(session *mgo.Session, op operation, user string) ([]bson.M, error) {&lt;br /&gt;141 &amp;nbsp; &amp;nbsp; var err error&lt;br /&gt;142 &amp;nbsp; &amp;nbsp; expressions := make([]bson.M, len(op.Expressions))&lt;br /&gt;143&lt;br /&gt;144 &amp;nbsp; &amp;nbsp; // Iterate through the set of expressions and build the slice&lt;br /&gt;145 &amp;nbsp; &amp;nbsp; // of operations.&lt;br /&gt;146 &amp;nbsp; &amp;nbsp; for index, exp := range op.Expressions {&lt;br /&gt;147 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if index := strings.Index(exp, &quot;#userId#&quot;); index &amp;gt;= 0 {&lt;br /&gt;148 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; exp = strings.Replace(exp, &quot;#userId#&quot;, user, -1)&lt;br /&gt;149 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;150&lt;br /&gt;151 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.Println(exp)&lt;br /&gt;152 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; expressions[index] = decodeExpression(exp)&lt;br /&gt;153 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;154&lt;br /&gt;155 &amp;nbsp; &amp;nbsp; // Capture a collection so we can execute the expressions.&lt;br /&gt;156 &amp;nbsp; &amp;nbsp; collection := session.DB(TestDatabase).C(op.Collection)&lt;br /&gt;157 &amp;nbsp; &amp;nbsp; if collection == nil {&lt;br /&gt;158 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return nil, fmt.Errorf(&quot;Collection %s does not exist&quot;, op.Collection)&lt;br /&gt;159 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;160&lt;br /&gt;161 &amp;nbsp; &amp;nbsp; // Execute the expressions against the aggregation pipeline.&lt;br /&gt;162 &amp;nbsp; &amp;nbsp; var results []bson.M&lt;br /&gt;163 &amp;nbsp; &amp;nbsp; err = collection.Pipe(expressions).All(&amp;amp;results)&lt;br /&gt;164&lt;br /&gt;165 &amp;nbsp; &amp;nbsp; // Pretty print the result.&lt;br /&gt;166 &amp;nbsp; &amp;nbsp; output, _ := json.MarshalIndent(results, &quot;&quot;, &quot;    &quot;)&lt;br /&gt;167 &amp;nbsp; &amp;nbsp; log.Println(string(output))&lt;br /&gt;168&lt;br /&gt;169 &amp;nbsp; &amp;nbsp; return results, err&lt;br /&gt;170 } &lt;/div&gt;&lt;br /&gt;On line 142 we declare a slice of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bson.M&lt;/span&gt; named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;expressions&lt;/span&gt; to hold all the expressions we need to execute and then between lines 146 through 153 we iterate through that set of expressions. The first thing that is done in each iteration on line 147 is to check the expression for a user id tag. If the tag is found, it is replaced with the actual user id. On line 151 the expression is displayed and finally on line 152 the expression is decoded into a map of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bson.M&lt;/span&gt; and assigned to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;expressions&lt;/span&gt; slice.&lt;br /&gt;&lt;br /&gt;Once the slice of expressions is ready for execution, we capture a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;collection&lt;/span&gt; value from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;session&lt;/span&gt;&amp;nbsp;value on line 156 and execute the expressions against that collection on line 163. The results from the aggregation pipeline are then returned from the function for processing, which take the form of another map of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;bson.M&lt;/span&gt;. One line 166 we create a pretty print view of the results and then display those results on line 167.&lt;br /&gt;&lt;br /&gt;Now that we have seen the code, let’s look at the results when we run the program for the data and the rule we reviewed.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The Result&lt;/span&gt;&lt;br /&gt;When we run the program we see the following output:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Test:&lt;br /&gt;{ &quot;$match&quot; : { &quot;user_id&quot; : &quot;396bc782-6ac6-4183-a671-6e75ca5989a5&quot;, &quot;category&quot; : &quot;gas&quot; }}&lt;br /&gt;{ &quot;$group&quot; : { &quot;_id&quot; : { &quot;category&quot; : &quot;$category&quot; }, &quot;amount&quot; : { &quot;$sum&quot; : &quot;$amount&quot; }}}&lt;br /&gt;{ &quot;$match&quot; : { &quot;amount&quot; : { &quot;$gt&quot; : 20.00}}}&lt;br /&gt;[&lt;br /&gt;&amp;nbsp; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;_id&quot;: {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;category&quot;: &quot;gas&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; },&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;amount&quot;: 23.76&lt;br /&gt;&amp;nbsp; }&lt;br /&gt;]&lt;br /&gt;Success:&lt;br /&gt;{ &quot;$match&quot; : { &quot;advice_id&quot; : 1 }}&lt;br /&gt;[&lt;br /&gt;&amp;nbsp; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;_id&quot;: &quot;53a70e71792ac1bbba4b016e&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;advice_id&quot;: 1,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;desc&quot;: &quot;With gas prices rising, and no relief in sight, looking for...&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;link&quot;: &quot;www.careonecredit.com/knowledge/dealingwithrisinggasprices.aspx&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;title&quot;: &quot;Dealing with Rising Gas Prices&quot;&lt;br /&gt;&amp;nbsp; }&lt;br /&gt;] &lt;/div&gt;&lt;br /&gt;The first section of the output shows the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Test&lt;/span&gt; expressions that are executed through the aggregation pipeline with the result immediately following. The results show the total spend for the user was $23.76. Since this value is greater than $20.00, the code then proceeds to execute the Success expressions. This one expression returns the advice document for&amp;nbsp;the advice about managing transportation costs.&lt;br /&gt;&lt;br /&gt;If we change the rule so it fails we should get the other piece of advice:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Test:&lt;br /&gt;{ &quot;$match&quot; : { &quot;user_id&quot; : &quot;396bc782-6ac6-4183-a671-6e75ca5989a5&quot;, &quot;category&quot; : &quot;gas&quot; }}&lt;br /&gt;{ &quot;$group&quot; : { &quot;_id&quot; : { &quot;category&quot; : &quot;$category&quot; }, &quot;amount&quot; : { &quot;$sum&quot; : &quot;$amount&quot; }}}&lt;br /&gt;&lt;b&gt;{ &quot;$match&quot; : { &quot;amount&quot; : { &quot;$lt&quot; : 20.00}}}&lt;/b&gt;&lt;br /&gt;null&lt;br /&gt;Failed:&lt;br /&gt;{ &quot;$match&quot; : { &quot;advice_id&quot; : 2 }}&lt;br /&gt;[&lt;br /&gt;&amp;nbsp; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;_id&quot;: &quot;53a70e8a792ac1bbba4b016f&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;advice_id&quot;: 2,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;desc&quot;: &quot;Are you looking for ways to make your dollar go further? ...&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;link&quot;: &quot;www.careonecredit.com/knowledge/ways-to-stretch-a-dollar.aspx&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;title&quot;: &quot;Ways To Stretch A Dollar&quot;&lt;br /&gt;&amp;nbsp; }&lt;br /&gt;] &lt;/div&gt;&lt;br /&gt;This time we changed the rule to test for the total spend on gasoline to be less than $20.00. This change resulted in a &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;null&lt;/span&gt; dataset so the code proceeded to execute the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Failed&lt;/span&gt; expressions. This time the advice is more generalized around saving money.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;br /&gt;MongoDB with the aggregation pipeline allows you to design programs that can make your data actionable. This small Go program provides one way you can declare and process rules against data in your MongoDB collections and adapt your users experience. Using Go to drive your rules engine gives you the added benefit of high performance and concurrent processing. Together, MongoDB and Go can help you build these robust systems faster, smarter and with a ton of flexibility.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/5031828978589342939/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/06/actionable-data-with-mongodb-and-go.html#comment-form' title='1 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/5031828978589342939'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/5031828978589342939'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/06/actionable-data-with-mongodb-and-go.html' title='Actionable Data With MongoDB and Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-699388346034030609</id><published>2014-06-20T13:10:00.001-04:00</published><updated>2014-06-21T09:17:47.278-04:00</updated><title type='text'>Pitfalls With Closures In Go</title><content type='html'>&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;br /&gt;Closures in Go are a very powerful construct but they can also be the cause of bugs if you don’t understand how they work. In this post I am going to pull a small piece of code from Chapter 2 from the &lt;a href=&quot;http://www.goinactionbook.com/&quot; target=&quot;_blank&quot;&gt;Go In Action&lt;/a&gt; book that discusses a pitfall you can run into when using closures. The full code example can be found in the &lt;a href=&quot;https://github.com/goinaction/code/tree/master/chapter2/sample&quot; target=&quot;_blank&quot;&gt;Github repository&lt;/a&gt; for the book. Chapter 2 discusses this code example in full detail.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;The Closure Pitfall&lt;/span&gt;&lt;br /&gt;First let’s look at the piece of code: &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;search/search.go&lt;br /&gt;&lt;br /&gt;29 &amp;nbsp;// Launch a goroutine for each feed to find the results.&lt;br /&gt;30 &amp;nbsp;for _, feed := range feeds {&lt;br /&gt;31 &amp;nbsp; &amp;nbsp; // Retrieve a matcher for the search.&lt;br /&gt;32 &amp;nbsp; &amp;nbsp; matcher, exists := matchers[feed.Type]&lt;br /&gt;33 &amp;nbsp; &amp;nbsp; if !exists {&lt;br /&gt;34 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;matcher = matchers[&quot;default&quot;]&lt;br /&gt;35 &amp;nbsp; &amp;nbsp; }&lt;br /&gt;36&lt;br /&gt;37 &amp;nbsp; &amp;nbsp; // Launch the goroutine to perform the search.&lt;br /&gt;38 &amp;nbsp; &amp;nbsp; go func(matcher Matcher, feed *Feed) {&lt;br /&gt;39 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Match(matcher, feed, searchTerm, results)&lt;br /&gt;40 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;waitGroup.Done()&lt;br /&gt;41 &amp;nbsp; &amp;nbsp; }(matcher, feed)&lt;br /&gt;42 &amp;nbsp;} &lt;/div&gt;&lt;br /&gt;This code sample starts out on line 30 iterating over a slice of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Feed&lt;/span&gt; values. The value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;feed&lt;/span&gt; variable declared within the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;for range&lt;/span&gt; loop is changing with each iteration. Then on line 32 the code is checking a map for a value that matches the specified key for the value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;feed.Type&lt;/span&gt; field. If the key does not exist, a default value for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;matcher&lt;/span&gt; variable is then assigned. Just like the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;feed&lt;/span&gt; variable, the value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;matcher&lt;/span&gt; variable also changes with each iteration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;for range&lt;/span&gt; loop.&lt;br /&gt;&lt;br /&gt;Now we can jump to lines 38 through 41 which still exist within the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;for range&lt;/span&gt; loop.  Here we are declaring an anonymous function and launching that function as a goroutine. The anonymous function is being declared to accept two parameters. The first parameter is a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Matcher&lt;/span&gt; and the second parameter is a pointer to a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Feed&lt;/span&gt;. On line 41 we can see the value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;matcher&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;feed&lt;/span&gt; variables being passed into the anonymous function.&lt;br /&gt;&lt;br /&gt;The implementation of the anonymous function on line 39 is where things get interesting. Here we see a call to a function named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Match&lt;/span&gt;. This function accepts four parameters and if you look closely at the function call, you will notice the first two parameters are the variables we declared as the function parameters. The last two parameters however were not declared within the scope of the anonymous function. Here we are seeing two variables being used by the anonymous function via closures.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;search/search.go&lt;br /&gt;&lt;br /&gt;37 &amp;nbsp; &amp;nbsp; // Launch the goroutine to perform the search.&lt;br /&gt;38 &amp;nbsp; &amp;nbsp; go func(matcher Matcher, feed *Feed) {&lt;br /&gt;39 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Match(matcher, feed, searchTerm, results)&lt;br /&gt;40 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;waitGroup.Done()&lt;br /&gt;41 &amp;nbsp; &amp;nbsp; }(matcher, feed)&lt;br /&gt;42 &amp;nbsp;} &lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;searchTerm&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;results&lt;/span&gt; variables are declared within the scope of the outer function yet we are able to use them within the scope of the anonymous function without the need to pass them in as parameters. A question this raises is why are we passing in the values of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;matcher&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;feed&lt;/span&gt; variables as parameters but using closures for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;searchTerm&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;results&lt;/span&gt; variables?&lt;br /&gt;&lt;br /&gt;I pointed out in the beginning how the values of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;matcher&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;feed&lt;/span&gt; variables were changing with every iteration of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;for range&lt;/span&gt; loop. The values of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;searchTerm&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;results&lt;/span&gt; variable are not changing with each iteration. Their values remain constant throughout the lifetime of each goroutine that is launched based on the declaration of the anonymous function. What does this have to do with anything?&lt;br /&gt;&lt;br /&gt;When we use a variable in an anonymous function via closures, we are not passing the value of the variable at the time the anonymous function is declared. We are sharing the actual variable which means changes to that variable’s value will be reflected within the scope of the anonymous function and in our case the running goroutine. If we were to share the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;matcher&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;feed&lt;/span&gt; variables via closures with the anonymous function and not pass the value of these variables into the function, most of the goroutines would be processing the very last value in the slice.&lt;br /&gt;&lt;br /&gt;In this program all of the goroutines will be running concurrently and not in parallel. By the time the first or even second goroutine is given time to run, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;for range&lt;/span&gt; loop will be complete and the value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;matcher&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;feed&lt;/span&gt; variables will contain values for the last iteration of the loop. This mean the majority if not all of the goroutines will be processing the same values for these variables. This is ok for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;searchTerm&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;results&lt;/span&gt; variables since they do not change.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;br /&gt;Luckily we can declare anonymous functions that accept parameters and these types of closure problems can be avoided. In our example above, when each anonymous function is declared within the scope of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;for range&lt;/span&gt; loop, the values of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;matcher&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;feed&lt;/span&gt; variables are locked in by passing them as parameters. The code remains clean and readable by leveraging closures for the remaining variables the anonymous function requires. Before using closures to share a variable with an anonymous function, ask yourself if the value of that variable will be changing and how that affects the function when it is called to run. &lt;br /&gt;&lt;br /&gt;To learn more details about this piece of code and the entire code sample, please take the time to download and read the Go In Action book. Chapter 2 is available for &lt;a href=&quot;http://www.manning.com/ketelsen/?a_aid=goinaction&quot; target=&quot;_blank&quot;&gt;download here&lt;/a&gt;.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/699388346034030609/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/06/pitfalls-with-closures-in-go.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/699388346034030609'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/699388346034030609'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/06/pitfalls-with-closures-in-go.html' title='Pitfalls With Closures In Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-183613223728302854</id><published>2014-05-03T19:50:00.000-04:00</published><updated>2014-09-07T14:53:31.961-04:00</updated><title type='text'>Methods, Interfaces and Embedded Types in Go</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;My business partner Ed asked me what would happen if a struct and an embedded field both implemented the same interface. We asked ourselves two questions:&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;Would the compiler throw an error because we now had two implementations of the interface?&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;If the compiler accepted the type declaration, how does the compiler determine which implementation to use for interface calls?&lt;/li&gt;&lt;/ul&gt;We hacked out some code to answer the questions and then I dug into the specification. What we found was really interesting and we believed worth sharing with others who are also learning the language. Once we learned the mechanics behind methods, interfaces, and embedded types, the answers seemed obvious. To get started, let’s talk about what methods are in Go.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Methods&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Go has both functions and methods. In Go, a method is a function that is declared with a &lt;a href=&quot;http://golang.org/ref/spec#Method_declarations&quot; target=&quot;_blank&quot;&gt;receiver&lt;/a&gt;. A receiver is a value or a pointer of a &lt;a href=&quot;http://golang.org/ref/spec#Types&quot; target=&quot;_blank&quot;&gt;named&lt;/a&gt; or &lt;a href=&quot;http://golang.org/ref/spec#Struct_types&quot; target=&quot;_blank&quot;&gt;struct&lt;/a&gt; type. All the methods for a given type belong to the type’s method set.&lt;br /&gt;&lt;br /&gt;Let’s declare a struct type and a method for that type:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type User struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; Name string&lt;br /&gt;&amp;nbsp; &amp;nbsp; Email string&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;func (u User) Notify() error&lt;/div&gt;&lt;br /&gt;First we declare a struct type named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt; and then we declare a method named &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; with a receiver that accepts a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt;. To call the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; method we need a value or pointer of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Value of type User can be used to call the method&lt;br /&gt;// with a value receiver.&lt;br /&gt;bill := User{“Bill”, “bill@email.com”}&lt;br /&gt;bill.Notify()&lt;br /&gt;&lt;br /&gt;// Pointer of type User can also be used to call a method&lt;br /&gt;// with a value receiver.&lt;br /&gt;jill := &amp;amp;User{“Jill”, “jill@email.com”}&lt;br /&gt;jill.Notify()&lt;/div&gt;&lt;br /&gt;In the case where we are using a pointer, Go &lt;a href=&quot;http://golang.org/ref/spec#Calls&quot; target=&quot;_blank&quot;&gt;adjusts&lt;/a&gt; and dereferences the pointer so the call can be made. Be aware that when the receiver is not a pointer, the method is operating against a copy of the receiver value.&lt;br /&gt;&lt;br /&gt;We can change the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; method to use a pointer for the receiver:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func (u *User) Notify() error&lt;/div&gt;&lt;br /&gt;Once again, we can call the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; method like we did before:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Value of type User can be used to call the method&lt;br /&gt;// with a pointer receiver. &lt;br /&gt;bill := User{“Bill”, “bill@email.com”}&lt;br /&gt;bill.Notify()&lt;br /&gt;&lt;br /&gt;// Pointer of type User can be used to call the method&lt;br /&gt;// with a pointer receiver.&lt;br /&gt;jill := &amp;amp;User{“Jill”, “jill@email.com”}&lt;br /&gt;jill.Notify()&lt;/div&gt;&lt;br /&gt;If you are unsure about when to use a value or a pointer for the receiver, the Go wiki has a great set of &lt;a href=&quot;https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Receiver_Type&quot; target=&quot;_blank&quot;&gt;rules&lt;/a&gt; that you can follow. The Go wiki also contains a paragraph about the conventions the community follows for &lt;a href=&quot;https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Receiver_Names&quot; target=&quot;_blank&quot;&gt;naming&lt;/a&gt; receivers.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Interfaces&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;a href=&quot;http://golang.org/doc/effective_go.html#interfaces&quot; target=&quot;_blank&quot;&gt;Interfaces&lt;/a&gt; in Go are special and provide an incredible amount of flexibility and abstraction for our programs. They are a way of specifying that values and pointers of a particular type can behave in a specific way. From a language perspective, an interface is a type that specifies a &lt;a href=&quot;http://golang.org/ref/spec#Method_sets&quot; target=&quot;_blank&quot;&gt;method set&lt;/a&gt; and all the methods for an &lt;a href=&quot;http://golang.org/ref/spec#Interface_types&quot; target=&quot;_blank&quot;&gt;interface type&lt;/a&gt; are considered to be the interface.&lt;br /&gt;&lt;br /&gt;Let’s declare an interface in Go:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type Notifier interface {&lt;br /&gt;&amp;nbsp; &amp;nbsp; Notify() error&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;Here we declare an interface called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notifier&lt;/span&gt; with a single method called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt;. It is a &lt;a href=&quot;http://golang.org/doc/effective_go.html#interface-names&quot; target=&quot;_blank&quot;&gt;convention&lt;/a&gt; in Go to name interfaces with an &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;-er&lt;/span&gt; suffix when the interface contains only one method. This is not a hard rule but something we should honor, especially when the interface and method name have the same signature and meaning.&lt;br /&gt;&lt;br /&gt;We can specify as many methods as we want for our interfaces. In the standard library you will be hard pressed to find many interfaces with more than two methods. &lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Implementing Interfaces&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Go is unique when it comes to how we implement the interfaces we want our types to support. Go does not require us to explicitly state that our types implement an interface. If every method that belongs to an interface’s method set is implemented by our type, then our type is said to implement the interface.&lt;br /&gt;&lt;br /&gt;Let’s continue with our example by creating a function that accepts any value or pointer of a type that implements the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notifier&lt;/span&gt; interface:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func SendNotification(notify Notifier) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; return notify.Notify()&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;SendNotification&lt;/span&gt; function calls the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; method that is implemented by the value or pointer that is passed into the function. This function can be used to execute the specific behavior for any value or pointer of a given type that implements the interface.&lt;br /&gt;&lt;br /&gt;Let’s implement the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; method for our &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt; type and call the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;SendNotification&lt;/span&gt; function passing a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func (u *User) Notify() error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; log.Printf(&quot;User: Sending User Email To %s&amp;lt;%s&amp;gt;\n&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; u.Name,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; u.Email)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; return nil&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;func main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; user := User{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Name: &amp;nbsp;&quot;janet jones&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Email: &quot;janet@email.com&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; SendNotification(user)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// Output:&lt;br /&gt;cannot use user (type User) as type Notifier in function argument: &lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; User does not implement Notifier (Notify method has pointer receiver)&lt;/div&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/VieiPRDGVu&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/VieiPRDGVu&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Why does the compiler not consider our value to be of a type that implements the interface? The rules for determining interface compliance are based on the receiver for those methods and how the interface call is being made. Here are the rules in the spec for how the compiler determines if the value or pointer for our type &lt;a href=&quot;http://golang.org/ref/spec#Method_sets&quot; target=&quot;_blank&quot;&gt;implements&lt;/a&gt; the interface:&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;&lt;i&gt;The method set of the corresponding pointer type *T is the set of all methods with receiver *T or T&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;This rule is stating that if the interface variable we are using to call a particular interface method contains a pointer, then methods with receivers based on both values and pointers will satisfy the interface. This rule does not apply for our example because we are passing a value to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;SendNotification&lt;/span&gt; function.&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;&lt;i&gt;The method set of any other type T consists of all methods with receiver type T.&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;This rule is stating that if the interface variable we are using to call a particular interface method contains a value, then only methods with receivers based on values will satisfy the interface. This rule does not apply for our example because the receiver for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; method accepts a pointer.&lt;br /&gt;&lt;br /&gt;Since those are the only two rules in the spec for interface compliance, I have derived this rule that applies to our example:&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;&lt;i&gt;The method set of the corresponding type T &lt;u&gt;&lt;b&gt;does not&lt;/b&gt;&lt;/u&gt; consists of any methods with receiver type *T.&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;This is our case and why we are receiving the compiler error. The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; method is using a pointer for the receiver and we are using a value to make the interface method call. To fix this we just need to pass the address of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt; value to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;SendNotification&lt;/span&gt; function:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; user := &amp;amp;User{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Name: &amp;nbsp;&quot;janet jones&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Email: &quot;janet@email.com&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; SendNotification(user)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// Output:&lt;br /&gt;User: Sending User Email To janet jones&amp;lt;janet@email.com&amp;gt;&lt;/div&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/3NNiS4dMrK&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/3NNiS4dMrK&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Embedded Types&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;a href=&quot;http://golang.org/ref/spec#Struct_types&quot; target=&quot;_blank&quot;&gt;Struct types&lt;/a&gt; have the ability to contain anonymous or embedded fields. This is also called embedding a type. When we embed a type into a struct, the name of the type acts as the field name for what is then an embedded field.&lt;br /&gt;&lt;br /&gt;Let’s declare a new type and embed our &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt; type into it:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type Admin struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; User&lt;br /&gt;&amp;nbsp; &amp;nbsp; Level string&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;We have declared a new type called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; and embedded the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt; type within the struct declaration. This is not inheritance but composition. There is no relationship between the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt; and the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type.&lt;br /&gt;&lt;br /&gt;Let’s change &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt; to create a value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type and pass the address of this value to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;SendNotification&lt;/span&gt; function:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; admin := &amp;amp;Admin{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; User: User{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Name: &amp;nbsp;&quot;john smith&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Email: &quot;john@email.com&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Level: &quot;super&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; SendNotification(admin)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// Output&lt;br /&gt;User: Sending User Email To john smith&amp;lt;john@email.com&amp;gt;&lt;/div&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/2jZMCGEfxW&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/2jZMCGEfxW&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Sure enough, we are able to call the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;SendNotification&lt;/span&gt; function with a pointer of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt;. Thanks to composition, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type now implements the interface through the promotion of the methods from the embedded &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt; type.&lt;br /&gt;&lt;br /&gt;If the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type now contains the fields and methods of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt; type, then where are they in relationship to the struct? &lt;br /&gt;&lt;br /&gt;&lt;i&gt;“When we &lt;a href=&quot;http://golang.org/doc/effective_go.html#embedding&quot; target=&quot;_blank&quot;&gt;embed&lt;/a&gt; a type, the methods of that type become methods of the outer type, but when they are invoked, the receiver of the method is the inner type, not the outer one.” - Effective Go&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;Since the name of the embedded type acts as the field name and the embedded type exists as an inner type, we can then make the following method call:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;admin.User.Notify()&lt;br /&gt;&lt;br /&gt;// Output&lt;br /&gt;User: Sending User Email To john smith&amp;lt;john@email.com&amp;gt;&lt;/div&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/_huNeKVmXS&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/_huNeKVmXS&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Here we are accessing the field and method set of the inner type through the use of the type’s name. However, these fields and methods are also promoted to the outer type:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;admin.Notify()&lt;br /&gt;&lt;br /&gt;// Output&lt;br /&gt;User: Sending User Email To john smith&amp;lt;john@email.com&amp;gt;&lt;/div&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/v4ro-KHiKJ&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/v4ro-KHiKJ&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;So calling the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; method using the outer type, calls the implementation of the inner type’s method.&lt;br /&gt;&lt;br /&gt;These are the rules for inner type &lt;a href=&quot;http://golang.org/ref/spec#Method_sets&quot; target=&quot;_blank&quot;&gt;method set promotion&lt;/a&gt; in Go:&lt;br /&gt;&lt;br /&gt;&lt;i&gt;Given a struct type S and a type named T, promoted methods are included in the method set of the struct as follows:&lt;/i&gt;&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;&lt;i&gt;If S contains an anonymous field T, the method sets of S and *S both include promoted methods with receiver T.&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;This rule is stating that when we embed a type, methods for the embedded type with receivers that use a value are promoted and available for calling by values and pointers of the outer type.&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;&lt;i&gt;The method set of *S also includes promoted methods with receiver *T.&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;This rule is stating that when we embed a type, methods for the embedded type with receivers that use a pointer are promoted and available for calling by pointers of the outer type.&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;&lt;i&gt;If S contains an anonymous field *T, the method sets of S and *S both include promoted methods with receiver T or *T.&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;This rule is stating that when we embed a pointer of the type, methods for the embedded type with receivers that use both values and pointers are promoted and available for calling by values and pointers of the outer type.&lt;br /&gt;&lt;br /&gt;Since those are the only three rules in the spec for method promotion, I have derived this rule for one other case:&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;&lt;i&gt;If S contains an anonymous field T, the method set of S &lt;u&gt;&lt;b&gt;does not&lt;/b&gt;&lt;/u&gt; include promoted methods with receiver *T.&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;This rule is stating that when we embed a type, methods for the embedded type with receivers that use a pointer are not promoted for calling by values of the outer type. This is consistent with the rules for interface compliance that we stated above.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Answering The Questions&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Now we can finalize the sample program that will provide the answers for the two questions we asked in the beginning of the post. Let’s implement the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notifier&lt;/span&gt; interface for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func (a *Admin) Notify() error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; log.Printf(&quot;Admin: Sending Admin Email To %s&amp;lt;%s&amp;gt;\n&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; a.Name,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; a.Email)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; return nil&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;The implementation of the interface by the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type displays a message on behalf of an admin. This will help us determine which implementation gets called when we use a pointer of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type to make the function call to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;SendNotification&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;Now let’s create a value of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type and pass the address of that value to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;SendNotification&lt;/span&gt; function and see what happens:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; admin := &amp;amp;Admin{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; User: User{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Name: &amp;nbsp;&quot;john smith&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Email: &quot;john@email.com&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Level: &quot;super&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; SendNotification(admin)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// Output&lt;br /&gt;Admin: Sending Admin Email To john smith&amp;lt;john@email.com&amp;gt;&lt;/div&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/NkDioPJs04&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/NkDioPJs04&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;As expected, the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type’s implementation of the interface is called by the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;SendNotification&lt;/span&gt; function. So now what happens when we call the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Notify&lt;/span&gt; method using the outer type:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;admin.Notify() &lt;br /&gt;&lt;br /&gt;// Output&lt;br /&gt;Admin: Sending Admin Email To john smith&amp;lt;john@email.com&amp;gt;&lt;/div&gt;&lt;br /&gt;&lt;a href=&quot;http://play.golang.org/p/RG50rxC0d7&quot; target=&quot;_blank&quot;&gt;http://play.golang.org/p/RG50rxC0d7&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;We get the output for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Admin&lt;/span&gt; type’s implementation. The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;User&lt;/span&gt; type’s implementation is no longer promoted to the outer type:&lt;br /&gt;&lt;br /&gt;So now we have the knowledge we need to answer the questions:&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;Would the compiler throw an error because we now had two implementations of the interface?&lt;/li&gt;&lt;/ul&gt;No, because when we use an embedded type, the unqualified type’s name acts as the field name. This has the effect of fields and methods of the embedded type having a unique name as an inner type of the struct. So we can have an inner and outer implementation of the same interface with each implementation being unique and accessible.&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;If the compiler accepted the type declaration, how does the compiler determine which implementation to use for interface calls?&lt;/li&gt;&lt;/ul&gt;If the outer type contains an implementation that satisfies the interface, it will be used. Otherwise, thanks to method promotion, any inner type that implements the interface can be used through the outer type.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The way methods, interfaces, and embedded types work together is something that makes Go very unique. These features help us create powerful constructs to achieve the same ends as object oriented code without all the complexity. With the language features that we talked about in this post, we can build abstracted and scalable frameworks with a minimal amount of code and confusion.&lt;br /&gt;&lt;div&gt;&lt;br /&gt;The more I learn about the details of the language and the compiler, the more I come to appreciate how &lt;a href=&quot;http://en.wikipedia.org/wiki/Orthogonality_(programming)&quot; target=&quot;_blank&quot;&gt;orthogonal&lt;/a&gt; the language is. Small features that work together and allow us to be creative and use the language in ways not even the language designers thought or dreamed about. I recommend to take the time to learn the language features so you can do more with less and be both creative and productive at the same time.&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/183613223728302854/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/05/methods-interfaces-and-embedded-types.html#comment-form' title='8 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/183613223728302854'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/183613223728302854'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/05/methods-interfaces-and-embedded-types.html' title='Methods, Interfaces and Embedded Types in Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>8</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-8829517233269698363</id><published>2014-04-06T08:33:00.000-04:00</published><updated>2014-04-10T10:25:56.417-04:00</updated><title type='text'>Introduction To Numeric Constants In Go</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;One of the more unique features of Go is how the language implements constants. The rules for &lt;a href=&quot;http://golang.org/ref/spec#Constants&quot; target=&quot;_blank&quot;&gt;constants&lt;/a&gt; in the language specification are unique to Go. They provide the flexibility Go needs at the compiler level to make the code we write readable and intuitive while still maintaining a type safe language.&lt;br /&gt;&lt;br /&gt;This post will attempt to build a foundation for what numeric constants are, how they behave in their simplest form and how best to talk about them. There are a lot of little nuances, terms and concepts that can trip us up. Because of this, the post is going to take things slowly.&lt;br /&gt;&lt;br /&gt;So if you are ready to peek under the covers just a bit, roll up your sleeve and let’s get started: &lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Untyped and Typed Numeric Constants&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Constants can be declared with or without a type in Go. When we declare literal values in our code, we are actually declaring constants that are both untyped and unnamed.&lt;br /&gt;&lt;br /&gt;The following examples show typed and untyped numeric constants that are both named and unnamed:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;const&lt;/b&gt; untypedInteger &amp;nbsp; &amp;nbsp; &amp;nbsp; = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;12345&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; untypedFloatingPoint = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;3.141592&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; typedInteger       &lt;b&gt;&lt;span style=&quot;color: #0b5394;&quot;&gt;int&lt;/span&gt;&lt;/b&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;12345&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; typedFloatingPoint &lt;b&gt;&lt;span style=&quot;color: #0b5394;&quot;&gt;float64&lt;/span&gt;&lt;/b&gt; = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;3.141592&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;The constants on the left hand side of the declaration are named constants and the literal values on the right hand side are unnamed constants.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Kinds of Numeric Constants&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Your first instinct may be to think that typed constants use the same type system as variables, but they don’t. Constants have their own implementation for representing the values that we associate with them. Every Go &lt;a href=&quot;http://golang.org/cmd/&quot; target=&quot;_blank&quot;&gt;compiler&lt;/a&gt; has the flexibility to implement constants as they wish, within a set of mandatory &lt;a href=&quot;http://golang.org/ref/spec#Constants&quot; target=&quot;_blank&quot;&gt;requirements&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;When declaring a typed constant, the declared type is used to associate the type’s precision limitations. It does not change how the value is being internally represented. Because the internal representation of constants can be different between the different compilers, it is best to think of constants as having a &lt;i&gt;&lt;b&gt;kind&lt;/b&gt;&lt;/i&gt;, not a type.&lt;br /&gt;&lt;br /&gt;Numeric constants can be one of four kinds:  integer, floating-point, complex and rune:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;12345&lt;/b&gt;&lt;/span&gt; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;color: #783f04;&quot;&gt;// kind: integer&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;3.141592&lt;/b&gt;&lt;/span&gt;      &lt;span style=&quot;color: #783f04;&quot;&gt;// kind: floating-point&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;1E6 &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #783f04;&quot;&gt;// kind: floating-point&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;In the example above, we have declared three numeric constants, one of kind integer and two of kind floating-point. The form of the literal value will determine what kind the constant takes. When the form of the literal value contains a decimal or exponent, the constant is of kind floating-point. When the form does not contain a decimal or exponent, the constant is of kind integer.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Constants Are Mathematically Exact&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Regardless of the implementation, constants are always considered to be mathematically exact. This is something that makes constants in Go unique. This is not the case in other languages like C and C++.&lt;br /&gt;&lt;br /&gt;Integers can always be represented precisely when there is enough memory to store their entire value. Since the specification requires integer constants to have at least 256 bits of precision, we are safe in saying integer constants are mathematically exact.&lt;br /&gt;&lt;br /&gt;To have mathematically exact floating-point numbers, there are different strategies and options that the compiler can employ. The specification does not state how the compiler must do this, it just specifies a set of mandatory requirements that need to be met.&lt;br /&gt;&lt;br /&gt;Here are two strategies that the different Go compilers use today to implement mathematically exact floating-point numbers:&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;One strategy is to represent all floating-point numbers as fractions, and use rational arithmetic on those fractions. This is what go/types does today and these floating-point numbers never have any loss of precision.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;Another strategy is to use floating-point numbers with so much precision that they appear to be exact for all practical purposes. When we use floating-point numbers with several hundred bits, the difference between exact and approximate becomes virtually non-existent. This is what the gc/gccgo compilers do today.&lt;/li&gt;&lt;/ul&gt;As developers however, it is best to not consider what internal representation is being used by the compiler, it is irrelevant. Just remember that all constants, regardless if they are declared with or without a type, use the same representation to store their values, which is not the same as variables and is mathematically exact.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Mathematically Exact Example&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Since constants only exist during compilation, it is hard to provide an example that shows constants are mathematically exact. One way is to show how the compiler will let us declare constants of kind integer with values that are much larger than the largest integer types can support.&lt;br /&gt;&lt;br /&gt;Here is a program that can be compiled because constants of kind integer are mathematically exact:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;package&lt;/b&gt; main&lt;br /&gt;&lt;br /&gt;&lt;b&gt;import&lt;/b&gt; &lt;span style=&quot;color: #990000;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;color: #783f04;&quot;&gt;// Much larger value than int64.&lt;/span&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; myConst = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;9223372036854775808543522345&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;func&lt;/b&gt; main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&lt;span style=&quot;color: #990000;&quot;&gt;&quot;Will Compile&quot;&lt;/span&gt;)&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;If we change the constant to be of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;int64&lt;/span&gt;, which means the constant is now bound to the precision limitations of a 64 bit integer, the program will no longer compile:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;package&lt;/b&gt; main&lt;br /&gt;&lt;br /&gt;&lt;b&gt;import&lt;/b&gt; &lt;span style=&quot;color: #990000;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;color: #783f04;&quot;&gt;// Much larger value than int64.&lt;/span&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; myConst &lt;b&gt;&lt;span style=&quot;color: #0b5394;&quot;&gt;int64&lt;/span&gt;&lt;/b&gt; = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;9223372036854775808543522345&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;func&lt;/b&gt; main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&lt;span style=&quot;color: #990000;&quot;&gt;&quot;Will NOT Compile&quot;&lt;/span&gt;)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;color: #660000;&quot;&gt;&lt;b&gt;Compiler Error:&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #660000;&quot;&gt;./ideal.go:6: constant 9223372036854775808543522345 overflows int64 &lt;/span&gt;&lt;/div&gt;&lt;br /&gt;Here we can see that constants of kind integer can represent very large numbers and why we say they are mathematically exact.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Numeric Constant Declarations&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;When we declare an untyped numeric constant, there are no type constraints that must be met by the constant value:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;const&lt;/b&gt; untypedInteger &amp;nbsp; &amp;nbsp; &amp;nbsp; = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;12345&lt;/b&gt;&lt;/span&gt; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;color: #783f04;&quot;&gt;// kind: integer&lt;/span&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; untypedFloatingPoint = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;3.141592&lt;/b&gt;&lt;/span&gt; &lt;span style=&quot;color: #783f04;&quot;&gt;// kind: floating-point &lt;/span&gt;&lt;/div&gt;&lt;br /&gt;In each case, the untyped constant on the left hand side of the declaration is given the same kind and value as the constant on the right.&lt;br /&gt;&lt;br /&gt;When we declare a typed constant, the constant on the right hand side of the declaration must use a form that is compatible with the declared type on the left:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;const&lt;/b&gt; typedInteger       &lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;int&lt;/span&gt;&lt;/b&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;12345&lt;/span&gt;&lt;/b&gt; &amp;nbsp; &amp;nbsp;// kind: integer&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; typedFloatingPoint &lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;float64&lt;/span&gt;&lt;/b&gt; = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;3.141592&lt;/b&gt;&lt;/span&gt; // kind: floating-point &lt;/div&gt;&lt;br /&gt;The value on the right hand side of the declaration must also fit into the range for the declared type. For instance, this numeric constant declaration is invalid:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;const&lt;/b&gt; myUint8&amp;nbsp;&lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;uint8&lt;/span&gt;&lt;/b&gt; = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;1000 &lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;uint8&lt;/span&gt; only can represent numbers from 0 to 255. This is what I mean when I said earlier that the declared type is used to associate the type’s precision limitations.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Implicit Integer Type Conversions&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;In Go there are no implicit type &lt;a href=&quot;http://golang.org/ref/spec#Conversions&quot; target=&quot;_blank&quot;&gt;conversions&lt;/a&gt; between variables. However, implicit type conversions between variables and constants can happen regularly by the compiler.&lt;br /&gt;&lt;br /&gt;Let’s start with an implicit integer conversion:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;var&lt;/b&gt; myInt &lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;int&lt;/span&gt;&lt;/b&gt; = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;123 &lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;In this example we have constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;123&lt;/span&gt; of kind integer being implicitly converted to a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;int&lt;/span&gt;. Since the form of the constant is not using a decimal point or exponent, the constant takes the kind integer. Constants of kind integer can be implicitly converted into signed and unsigned integer variables of any length as long as no truncation needs to take place.&lt;br /&gt;&lt;br /&gt;Constants of kind floating-point can also be implicitly converted into integer variables if the constant uses a form that is compatible with the integer type:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;var&lt;/b&gt; myInt &lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;int&lt;/span&gt;&lt;/b&gt; = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;123.0 &lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;br /&gt;We can also perform implicit type conversion assignments without declaring an explicit type for the variable:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;var&lt;/b&gt; myInt = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;123 &lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;In this case, the default type of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;int64&lt;/span&gt; is used to initialize the variable being assigned with constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;123&lt;/span&gt; of kind integer.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Implicit Floating-Point Type Conversions&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Next let’s look at an implicit floating-point conversion:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;var&lt;/b&gt; myFloat &lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;float64&lt;/span&gt;&lt;/b&gt; = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;0.333 &lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;br /&gt;This time the compiler is performing an implicit conversion between constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;0.333&lt;/span&gt; of kind floating-point to a variable of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;float64&lt;/span&gt;. Since the form of the constant is using a decimal point, the constant takes the kind floating-point. The default type for a variable initialized with a constant of kind floating-point is &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;float64&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;The compiler can also perform implicit conversions between constants of kind integer to variables of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;float64&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;var&lt;/b&gt; myFloat &lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;float64&lt;/span&gt;&lt;/b&gt; = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;1 &lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;br /&gt;In this example, constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;1&lt;/span&gt; of kind integer is implicitly converted to a variable of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;float64&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Kind Promotion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Performing constant arithmetic between other constants and variables is something we do quite often in our programs. It follows the rules for &lt;a href=&quot;http://golang.org/ref/spec#Operators&quot; target=&quot;_blank&quot;&gt;binary operators&lt;/a&gt; in the specification. The rule states that operand types must be identical unless the operation involves shifts or untyped constants.&lt;br /&gt;&lt;br /&gt;Let’s look at an example of two constants that are multiplied together:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;var&lt;/b&gt; answer = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;3&lt;/b&gt;&lt;/span&gt; &lt;b&gt;*&lt;/b&gt; &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;0.333 &lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;In this example we perform multiplication between constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;3&lt;/span&gt; of kind integer and constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;0.333&lt;/span&gt; of kind floating-point.&lt;br /&gt;&lt;br /&gt;There is a rule in the specification about constant expressions that is specific to this operation:&lt;br /&gt;&lt;br /&gt;&lt;i&gt;&quot;Except for shift operation, if the operands of a binary operation are &lt;u&gt;different kinds of untyped constants&lt;/u&gt;, ..., the result &lt;u&gt;use the kind that appears later in this list&lt;/u&gt;: integer, rune, floating-point, complex.&quot;&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;Based on this rule, the result of the multiplication between these two constants will be a constant of kind floating-point. Kind floating-point is being promoted ahead of kind integer based on the rule.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Numeric Constant Arithmetic&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Let’s continue with our multiplication example:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;var&lt;/b&gt; answer = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;3&lt;/span&gt;&lt;/b&gt; &lt;b&gt;*&lt;/b&gt; &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;0.333 &lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;br /&gt;The result of the multiplication will be a new constant of kind floating-point. That constant is then assigned to the variable &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;answer&lt;/span&gt; through an implicit type conversion from kind floating-point to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;float64&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;When we divide numeric constants, the kind of the constants determine how the division is performed.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;const&lt;/b&gt; third = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;1&lt;/span&gt;&lt;/b&gt; &lt;b&gt;/&lt;/b&gt; &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;3.0 &lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;br /&gt;When one of the two constants are of kind floating-point, the result of the division will also be a constant of kind floating-point. In our example we have used a decimal point to represent the constant in the denominator. This follows the rules for kind promotion that we talked about before.&lt;br /&gt;&lt;br /&gt;Let’s take the same example but use kind integer in the denominator:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;const&lt;/b&gt; zero = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;1&lt;/span&gt;&lt;/b&gt; &lt;b&gt;/&lt;/b&gt; &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;3 &lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;br /&gt;This time we are performing division between two constants of kind integer. The result of the division will be a new constant of type integer. Since dividing 3 into the value of 1 represents a number that is less than 1, the result of this division is constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;0&lt;/span&gt; of kind integer.&lt;br /&gt;&lt;br /&gt;Let’s create a typed constant using numeric constant arithmetic:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;type&lt;/b&gt; Numbers &lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;int8&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; One Numbers = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;1&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; Two &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;2&lt;/b&gt;&lt;/span&gt; &lt;b&gt;*&lt;/b&gt; One&lt;/div&gt;&lt;br /&gt;Here we declare a new type called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Numbers&lt;/span&gt; with a base type of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;int8&lt;/span&gt;. Then we declare constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;One&lt;/span&gt; with type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Numbers&lt;/span&gt; and assign constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;1&lt;/span&gt; of kind integer. Next we declare constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Two&lt;/span&gt; which is promoted to type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Numbers&lt;/span&gt; through the multiplication of constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;2&lt;/span&gt; of kind integer and constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;One&lt;/span&gt; of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Numbers&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;The declaration of constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Two&lt;/span&gt; shows an example of a constant getting promoted not just to a user-defined type, but a user-defined type associated with a base type.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;One Practical Example&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Let’s look at one practical example right from the standard library. The time package declares this type and set of constants:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;type&lt;/b&gt; Duration &lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;int64&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; (&lt;br /&gt;&amp;nbsp; &amp;nbsp; Nanosecond  Duration = &lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;1&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; Microsecond &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;1000&lt;/span&gt;&lt;/b&gt; &lt;b&gt;*&lt;/b&gt; Nanosecond&lt;br /&gt;&amp;nbsp; &amp;nbsp; Millisecond &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;1000&lt;/span&gt;&lt;/b&gt; &lt;b&gt;*&lt;/b&gt; Microsecond&lt;br /&gt;&amp;nbsp; &amp;nbsp; Second &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;= &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;1000&lt;/span&gt;&lt;/b&gt; &lt;b&gt;*&lt;/b&gt; Millisecond&lt;br /&gt;)&lt;/div&gt;&lt;br /&gt;All of the constants declared above are constants of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Duration&lt;/span&gt; which have a base type of &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;int64&lt;/span&gt;. Here we are declaring typed constants using constant arithmetic between constants that are typed and untyped.&lt;br /&gt;&lt;br /&gt;Since the compiler will perform implicit conversions for constants, we can write code in Go like this:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;package&lt;/b&gt; main&lt;br /&gt;&lt;br /&gt;&lt;b&gt;import&lt;/b&gt; (&lt;br /&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;color: #990000;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;color: #990000;&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;&lt;b&gt;const&lt;/b&gt; fiveSeconds = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;5&lt;/span&gt;&lt;/b&gt; &lt;b&gt;*&lt;/b&gt; time.Second&lt;br /&gt;&lt;br /&gt;&lt;b&gt;func&lt;/b&gt; main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;now := time.Now()&lt;br /&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;lessFiveNanoseconds := now.Add(&lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;-5&lt;/span&gt;&lt;/b&gt;)&lt;br /&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;lessFiveSeconds := now.Add(-fiveSeconds)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;fmt.Printf(&lt;span style=&quot;color: #990000;&quot;&gt;&quot;Now &amp;nbsp; &amp;nbsp; : %v\n&quot;&lt;/span&gt;, now)&lt;br /&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;fmt.Printf(&lt;span style=&quot;color: #990000;&quot;&gt;&quot;Nano &amp;nbsp; &amp;nbsp;: %v\n&quot;&lt;/span&gt;, lessFiveNanoseconds)&lt;br /&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;fmt.Printf(&lt;span style=&quot;color: #990000;&quot;&gt;&quot;Seconds : %v\n&quot;&lt;/span&gt;, lessFiveSeconds)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;color: #4c1130;&quot;&gt;&lt;b&gt;Output:&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #4c1130;&quot;&gt;Now &amp;nbsp; &amp;nbsp; : 2014-03-27 13:30:49.111038384 -0400 EDT&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #4c1130;&quot;&gt;Nano &amp;nbsp; &amp;nbsp;: 2014-03-27 13:30:49.111038379 -0400 EDT&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #4c1130;&quot;&gt;Seconds : 2014-03-27 13:30:44.111038384 -0400 EDT&lt;/span&gt;&lt;/div&gt;&lt;br /&gt;The power of constants are exhibited with the method calls to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Add&lt;/span&gt;. Let’s look at the definition of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Add&lt;/span&gt; method for the receiver type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;func&lt;/b&gt; (t Time) Add(d Duration) Time &lt;/div&gt;&lt;br /&gt;The &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Add&lt;/span&gt; method accepts a single parameter of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Duration&lt;/span&gt;. Let’s look closer at the method calls to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Add&lt;/span&gt; from our program:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;var&lt;/b&gt; lessFiveNanoseconds = now.Add(&lt;span style=&quot;color: #38761d;&quot;&gt;&lt;b&gt;-5&lt;/b&gt;&lt;/span&gt;)&lt;br /&gt;&lt;b&gt;var&lt;/b&gt; lessFiveMinutes = now.Add(-fiveSeconds) &lt;/div&gt;&lt;br /&gt;The compiler is implicitly converting constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;-5&lt;/span&gt; into a variable of type&amp;nbsp;&lt;span style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;Duration&lt;/span&gt;&amp;nbsp;to allow the method call to&amp;nbsp;happen. Constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;fiveSeconds&lt;/span&gt; is already of type&amp;nbsp;&lt;span style=&quot;font-family: &#39;Courier New&#39;, Courier, monospace;&quot;&gt;Duration&lt;/span&gt;&amp;nbsp;thanks to the rules for constant&amp;nbsp;arithmetic:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;const&lt;/b&gt; fiveSeconds = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;5&lt;/span&gt;&lt;/b&gt; &lt;b&gt;*&lt;/b&gt; time.Second &lt;/div&gt;&lt;br /&gt;The multiplication between constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;5&lt;/span&gt; and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;time.Second&lt;/span&gt; results in constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;fiveSeconds&lt;/span&gt; becoming a constant of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Duration&lt;/span&gt;. This is because constant &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;time.Second&lt;/span&gt; is of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Duration&lt;/span&gt; and this type is promoted when determining the type of the result. To support the function call, the constant still needs to be implicitly converted from a constant of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Duration&lt;/span&gt; to a variable of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Duration&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;If constants didn&#39;t behave the way they do, these kind of assignments and function calls would always require explicit conversions. Look at what happens when we try to use a value of type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;int&lt;/span&gt; to make the same method call:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;&lt;b&gt;var&lt;/b&gt; difference &lt;b&gt;&lt;span style=&quot;color: #134f5c;&quot;&gt;int&lt;/span&gt;&lt;/b&gt; = &lt;b&gt;&lt;span style=&quot;color: #38761d;&quot;&gt;-5&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;b&gt;var&lt;/b&gt; lessFiveNano = now.Add(difference)&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;color: #990000;&quot;&gt;&lt;b&gt;Compiler Error:&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;color: #990000;&quot;&gt;./const.go:16: cannot use difference (type int) as type time.Duration in functi&lt;/span&gt;on argument &lt;/div&gt;&lt;br /&gt;Once we use a typed integer value as the parameter for the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Add&lt;/span&gt; method call, we received a compiler error. The compiler will not allow implicit type conversions between typed variables. For that code to compile we would need to perform an explicit type conversion:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Add(time.Duration(difference)) &lt;/div&gt;&lt;br /&gt;Constants are the only mechanism we have to write code without the need to use explicit type conversions.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;We take the behavior of constants for granted, which is a testament to the language designers and those who have worked hard on this feature. A lot of work and care has gone into making constants work this way and the benefits are hopefully clear.&lt;br /&gt;&lt;br /&gt;So the next time you are working with a constant, remember you are working with something that is unique. A hidden gem buried in the compiler that doesn’t get enough credit or recognition as a unique feature of Go. Constants help make coding in Go fun and the code we write readable and intuitive. While at the same time keeping the code we write type safe.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Thanks&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Thanks to&amp;nbsp;&lt;a href=&quot;http://blog.natefinch.com/&quot; target=&quot;_blank&quot;&gt;Nate Finch&lt;/a&gt; and &lt;a href=&quot;http://www.westryn.net/resumes/kim.html&quot; target=&quot;_blank&quot;&gt;Kim Shrier&lt;/a&gt;&amp;nbsp;who have provided several reviews of the post that have helped to make sure the content and examples were accurate, flowed well and would be interesting to Go developers. I was ready to give up a few times and Nate’s encouragement kept me going.&lt;br /&gt;&lt;br /&gt;Special thanks to Robert Griesemer and others on the Go dev team for their time and patience in teaching me the subject matter. The Go dev team is filled with an amazing group of people who really care about the community and the people who are a part of it. Thanks!!&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/8829517233269698363/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/04/introduction-to-numeric-constants-in-go.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/8829517233269698363'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/8829517233269698363'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/04/introduction-to-numeric-constants-in-go.html' title='Introduction To Numeric Constants In Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-7658649759967055434</id><published>2014-03-15T17:07:00.001-04:00</published><updated>2014-09-07T14:49:06.344-04:00</updated><title type='text'>Exported/Unexported Identifiers In Go</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;One of the first things I learned about in Go was using an uppercase or lowercase letter as the first letter when naming a type, variable or function. It was explained that when the first letter was capitalized, the identifier was public to any piece of code that wanted to use it. When the first letter was lowercase, the identifier was private and could only be accessed within the package it was declared.&lt;br /&gt;&lt;br /&gt;I have come to realize that the use of the language public and private is really not accurate. It is more accurate to say an identifier is exported or unexported from a package. When an identifier is exported from a package, it means the identifier can be directly accessed from any other package in the code base. When an identifier is unexported from a package, it can&#39;t be directly accessed from any other package. What we will soon learn is that just because an identifier is unexported, it doesn&#39;t mean it can&#39;t be accessed outside of its package, it just means it can&#39;t be accessed directly.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Direct Identifier Access&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Let&#39;s start with a simple example of an exported type:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_1a.go&quot;&gt;&lt;/script&gt;Here we define a named type called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;AlertCounter&lt;/span&gt;&amp;nbsp;inside the package &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;counters&lt;/span&gt;. This type is an alias for the built-in type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;int&lt;/span&gt;, but in Go &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;AlertCounter&lt;/span&gt;&amp;nbsp;will be considered a unique and distinct type. We are using the capital letter &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;&#39;A&#39;&lt;/span&gt; as the first letter for the name of the type, which means this type is exported and accessible by other packages.&lt;br /&gt;&lt;br /&gt;Now let&#39;s access our&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;AlertCounter&lt;/span&gt;&amp;nbsp;type in the main program:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_1b.go&quot;&gt;&lt;/script&gt;Since the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;AlertCounter&lt;/span&gt;&amp;nbsp;type has been exported, this code builds fine. When we run the program we get the value of 10.&lt;br /&gt;&lt;br /&gt;Now let&#39;s change the exported &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;AlertCounter&lt;/span&gt;&amp;nbsp;type to be an unexported type by changing the name to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;alertCounter&lt;/span&gt;&amp;nbsp;and see what happens:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_2a.go&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_2b.go&quot;&gt;&lt;/script&gt;After making the changes to the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;counters&lt;/span&gt;&amp;nbsp;and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;main&lt;/span&gt;&amp;nbsp;packages, we attempt to build the code again and get the following compiler error:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;./main.go:11: cannot refer to unexported name counters.alertCounter&lt;br /&gt;./main.go:11: undefined: counters.alertCounter &lt;/div&gt;&lt;br /&gt;As expected we can&#39;t directly access the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;alertCounter&lt;/span&gt;&amp;nbsp;type because it is unexported. Even though we&amp;nbsp;can&#39;t access the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;alertCounter&lt;/span&gt;&amp;nbsp;type directly anymore, there is a way for us to create and use variables of this unexported type in the main package:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_3a.go&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_3b.go&quot;&gt;&lt;/script&gt;In the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;counters&lt;/span&gt;&amp;nbsp;package we add an exported function called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;NewAlertCounter&lt;/span&gt;. This function creates and returns values of the&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;alertCounter&lt;/span&gt;&amp;nbsp;type. In the main program we use this&amp;nbsp;function and the programming logic stays the same.&lt;br /&gt;&lt;br /&gt;What this example shows is that an identifier that is declared as unexported can still be accessed and used by other packages. It just can&#39;t be accessed directly.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Using Structs&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Defining exported and unexported members for our structs work in the exact same way. If a field or method name starts with a capital letter, the member is exported and is accessible outside of the package. If a field or method starts with a lowercase letter, the member is unexported and does not have accessibility outside of the package.&lt;br /&gt;&lt;br /&gt;Here is an example of a struct with both exported and unexported fields. The main program has a compiler error because it attempts to access the unexported field directly:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_4a.go&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_4b.go&quot;&gt;&lt;/script&gt;Here is the error from the compiler:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;./main.go:14: unknown animal.Dog field &#39;age&#39; in struct literal &lt;/div&gt;&lt;br /&gt;As expected the compiler does not let the main program access the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;age&lt;/span&gt;&amp;nbsp;field directly.&lt;br /&gt;&lt;br /&gt;Let&#39;s look at an interesting example of embedding. We start with two struct types where one type embeds the other:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_5a.go&quot;&gt;&lt;/script&gt;We added a new exported type called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Animal&lt;/span&gt;&amp;nbsp;with two exported fields called &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Name&lt;/span&gt;&amp;nbsp;and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Age&lt;/span&gt;. Then we embed the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Animal&lt;/span&gt;&amp;nbsp;type into the exported &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Dog&lt;/span&gt;&amp;nbsp;type. This means that the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Dog&lt;/span&gt;&amp;nbsp;type now has three exported fields, &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Name&lt;/span&gt;, &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Age&lt;/span&gt;&amp;nbsp;and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;BarkStrength&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;Let&#39;s look at the implementation of the main program:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_5b.go&quot;&gt;&lt;/script&gt;In main we use a composite literal to create and initialize a value of the exported &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Dog&lt;/span&gt;&amp;nbsp;type. Then we display the structure and values of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;dog&lt;/span&gt;&amp;nbsp;value.&lt;br /&gt;&lt;br /&gt;To make things more interesting, let&#39;s change the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Animal&lt;/span&gt;&amp;nbsp;type from exported to unexported by changing the first letter of the type&#39;s name to a lowercase letter &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;&#39;a&#39;&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_6a.go&quot;&gt;&lt;/script&gt;The&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;animal&lt;/span&gt;&amp;nbsp;type remains embedded in the exported&amp;nbsp;&lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Dog&lt;/span&gt;&amp;nbsp;type, but now as an unexported type.&amp;nbsp;We keep the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Name&lt;/span&gt;&amp;nbsp;and &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Age&lt;/span&gt;&amp;nbsp;fields within the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;animal&lt;/span&gt;&amp;nbsp;type as exported fields.&lt;br /&gt;&lt;br /&gt;In the main program we just change the name of the type from &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Animal&lt;/span&gt;&amp;nbsp;to &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;animal&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_6b.go&quot;&gt;&lt;/script&gt;Once again we have a main program that can&#39;t compile because we are trying to access the unexported type &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;animal&lt;/span&gt;&amp;nbsp;from inside the composite literal:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;./main.go:11: cannot refer to unexported name animals.animal&lt;br /&gt;./main.go:14: unknown animals.Dog field &#39;animal&#39; in struct literal &lt;/div&gt;&lt;br /&gt;We can fix the compiler error by initializing the exported fields from the unexported embedded type outside of the composite literal:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_7.go&quot;&gt;&lt;/script&gt;Now the main program builds again. The exported fields that were embedded into the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Dog&lt;/span&gt;&amp;nbsp;type from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;animal&lt;/span&gt;&amp;nbsp;type are accessible, even though they came from an unexported type. The exported fields keep their exported status when the type is embedded.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Standard Library&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The exported &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt;&amp;nbsp;type from the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;time&lt;/span&gt;&amp;nbsp;package is a good example of a type from the standard library that provides no access to its internals:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9567247.js?file=exportedtypes_8.go&quot;&gt;&lt;/script&gt;The language designers are using the unexported fields to keep the internals of the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;Time&lt;/span&gt; type private. They are &quot;hiding&quot; the information so we can&#39;t do anything contrary to how the time data works. With that being said, we still can use the unexported fields through the interface they provide. Without the ability to use and access unexported fields indirectly, we would not be able to copy values of this type or embed this type into our own struct types.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;A solid understanding of how to hide and provide access to data from our packages is important. There is a lot more to exporting and unexporting identifiers than meets the eye. In setting out to write this post, I though a couple of examples would do the trick. Then I realized how involved the topic can get once we start looking at embedding unexported types into our own types.&lt;br /&gt;&lt;br /&gt;The ability to use exported or unexported identifiers is an implementation detail, one that Go give us flexibility to use in our programs. The standard library has great examples of using unexported identifiers to hide and protect data. We looked at one example with the &lt;span style=&quot;font-family: Courier New, Courier, monospace;&quot;&gt;time.Time&lt;/span&gt;&amp;nbsp;type. Take the time to look at the standard library to learn more.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/7658649759967055434/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/03/exportedunexported-identifiers-in-go.html#comment-form' title='2 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/7658649759967055434'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/7658649759967055434'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/03/exportedunexported-identifiers-in-go.html' title='Exported/Unexported Identifiers In Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-6296062787601634495</id><published>2014-03-07T17:58:00.001-05:00</published><updated>2014-03-14T17:28:38.879-04:00</updated><title type='text'>Web Form Validation And Localization In Go</title><content type='html'>&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;As I improve my knowledge and framework for a Go based web service I am building, I continue to go back and enhance my &lt;a href=&quot;http://www.goinggo.net/2013/12/sample-web-application-using-beego-and.html&quot; target=&quot;_blank&quot;&gt;Beego Sample App&lt;/a&gt;. Something I just added recently was providing localized messages for validation errors. I was fortunate to find Nick Snyder&#39;s &lt;a href=&quot;https://github.com/nicksnyder/go-i18n&quot; target=&quot;_blank&quot;&gt;go-i18n&lt;/a&gt; package. Nick&#39;s package made it easy to support multiple languages for the Go web service I am writing.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Abstracting go-i18n&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The go-i18n package is simple to use and you can use it to read files or strings that contain all the messages you want to localize. It has some nice features including variable substitution and support for handling plurals for each individual locale. Nick has documentation for his package, so I am going to show you how I abstracted and integrated go-i18n into the Beego sample app.&lt;br /&gt;&lt;br /&gt;I decided I didn&#39;t want to use files to store the messages, but create raw string literal variables. The less I had to worry about managing external resources the better. With that being said, I built a simple package that abstracted the support I needed. Luckily go-i18n supports passing in a string that can contain the JSON document with the message data:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9417459.js?file=localization_messages.go&quot;&gt;&lt;/script&gt;I am just using simple messages right now, but as you can see, the variable En_US is defined and assigned a JSON document with the messages I need localized. The go-i18n package also lets you define messages like this:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9417459.js?file=localization_sample.go&quot;&gt;&lt;/script&gt;In this sample, the translation has one message for the singular case and one for the plural case. There is also support for using variable substitution thanks to template support.&lt;br /&gt;&lt;br /&gt;Here is the localize package that provides support for the web service:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9417459.js?file=localization_full.go&quot;&gt;&lt;/script&gt;The Init function creates the default locale for the application. Currently the Beego Sample App only supports English for the United States. Eventually, we can add cases for the other locales. Obviously this can all be done through configuration in the future.&lt;br /&gt;&lt;br /&gt;The Init function uses the LoadJSON function to load the go-i18n datastore with the internal messages for the default locale. Later on we can use the LoadJSON function again to load more JSON documents for the same or different locales.&lt;br /&gt;&lt;br /&gt;The Init function also uses the NewTranslation function to obtain a new i18n.TranslateFunc object for the default locale. This object is used to retrieve messages from the go-i18n datastore. If we have a scenario where the default locale is not valid, we can use the NewTranslation function at any time to obtain an object for the locale we need.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Beego Integration&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;To see how I integrated the go-i18n package into the sample app, we need to look at the controller:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9417459.js?file=localization_controller.go&quot;&gt;&lt;/script&gt;As discussed in my previous post about the Beego Sample App, we define a struct with tags that are used by the Beego validation module. I added support for defining the error to be returned when validation fails, by providing a new tag called error. In this case the error tag contains the id of the localized message we want to return. The ParseAndValidate function will handle the rest:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9417459.js?file=localization_parseval.go&quot;&gt;&lt;/script&gt;When the Beego validation module finds a problem, then the real work begins. The function uses reflection to find the error tag on any of the fields in the param struct. If an error tag is found, the id of the localized message is stored along with the field name. Then the function ranges over all the errors that the Beego validation module found and if an error tag existed for that field, we use the id to retrieve the localized message.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Testing&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;If we run the run_endpoint_test.sh shell script, which can be found in the zscripts folder, we can see the localized message returned in the last test:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/goinggo/9417459.js?file=localization_result.go&quot;&gt;&lt;/script&gt;The last test is designed to validate the localized message is returned.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The Beego framework has been great for developing my Go web service. It has the right amount of framework and modules, like the validation module, when you need it. The ability to bring in a package like go-i18n and integrate it so easily is another big win for Beego.&lt;br /&gt;&lt;br /&gt;If you are in need for localizing your Go application, take a look at go-i18n and see if it can work for you.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/6296062787601634495/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/03/web-form-validation-and-localization-in.html#comment-form' title='5 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/6296062787601634495'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/6296062787601634495'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/03/web-form-validation-and-localization-in.html' title='Web Form Validation And Localization In Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-736250672526085148</id><published>2014-02-25T10:19:00.000-05:00</published><updated>2014-03-14T09:52:09.673-04:00</updated><title type='text'>Running MongoDB Queries Concurrently With Go</title><content type='html'>&lt;i&gt;If you are attending GopherCon 2014 or plan to watch the videos once they are released, this article will prepare you for the talk by Gustavo Niemeyer and Steve Francia. It provides a&amp;nbsp;beginners view for using the Go mgo driver against a MongoDB database.&amp;nbsp;&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;MongoDB supports many different programming languages thanks to a great set of &lt;a href=&quot;http://docs.mongodb.org/ecosystem/drivers/&quot;&gt;drivers&lt;/a&gt;. One such driver is the MongoDB Go driver which is called &lt;a href=&quot;http://labix.org/mgo&quot;&gt;mgo&lt;/a&gt;. This driver has been externally developed by &lt;a href=&quot;http://gophercon.com/speakers/#gustavo_niemeyer&quot;&gt;Gustavo Niemeyer&lt;/a&gt; from Canonical, and eventually &lt;a href=&quot;http://gophercon.com/speakers/#steve_francia&quot;&gt;Steve Francia&lt;/a&gt;, the head of the drivers team at MongoDB Inc, took notice and offered support. Both Gustavo and Steve will be talking at &lt;a href=&quot;http://gophercon.com/&quot;&gt;GopherCon 2014&lt;/a&gt; in April about &quot;&lt;a href=&quot;http://gophercon.com/schedule/#gustavo_niemeyer&quot;&gt;Painless Data Storage With MongoDB and Go&lt;/a&gt;&quot;. The talk centers around the mgo driver and how MongoDB and Go really work well together to build highly scalable and concurrent software.&lt;span id=&quot;docs-internal-guid-42314786-69f7-a6d7-0263-6f34798f5ee5&quot;&gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;MongoDB and Go let us build scalable software on many different operating systems and architectures, without the need to install any frameworks or runtime environments. Go programs are native binaries and the Go tooling is constantly improving to create binaries that run as fast as equivalent C programs. That wouldn&#39;t mean anything if writing code in Go was complicated and as tedious as writing programs in C. This is where Go really shines because once you get up to speed, writing programs in Go is fast and fun.&lt;br /&gt;&lt;br /&gt;In this post I am going to show you how to write a Go program using the mgo driver to connect and run queries concurrently against a MongoDB database. I will break down the sample code and explain a few things that seem to be always be a bit confusing to those new to MongoDB and Go.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Sample Program&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The sample program connects to a public MongoDB database I have hosted with&amp;nbsp;&lt;a href=&quot;https://mongolab.com/welcome/&quot; target=&quot;_blank&quot;&gt;MongoLab&lt;/a&gt;. If you have &lt;a href=&quot;http://www.goinggo.net/2013/06/installing-go-gocode-gdb-and-liteide.html&quot; target=&quot;_blank&quot;&gt;Go&lt;/a&gt; and &lt;a href=&quot;http://wiki.bazaar.canonical.com/Download&quot; target=&quot;_blank&quot;&gt;Bazaar&lt;/a&gt; installed on your machine, you can run the program. The program launches ten goroutines that individually query all the records from the buoy_stations collection inside the goinggo database. The records are unmarshaled into native Go types and each goroutine logs the number of documents returned:&lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/ardan-bkennedy/9198289.js?file=GoMgoSample-Full.go&quot;&gt;&lt;/script&gt;Now that you have seen the entire program, we can break it down. Let&#39;s start with the type structures that are defined in the beginning: &lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/ardan-bkennedy/9198289.js?file=GoMgoSample-1.go&quot;&gt;&lt;/script&gt;The structures represent the data that we are going to retrieve and unmarshal from our query. BuoyStation represents the main document and BuoyCondition and BuoyLocation are embedded documents. The mgo driver makes it easy to use native types that represent the documents stored in our collections by using tags. With the tags, we can control how the mgo driver unmarshals the returned documents into our native Go structures.&lt;br /&gt;&lt;br /&gt;Now let&#39;s look at how we connect to a MongoDB database using mgo: &lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/ardan-bkennedy/9198289.js?file=GoMgoSample-2.go&quot;&gt;&lt;/script&gt;We start with creating a mgo.DialInfo object. We can connect to a single MongoDB database or a replica set. Connecting to a replica set can be accomplished by providing multiple addresses in the Addrs field or with a single address. If we are using a single host address to connect to a replice set, the mgo driver will learn about any remaining hosts from the replica set member we connect to. In our case we are connecting to a single host.&lt;br /&gt;&lt;br /&gt;After providing the host, we specify the database, username and password we need for authentication. One thing to note is that the database we authenticate against may not necessarily be the database our application needs to access. Some applications authenticate against the admin database and then use other databases depending on their configuration. The mgo driver supports these types of configurations very well.&lt;br /&gt;&lt;br /&gt;Next we use the mgo.DialWithInfo method to create a mgo.Session object. The mgo.Session object maintains a pool of connections to the MongoDB host. We can create multiple sessions with different modes and settings to support different aspects of our applications.  We can specify if the session is to use a Strong or Monotonic mode, and we can set the safe level as well as other settings. &lt;br /&gt;&lt;br /&gt;The next line of code sets the mode for the session. There are three modes that can be set, Strong, Monotonic and Eventual. Each mode sets a specific consistency for how reads and writes are performed. For more information on the differences between each mode, check out the &lt;a href=&quot;http://godoc.org/labix.org/v2/mgo#Session.SetMode&quot; target=&quot;_blank&quot;&gt;documentation&lt;/a&gt; for the mgo driver.&lt;br /&gt;&lt;br /&gt;We are using Monotonic mode which provides reads that may not entirely be up to date, but the reads will always see the history of changes moving forward. In this mode reads occur against secondary members of our replica sets until a write happens. Once a write happens, the primary member is used. The benefit is some distribution of the reading load can take place against the secondaries when possible.&lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;With the session set and ready to go, next we execute multiple queries concurrently:&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/ardan-bkennedy/9198289.js?file=GoMgoSample-4.go&quot;&gt;&lt;/script&gt;This code is classic Go concurrency in action. First we create a sync.WaitGroup object so we can keep track of all the goroutines we are going to launch as they complete their work. Then we immediately set the count of the sync.WaitGroup object to ten and use a for loop to launch ten goroutines using the RunQuery function. The keyword go is used to launch a function or method to run concurrently. The final line of code calls the Wait method on the sync.WaitGroup object which locks the main goroutine until everything is done processing.&lt;br /&gt;&lt;br /&gt;To learn more about Go concurrency and better understand how this particular piece of code works, check out these posts on &lt;a href=&quot;http://www.goinggo.net/2014/01/concurrency-goroutines-and-gomaxprocs.html&quot; target=&quot;_blank&quot;&gt;concurrency&lt;/a&gt; and &lt;a href=&quot;http://www.goinggo.net/2014/02/the-nature-of-channels-in-go.html&quot; target=&quot;_blank&quot;&gt;channels&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Now let&#39;s look at the RunQuery function and see how to properly use the mgo.Session object to acquire a connection and execute a query: &lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/ardan-bkennedy/9198289.js?file=GoMgoSample-5.go&quot;&gt;&lt;/script&gt;The very first thing we do inside of the RunQuery function is to defer the execution of the Done method on the sync.WaitGroup object. The defer keyword will postpone the execution of the Done method, to take place once the RunQuery function returns. This will guarantee that the sync.WaitGroup objects count will decrement even if an unhandled exception occurs.&lt;br /&gt;&lt;br /&gt;Next we make a copy of the session we created in the main goroutine. Each goroutine needs to create a copy of the session so they each obtain their own socket without serializing their calls with the other goroutines. Again, we use the defer keyword to postpone and guarantee the execution of the Close method on the session once the RunQuery function returns. Closing the session returns the socket back to the main pool, so this is very important. &lt;br /&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/ardan-bkennedy/9198289.js?file=GoMgoSample-6.go&quot;&gt;&lt;/script&gt;To execute a query we need a mgo.Collection object. We can get a mgo.Collection object through the mgo.Session object by specifying the name of the database and then the collection. Using the mgo.Collection object, we can perform a Find and retrieve all the documents from the collection. The All function will unmarshal the response into our slice of BuoyStation objects. A slice is a dynamic array in Go. Be aware that the All method will load all the data in memory at once. For large collections it is better to use the &lt;a href=&quot;http://godoc.org/labix.org/v2/mgo#Iter&quot; target=&quot;_blank&quot;&gt;Iter&lt;/a&gt; method instead. Finally, we just log the number of BuoyStation objects that are returned.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The example shows how to use Go concurrency to launch multiple goroutines that can execute queries against a MongoDB database independently. Once a session is established, the mgo driver exposes all of the MongoDB functionality and handles the unmarshaling of BSON documents into Go native types.&lt;br /&gt;&lt;br /&gt;MongoDB can handle a large number of concurrent requests when you architect your MongoDB databases and collections with concurrency in mind. Go and the mgo driver are perfectly aligned to push MongoDB to its limits and build software that can take advantage of all the computing power that is available.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;p1&quot;&gt;The mgo driver can help you distribute your queries across a MongoDB replica set. The mgo driver gives you the ability to create and configure your sessions and take advantage of MongoDB&#39;s mode and configuration options. The mode you use for your session, how and where the cluster and load balancer is setup, and the type of work being processed by MongoDB at the time of those queries, plays an important role in the actual distribution.&lt;/div&gt;&lt;div class=&quot;p1&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;p1&quot;&gt;The mgo driver provides a safe way to leverage Go&#39;s concurrency support and you have the flexibility to execute queries concurrently and in parallel. It is best to take the time to learn a bit about MongoDB replica sets and load balancer configuration. Then make sure the load balancer is behaving as expected under the different types of load your application can produce.&lt;/div&gt;&lt;br /&gt;Now is a great time to see what MongoDB and Go can do for your software applications, web services and service platforms. Both technologies are being battle tested everyday by all types of companies, solving all types of business and computing problems.  &lt;!-- package main  import (  &quot;labix.org/v2/mgo&quot;  &quot;labix.org/v2/mgo/bson&quot;  &quot;log&quot;  &quot;sync&quot;  &quot;time&quot; )  const (  MongoDBHosts = &quot;ds035428.mongolab.com:35428&quot;  AuthDatabase = &quot;goinggo&quot;  AuthUserName = &quot;guest&quot;  AuthPassword = &quot;welcome&quot;  TestDatabase = &quot;goinggo&quot; )  type (  // BuoyCondition contains information for an individual station  BuoyCondition struct {   WindSpeed     float64 `bson:&quot;wind_speed_milehour&quot;`   WindDirection int     `bson:&quot;wind_direction_degnorth&quot;`   WindGust      float64 `bson:&quot;gust_wind_speed_milehour&quot;`  }   // BuoyLocation contains the buoy&#39;s location  BuoyLocation struct {   Type        string    `bson:&quot;type&quot;`   Coordinates []float64 `bson:&quot;coordinates&quot;`  }   // BuoyStation contains information for an individual station  BuoyStation struct {   ID        bson.ObjectId `bson:&quot;_id,omitempty&quot;`   StationId string        `bson:&quot;station_id&quot;`   Name      string        `bson:&quot;name&quot;`   LocDesc   string        `bson:&quot;location_desc&quot;`   Condition BuoyCondition `bson:&quot;condition&quot;`   Location  BuoyLocation  `bson:&quot;location&quot;`  } )  func main() {  // We need this object to establish a session to our MongoDB  mongoDBDialInfo := &amp;mgo.DialInfo{   Addrs:    []string{MongoDBHosts},   Timeout:  60 * time.Second,   Database: AuthDatabase,   Username: AuthUserName,   Password: AuthPassword,  }   // Create a session which maintains a pool of socket connections  // to our MongoDB  mongoSession, err := mgo.DialWithInfo(mongoDBDialInfo)  if err != nil {   log.Fatalf(&quot;CreateSession: %s\n&quot;, err)  }   // Reads may not be entirely up-to-date, but they will always see the  // history of changes moving forward, the data read will be consistent  // across sequential queries in the same session, and modifications made  // within the session will be observed in following queries (read-your-writes).  // http://godoc.org/labix.org/v2/mgo#Session.SetMode  mongoSession.SetMode(mgo.Monotonic, true)   // Create a wait group to manage the goroutines  var waitGroup sync.WaitGroup   // Perform 10 concurrent queries against the database  waitGroup.Add(10)  for query := 0; query &lt; 10; query++ {   go RunQuery(query, &amp;waitGroup, mongoSession)  }   // Wait for all the queries to complete  waitGroup.Wait()  log.Println(&quot;All Queries Completed&quot;) }  func RunQuery(query int, waitGroup *sync.WaitGroup, mongoSession *mgo.Session) {  // Decrement the wait group count so the program knows this  // has been completed once the goroutine exits  defer waitGroup.Done()   // Request a socket connection from the session to process our query.  // Close the session when the goroutine exits and put the connection back  // into the pool  sessionCopy := mongoSession.Copy()  defer sessionCopy.Close()   // Get a collection to execute the query against  collection := sessionCopy.DB(TestDatabase).C(&quot;buoy_stations&quot;)   log.Printf(&quot;RunQuery : %d : Executing\n&quot;, query)   // Retrieve the list of stations  var buoyStations []BuoyStation  err := collection.Find(nil).All(&amp;buoyStations)  if err != nil {   log.Printf(&quot;RunQuery : ERROR : %s\n&quot;, err)   return  }   log.Printf(&quot;RunQuery : %d : Count[%d]\n&quot;, query, len(buoyStations)) } --&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/736250672526085148/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/02/running-queries-concurrently-against.html#comment-form' title='5 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/736250672526085148'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/736250672526085148'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/02/running-queries-concurrently-against.html' title='Running MongoDB Queries Concurrently With Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-4469444733656318355</id><published>2014-02-17T09:25:00.000-05:00</published><updated>2014-03-14T17:23:24.797-04:00</updated><title type='text'>The Nature Of Channels In Go</title><content type='html'>&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;In my last post called &lt;a href=&quot;http://www.goinggo.net/2014/01/concurrency-goroutines-and-gomaxprocs.html&quot; target=&quot;_blank&quot;&gt;Concurrency, Goroutines and GOMAXPROCS&lt;/a&gt;, I set the stage for talking about channels. We discussed what concurrency was and how goroutines played a role. With that foundation in hand, we can now understand the nature of channels and how they can be used to synchronize goroutines to share resources in a safe, less error prone and fun way. &lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;What Are Channels&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Channels are type safe message queues that have the intelligence to control the behavior of any goroutine attempting to read or write to it. A channel acts as a conduit between two goroutines and will synchronize the exchange of any resource that is passed through it. It is the channel&#39;s ability to control the goroutines interaction that creates the synchronization mechanism. When a channel is created with no capacity for its queue, it is called an unbuffered channel. In turn, a channel created with capacity for its queue is called a buffered channel.&lt;br /&gt;&lt;br /&gt;To understand what the synchronization behavior will be for any goroutine interacting with a channel, we need to know the type and state of the channel. The scenarios are a bit different depending on whether we are using an unbuffered or buffered channel, so let&#39;s talk about each one independently.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Unbuffered Channels&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Unbuffered channels have no capacity and therefore require both goroutines to be ready to make any exchange. When a goroutine attempts to write a resource to an unbuffered channel and there is no goroutine waiting to receive the resource, the channel will lock the goroutine and make it wait. When a goroutine attempts to read from an unbuffered channel, and there is no goroutine waiting to send a resource, the channel will lock the goroutine and make it wait.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/-vnJIWvlbP-E/UwDVICJKB9I/AAAAAAAANX0/T04V_58i8Vs/s1600/Screen+Shot+2014-02-16+at+10.10.54+AM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-vnJIWvlbP-E/UwDVICJKB9I/AAAAAAAANX0/T04V_58i8Vs/s1600/Screen+Shot+2014-02-16+at+10.10.54+AM.png&quot; height=&quot;305&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;In the diagram above, we see an example of two goroutines making an exchange using an unbuffered channel. In step 1, the two goroutines approach the channel and then in step 2, the goroutine on the left sticks his hand into the channel or performs a write. At this point, that goroutine is locked in the channel until the exchange is complete. Then in step 3, the goroutine on the right places his hand into the channel or performs a read. That goroutine is also locked in the channel until the exchange is complete. In step 4 and 5 the exchange is made and finally in step 6, both goroutines are free to remove their hands and go on their way.&lt;br /&gt;&lt;br /&gt;Synchronization is inherent in the interaction between the write and the read. One can not happen without the other. The nature of an unbuffered channel is synchronization.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Buffered Channels&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Buffered channels have capacity and therefore can behave a bit differently. When a goroutine attempts to write a resource to a buffered channel and channel&#39;s queue is full, the channel will lock the goroutine and make it wait until a buffer becomes available. If there is room in the queue, the write can take place immediately and the goroutine can move on. When a goroutine attempts to read from a buffered channel and the buffered channel&#39;s queue is empty, the channel will lock the goroutine and make it wait until a resource has been queued.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://1.bp.blogspot.com/-GkVAtGeUzrs/UwIQ6AezJmI/AAAAAAAANYE/5XWpxN-zA3w/s1600/Screen+Shot+2014-02-17+at+8.38.15+AM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://1.bp.blogspot.com/-GkVAtGeUzrs/UwIQ6AezJmI/AAAAAAAANYE/5XWpxN-zA3w/s1600/Screen+Shot+2014-02-17+at+8.38.15+AM.png&quot; height=&quot;202&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;In the diagram above, we see an example of two goroutines adding and removing items from a buffered channel independently. In step 1, the goroutine on the right is removing a resource from the channel or performing a read. In step 2, the goroutine on the right can remove the resource independent of the goroutine on the left adding a new resource to the channel. In step 3, both goroutines are adding and removing a resource from the channel at the same time and in step 4 both goroutines are done.&lt;br /&gt;&lt;br /&gt;Synchronization still occurs within the interactions of reads and writes, however when the queue has buffer availability, the writes will not lock. Reads will not lock when there is something to read from the queue. Consequently, if the buffer is full or if there is nothing to retrieve, a buffered channel will behave very much like an unbuffered channel.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Relay Race&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;If you have ever watched a track meet you may have seen a relay race. In a relay race there are four athletes who run around the track as fast as they can as a team. The key to the race is that only one runner per team can be running at a time. The runner with the baton is the only one allowed to run, and the exchange of the baton from runner to runner is critical to winning the race.&lt;br /&gt;&lt;br /&gt;Let&#39;s build a sample program that uses four goroutines and a channel to simulate a relay race. The goroutines will be the runners in the race and the channel will be used to exchanged the baton between each runner. This is a classic example of how resources can be passed between goroutines and how a channel controls the behavior of the goroutines that interact with it.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;package main&lt;br /&gt;&lt;br /&gt;import (&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;fmt&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;time&quot;&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;func main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Create an unbuffered channel&lt;br /&gt;&amp;nbsp; &amp;nbsp; baton := make(chan int)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // First runner to his mark&lt;br /&gt;&amp;nbsp; &amp;nbsp; go Runner(baton)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Start the race&lt;br /&gt;&amp;nbsp; &amp;nbsp; baton &amp;lt;- 1&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Give the runners time to race&lt;br /&gt;&amp;nbsp; &amp;nbsp; time.Sleep(500 * time.Millisecond)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;func Runner(baton chan int) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; var newRunner int&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Wait to receive the baton&lt;br /&gt;&amp;nbsp; &amp;nbsp; runner := &amp;lt;-baton&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Start running around the track&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Printf(&quot;Runner %d Running With Baton\n&quot;, runner)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // New runner to the line&lt;br /&gt;&amp;nbsp; &amp;nbsp; if runner != 4 {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; newRunner = runner + 1&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;Runner %d To The Line\n&quot;, newRunner)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; go Runner(baton)&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Running around the track&lt;br /&gt;&amp;nbsp; &amp;nbsp; time.Sleep(100 * time.Millisecond)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Is the race over&lt;br /&gt;&amp;nbsp; &amp;nbsp; if runner == 4 {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;Runner %d Finished, Race Over\n&quot;, runner)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Exchange the baton for the next runner&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Printf(&quot;Runner %d Exchange With Runner %d\n&quot;, runner, newRunner)&lt;br /&gt;&amp;nbsp; &amp;nbsp; baton &amp;lt;- newRunner&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;When we run the sample program we get the following output:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Runner 1 Running With Baton&lt;br /&gt;Runner 2 To The Line&lt;br /&gt;Runner 1 Exchange With Runner 2&lt;br /&gt;Runner 2 Running With Baton&lt;br /&gt;Runner 3 To The Line&lt;br /&gt;Runner 2 Exchange With Runner 3&lt;br /&gt;Runner 3 Running With Baton&lt;br /&gt;Runner 4 To The Line&lt;br /&gt;Runner 3 Exchange With Runner 4&lt;br /&gt;Runner 4 Running With Baton&lt;br /&gt;Runner 4 Finished, Race Over &lt;/div&gt;&lt;br /&gt;The program starts out creating an unbuffered channel:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Create an unbuffered channel&lt;br /&gt;baton := make(chan int)&lt;/div&gt;&lt;br /&gt;Using an unbuffered channel forces the goroutines to be ready at the same time to make the exchange of the baton. This need for both goroutines to be ready creates the synchronization.&lt;br /&gt;&lt;br /&gt;If we look at the rest of the main function, we see a goroutine created for the first runner in the race and then the baton is handed off to that runner. The baton in this example is an integer value that is being passed between each runner. The sample is using a sleep to let the race complete before main terminates and ends the program:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Create an unbuffered channel&lt;br /&gt;baton := make(chan int)&lt;br /&gt;&lt;br /&gt;// First runner to his mark&lt;br /&gt;go Runner(baton)&lt;br /&gt;&lt;br /&gt;// Start the race&lt;br /&gt;baton &amp;lt;- 1&lt;br /&gt;&lt;br /&gt;// Give the runners time to race&lt;br /&gt;time.Sleep(500 * time.Millisecond) &lt;/div&gt;&lt;br /&gt;If we just focus on the core parts of the Runner function, we can see how the baton exchange takes place until the race is over. The Runner function is launched as a goroutine for each runner in the race. Every time a new goroutine is launched, the channel is passed into the goroutine. The channel is the conduit for the exchange, so the current runner and the one waiting to go next need to reference the channel:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func Runner(baton chan int)&lt;/div&gt;&lt;br /&gt;The first thing each runner does is wait for the baton exchange. That is simulated with the read on the channel. The read immediately locks the goroutine until the baton is written to the channel. Once the baton is written to the channel, the read will release and the goroutine will simulate the next runner sprinting down the track. If the fourth runner is running, no new runner will enter the race. If we are still in the middle of the race, a new goroutine for the next runner is launched.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Wait to receive the baton&lt;br /&gt;runner := &amp;lt;-baton&lt;br /&gt;&lt;br /&gt;// New runner to the line&lt;br /&gt;if runner != 4 {&lt;br /&gt;&amp;nbsp; &amp;nbsp; newRunner = runner + 1&lt;br /&gt;&amp;nbsp; &amp;nbsp; go Runner(baton)&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;Then we sleep to simulate some time it takes for the runner to run around the track. If this is the fourth runner, the goroutine terminates after the sleep and the race is complete. If not, the baton exchange takes place with the write to the channel. There is a goroutine already locked and waiting for this exchange. As soon as the baton is written to the channel, the exchange is made and the race continue:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Running around the track&lt;br /&gt;time.Sleep(100 * time.Millisecond)&lt;br /&gt;&lt;br /&gt;// Is the race over&lt;br /&gt;if runner == 4 {&lt;br /&gt;&amp;nbsp; &amp;nbsp; return&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// Exchange the baton for the next runner&lt;br /&gt;baton &amp;lt;- newRunner&lt;/div&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The example showcases a real world event, a relay race between runners, being implemented in a way that mimics the actual events. This is one of the beautiful things about channels. The code flows in a way that simulates how these types of exchanges can happen in the real world.&lt;br /&gt;&lt;br /&gt;Now that we have an understanding of the nature of unbuffered and buffered channels, we can look at different concurrency patterns we can implement using channels. Concurrency patterns allow us to implement more complex exchanges between goroutines that simulate real world computing problems like semaphores, generators and multiplexers.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/4469444733656318355/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/02/the-nature-of-channels-in-go.html#comment-form' title='4 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/4469444733656318355'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/4469444733656318355'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/02/the-nature-of-channels-in-go.html' title='The Nature Of Channels In Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://3.bp.blogspot.com/-vnJIWvlbP-E/UwDVICJKB9I/AAAAAAAANX0/T04V_58i8Vs/s72-c/Screen+Shot+2014-02-16+at+10.10.54+AM.png" height="72" width="72"/><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-6392567019291607235</id><published>2014-01-29T21:55:00.000-05:00</published><updated>2015-07-24T08:51:57.157-04:00</updated><title type='text'>Concurrency, Goroutines and GOMAXPROCS</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;When new people join the &lt;a href=&quot;http://www.meetup.com/Go-Miami/&quot; target=&quot;_blank&quot;&gt;Go-Miami&lt;/a&gt; group they always write that they want to learn more about Go&#39;s concurrency model. Concurrency seems to be the big buzz word around the language. It was for me when I first started hearing about Go. It was Rob Pike&#39;s &lt;a href=&quot;http://www.youtube.com/watch?v=f6kdp27TYZs&quot; target=&quot;_blank&quot;&gt;Go Concurrency Patterns&lt;/a&gt; video that finally convinced me I needed to learn this language.&lt;br /&gt;&lt;br /&gt;To understand how Go makes writing concurrent programs easier and less prone to errors, we first need to understand what a concurrent program is and the problems that result from such programs. I will not be talking about CSP (Communicating Sequential Processes) in this post, which is the basis for Go&#39;s implementation of channels. This post will focus on what a concurrent program is, the role that goroutines play and how the GOMAXPROCS environment variable and runtime function affects the behavior of the Go runtime and the programs we write.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Processes and Threads&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;When we run an application, like the browser I am using to write this post, a process is created by the operating system for the application. The job of the process is to act like a container for all the resources the application uses and maintains as it runs. These resources include things like a memory address space, handles to files, devices and threads.&lt;br /&gt;&lt;br /&gt;A thread is a path of execution that is scheduled by the operating system to execute the code we write in our functions against a processor. A process starts out with one thread, the main thread, and when that thread terminates the process terminates. This is because the main thread is the origin for the application. The main thread can then in turn launch more threads and those threads can launch even more threads.&lt;br /&gt;&lt;br /&gt;The operating system schedules a thread to run on an available processor regardless of which process the thread belongs to. Each operating system has its own algorithms that make these decisions and it is best for us to write concurrent programs that are not specific to one algorithm or the other. Plus these algorithms change with every new release of an operating system, so it is dangerous game to play.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Goroutines and Parallelism&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Any function or method in Go can be created as a goroutine. We can consider that the&amp;nbsp;main function is executing as a goroutine, however the Go runtime does not start that goroutine. Goroutines are considered to be lightweight because they use little memory and resources plus their initial stack size is small. Prior to version 1.2 the stack size started at 4K and now as of version 1.4 it starts at 8K. The stack has the ability to grow as needed.&lt;br /&gt;&lt;br /&gt;The operating system schedules threads to run against available processors and the Go runtime schedules goroutines to run within a &lt;a href=&quot;http://www.goinggo.net/2015/02/scheduler-tracing-in-go.html&quot; target=&quot;_blank&quot;&gt;logical processor&lt;/a&gt;&amp;nbsp;that is bound to a single operating system thread. By default, the Go runtime allocates a single logical processor to execute all the goroutines that are created for our program. Even with this single logical processor and operating system thread, hundreds of thousands of goroutines can be scheduled to run concurrently with amazing efficiency and performance. It is not recommended to add more that one logical processor, but if you want to run goroutines in parallel, Go provides the ability to add more via the GOMAXPROCS environment variable or runtime function.&lt;br /&gt;&lt;br /&gt;Concurrency is not Parallelism. Parallelism is when two or more threads are executing code simultaneously against different processors. If you configure the runtime to use more than one logical processor, the scheduler will distribute goroutines between these logical processors which will result in goroutines running on different operating system threads. However, to have true parallelism you need to run your program on a machine with multiple physical processors. If not, then the goroutines will be running concurrently against a single physical processor, even though the Go runtime is using multiple logical processors.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-size: large;&quot;&gt;&lt;b&gt;Concurrency Example&lt;/b&gt;&lt;/span&gt;&lt;br /&gt;Let&#39;s build a small program that shows Go running goroutines concurrently. In this example we are using the default setting of running with one logical processor:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;package main&lt;br /&gt;&lt;br /&gt;import (&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;fmt&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;sync&quot;&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;func main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; var wg sync.WaitGroup&lt;br /&gt;&amp;nbsp; &amp;nbsp; wg.Add(2)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&quot;Starting Go Routines&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &lt;b&gt;go&lt;/b&gt; func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; defer wg.Done()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for char := &#39;a&#39;; char &amp;lt; &#39;a&#39;+26; char++ {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;%c &quot;, char)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; }()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &lt;b&gt;go&lt;/b&gt; func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; defer wg.Done()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for number := 1; number &amp;lt; 27; number++ {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;%d &quot;, number)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; }()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&quot;Waiting To Finish&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; wg.Wait()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&quot;\nTerminating Program&quot;)&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;This program launches two goroutines by using the keyword &lt;i&gt;go&lt;/i&gt;&amp;nbsp;and declaring two anonymous functions. The first goroutine displays the english alphabet using lowercase letters and the second goroutine displays numbers 1 through 26. When we run this program we get the following output:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Starting Go Routines&lt;br /&gt;Waiting To Finish&lt;br /&gt;a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 10 11&lt;br /&gt;12 13 14 15 16 17 18 19 20 21 22 23 24 25 26&lt;br /&gt;Terminating Program&lt;/div&gt;&lt;br /&gt;When we look at the output we can see that the code was run concurrently. Once the two goroutines are launched, the main goroutine waits for the goroutines to complete. We need to do this because once the main goroutine terminates, the program terminates. Using a &lt;i&gt;WaitGroup&lt;/i&gt; is a great way for goroutines to communicate when they are done.&lt;br /&gt;&lt;br /&gt;We can see that the first goroutine completes displaying all 26 letters and then the second goroutine gets a turn to display all 26 numbers. Because it takes less than a microsecond for the first goroutine to complete its work, we don&#39;t see the scheduler interrupt the first goroutine before it finishes its work. We can give a reason to the scheduler to swap the goroutines by putting a sleep into the first goroutine:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;package main&lt;br /&gt;&lt;br /&gt;import (&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;fmt&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;sync&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;time&quot;&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;func main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; var wg sync.WaitGroup&lt;br /&gt;&amp;nbsp; &amp;nbsp; wg.Add(2)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&quot;Starting Go Routines&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; go func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; defer wg.Done()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;b&gt;time.Sleep(1 * time.Microsecond)&lt;/b&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for char := &#39;a&#39;; char &amp;lt; &#39;a&#39;+26; char++ {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;%c &quot;, char)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; }()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; go func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; defer wg.Done()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for number := 1; number &amp;lt; 27; number++ {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;%d &quot;, number)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; }()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&quot;Waiting To Finish&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; wg.Wait()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&quot;\nTerminating Program&quot;)&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;This time we add a sleep in the first goroutine as soon as it starts. Calling sleep causes the scheduler to swap the two goroutines:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Starting Go Routines&lt;br /&gt;Waiting To Finish&lt;br /&gt;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 a&lt;br /&gt;b c d e f g h i j k l m n o p q r s t u v w x y z&lt;br /&gt;Terminating Program&lt;/div&gt;&lt;br /&gt;This time the numbers display first and then the letters. The sleep causes the scheduler to stop running the first goroutine and let the second goroutine do its thing.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Parallel Example&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;In our past two examples the goroutines were running concurrently, but not in parallel. Let&#39;s make a change to the code to allow the goroutines to run in parallel. All we need to do is add a second logical processor to the scheduler to use two threads:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;package main&lt;br /&gt;&lt;br /&gt;import (&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;fmt&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;runtime&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;sync&quot;&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;func main() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &lt;b&gt;runtime.GOMAXPROCS(2)&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; var wg sync.WaitGroup&lt;br /&gt;&amp;nbsp; &amp;nbsp; wg.Add(2)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&quot;Starting Go Routines&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &lt;b&gt;go&lt;/b&gt; func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; defer wg.Done()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for char := &#39;a&#39;; char &amp;lt; &#39;a&#39;+26; char++ {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;%c &quot;, char)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; }()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &lt;b&gt;go&lt;/b&gt; func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; defer wg.Done()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for number := 1; number &amp;lt; 27; number++ {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;%d &quot;, number)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; }()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&quot;Waiting To Finish&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; wg.Wait()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(&quot;\nTerminating Program&quot;)&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;Here is the output for the program:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Starting Go Routines&lt;br /&gt;Waiting To Finish&lt;br /&gt;a b 1 2 3 4 c d e f 5 g h 6 i 7 j 8 k 9 10 11 12 l m n o p q 13 r s 14&lt;br /&gt;t 15 u v 16 w 17 x y 18 z 19 20 21 22 23 24 25 26&lt;br /&gt;Terminating Program &lt;/div&gt;&lt;br /&gt;Every time we run the program we are going to get different results. The scheduler does not behave exactly the same for each and every run. We can see that the goroutines are truly running in parallel. Both goroutines start running immediately and you can see them both competing for standard out to display their results.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Just because we can add multiple logical processors for the scheduler to use doesn&#39;t mean we should. There is a reason the Go team has set the defaults to the runtime the way they did. Especially the default for only using a single logical processor. Just know that arbitrarily adding logical processors and running goroutines in parallel will not necessarily provide better performance for your programs. Always &lt;a href=&quot;http://blog.golang.org/profiling-go-programs&quot; target=&quot;_blank&quot;&gt;profile&lt;/a&gt; and benchmark your programs and make sure the Go runtime configuration is only changed if absolutely required.&lt;br /&gt;&lt;br /&gt;The problem with building concurrency into our applications is eventually our goroutines are going to attempt to access the same resources, possibly at the same time. Read and write operations against a shared resource must always be atomic. In other words reads and writes must happen by one goroutine at a time or else we create race conditions in our programs. To learn more about &lt;a href=&quot;http://www.goinggo.net/2013/09/detecting-race-conditions-with-go.html&quot; target=&quot;_blank&quot;&gt;race conditions&lt;/a&gt; read my post.&lt;br /&gt;&lt;br /&gt;Channels are the way in Go we write safe and elegant concurrent programs that eliminate race conditions and make writing concurrent programs fun again. Now that we know how goroutines work, are scheduled and can be made to run in parallel, channels are the next thing we need to learn.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/6392567019291607235/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/01/concurrency-goroutines-and-gomaxprocs.html#comment-form' title='10 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/6392567019291607235'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/6392567019291607235'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/01/concurrency-goroutines-and-gomaxprocs.html' title='Concurrency, Goroutines and GOMAXPROCS'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>10</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-1319131010712056921</id><published>2014-01-21T21:24:00.000-05:00</published><updated>2014-01-21T21:24:44.136-05:00</updated><title type='text'>Decode JSON Documents In Go</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;We are working on a project where we have to make calls into a web service. Many of the web calls return very large documents that contain many sub-documents. The worst part is, we usually only need a handful of the fields for any given document and those fields tend to be scattered all over the place.&lt;br /&gt;&lt;br /&gt;Here is a sample of a smaller document:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;var document string = `{&lt;br /&gt;&quot;userContext&quot;: {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;conversationCredentials&quot;: {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;sessionToken&quot;: &quot;06142010_1:75bf6a413327dd71ebe8f3f30c5a4210a9b11e93c028d6e11abfca7ff&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; },&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;valid&quot;: true,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;isPasswordExpired&quot;: false,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;cobrandId&quot;: 10000004,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;channelId&quot;: -1,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;locale&quot;: &quot;en_US&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;tncVersion&quot;: 2,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;applicationId&quot;: &quot;17CBE222A42161A3FF450E47CF4C1A00&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;cobrandConversationCredentials&quot;: {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;sessionToken&quot;: &quot;06142010_1:b8d011fefbab8bf1753391b074ffedf9578612d676ed2b7f073b5785b&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; },&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;preferenceInfo&quot;: {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;currencyCode&quot;: &quot;USD&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;timeZone&quot;: &quot;PST&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;dateFormat&quot;: &quot;MM/dd/yyyy&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;currencyNotationType&quot;: {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;currencyNotationType&quot;: &quot;SYMBOL&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;numberFormat&quot;: {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;decimalSeparator&quot;: &quot;.&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;groupingSeparator&quot;: &quot;,&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;groupPattern&quot;: &quot;###,##0.##&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br /&gt;},&lt;br /&gt;&quot;lastLoginTime&quot;: 1375686841,&lt;br /&gt;&quot;loginCount&quot;: 299,&lt;br /&gt;&quot;passwordRecovered&quot;: false,&lt;br /&gt;&quot;emailAddress&quot;: &quot;johndoe@email.com&quot;,&lt;br /&gt;&quot;loginName&quot;: &quot;sptest1&quot;,&lt;br /&gt;&quot;userId&quot;: 10483860,&lt;br /&gt;&quot;userType&quot;: {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;userTypeId&quot;: 1,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;userTypeName&quot;: &quot;normal_user&quot;&lt;br /&gt;}&lt;br /&gt;}`&lt;/div&gt;&lt;br /&gt;It is not scalable for us to create all the structs and embedded structs to unmarshal the different JSON documents using json.Unmarshal and working directly with a map was out of the question. What we needed was a way to decode these JSON documents into structs that just contained the fields we needed, regardless where those fields lived in the JSON document.&lt;br /&gt;&lt;br /&gt;Luckily we came a across a package by &lt;a href=&quot;https://github.com/mitchellh&quot; target=&quot;_blank&quot;&gt;Mitchell Hashimoto&lt;/a&gt; called &lt;a href=&quot;https://github.com/goinggo/mapstructure&quot; target=&quot;_blank&quot;&gt;mapstructure&lt;/a&gt;&amp;nbsp;and we forked it. This package is able to take a JSON document that is already unmarshaled into a map and decode that into a struct. Unfortunately, you still needed to create all the embedded structs if you wanted the data at the different levels. So I studied the code and build some functionality on top that allowed us do what we needed.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;DecodePath&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The first function we added is called DecodePath. This allows us to specify the fields and sub-documents we want from the JSON document and store them into the structs we need. Let&#39;s start with a small example using the JSON document above:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type UserType struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; UserTypeId   int&lt;br /&gt;&amp;nbsp; &amp;nbsp; UserTypeName string&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;type User struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; Session &amp;nbsp; string &amp;nbsp; `jpath:&quot;userContext.cobrandConversationCredentials.sessionToken&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; CobrandId    int &amp;nbsp; &amp;nbsp; &amp;nbsp;`jpath:&quot;userContext.cobrandId&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; UserType &amp;nbsp;UserType `jpath:&quot;userType&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; LoginName    string &amp;nbsp; `jpath:&quot;loginName&quot;`&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;docScript := []byte(document)&lt;br /&gt;docMap := map[string]interface{}{}&lt;br /&gt;json.Unmarshal(docScript, &amp;amp;docMap)&lt;br /&gt;&lt;br /&gt;user := User{}&lt;br /&gt;DecodePath(docMap, &amp;amp;user)&lt;br /&gt;&lt;br /&gt;fmt.Printf(&quot;%#v&quot;, user) &lt;/div&gt;&lt;br /&gt;If we run this program we get the following output:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;mapstructure.User{&lt;br /&gt;&amp;nbsp; &amp;nbsp; Session:&quot;06142010_1:b8d011fefbab8bf1753391b074ffedf9578612d676ed2b7f073b5785b&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; CobrandId:10000004,&lt;br /&gt;&amp;nbsp; &amp;nbsp; UserType:mapstructure.UserType{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; UserTypeId:1,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; UserTypeName:&quot;normal_user&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; LoginName:&quot;sptest1&quot;&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;The &quot;jpath&quot; tag is used to find the map keys and set the values into the struct. The User struct contains fields from three different layers of the JSON document. We only needed to define two structs to pull the data out of the map we needed.&lt;br /&gt;&lt;br /&gt;We can also map entire structs the same way a normal unmarshal would work. Just name the fields in the struct to match the field names in the JSON document. The names of the fields in the struct don&#39;t need to be in the same case as the fields in the JSON document.&lt;br /&gt;&lt;br /&gt;Here is a more complicated example using an anonymous field in our struct:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type NumberFormat struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; DecimalSeparator &amp;nbsp;string `jpath:&quot;userContext.preferenceInfo.numberFormat.decimalSeparator&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; GroupingSeparator string `jpath:&quot;userContext.preferenceInfo.numberFormat.groupingSeparator&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; GroupPattern &amp;nbsp; &amp;nbsp; &amp;nbsp;string `jpath:&quot;userContext.preferenceInfo.numberFormat.groupPattern&quot;`&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;type User struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; LoginName string `jpath:&quot;loginName&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; NumberFormat&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;docScript := []byte(document)&lt;br /&gt;docMap := map[string]interface{}{}&lt;br /&gt;json.Unmarshal(docScript, &amp;amp;docMap)&lt;br /&gt;&lt;br /&gt;user := User{}&lt;br /&gt;DecodePath(docMap, &amp;amp;user)&lt;br /&gt;&lt;br /&gt;fmt.Printf(&quot;%#v&quot;, user) &lt;/div&gt;&lt;br /&gt;If we run this program we get the following output:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;mapstructure.User{&lt;br /&gt;&amp;nbsp; &amp;nbsp; LoginName:&quot;sptest1&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; NumberFormat:mapstructure.NumberFormat{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; DecimalSeparator:&quot;.&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; GroupingSeparator:&quot;,&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; GroupPattern:&quot;###,##0.##&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;We can also use an anonymous&amp;nbsp;field pointer:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type User struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; LoginName string `jpath:&quot;loginName&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; *NumberFormat&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;In this case DecodePath will instantiate an object of that type and perform the decode, but only if a mapping can be found.&lt;br /&gt;&lt;br /&gt;We now have great control over decoding JSON documents into structs. What happens when the JSON you get back is an array of documents?&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;DecodeSlicePath&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;There are times when the web api returns an array of JSON documents:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;var document = `[{&quot;name&quot;:&quot;bill&quot;},{&quot;name&quot;:&quot;lisa&quot;}]` &lt;/div&gt;&lt;br /&gt;In this case we need to decode the slice of maps into a slice of objects. We added another function called DecodeSlicePath that does just that:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type NameDoc struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; Name string `jpath:&quot;name&quot;`&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;sliceScript := []byte(document)&lt;br /&gt;sliceMap := []map[string]interface{}{}&lt;br /&gt;json.Unmarshal(sliceScript, &amp;amp;sliceMap)&lt;br /&gt;&lt;br /&gt;var myslice []NameDoc&lt;br /&gt;DecodeSlicePath(sliceMap, &amp;amp;myslice)&lt;br /&gt;&lt;br /&gt;fmt.Printf(&quot;%#v&quot;, myslice) &lt;/div&gt;&lt;br /&gt;Here is the output: &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;[]mapstructure.NameDoc{&lt;br /&gt;&amp;nbsp; &amp;nbsp; mapstructure.NameDoc{Name:&quot;bill&quot;},&lt;br /&gt;&amp;nbsp; &amp;nbsp; mapstructure.NameDoc{Name:&quot;lisa&quot;}&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;The function DecodeSlicePath creates the slice based on the length of the map and then decodes each JSON document, one at a time. &lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;If it were not for Mitchell I would not have been able to get this to work. His package is brilliant and handles all the real technical issues around decoding maps into structs. The two functions I have built on top of mapstructure provides a nice convenience factor we needed for our project. If you&#39;re dealing with some of the same issue, please try out the package.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/1319131010712056921/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/01/decode-json-documents-in-go.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/1319131010712056921'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/1319131010712056921'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/01/decode-json-documents-in-go.html' title='Decode JSON Documents In Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-2436560613180939967</id><published>2014-01-16T19:20:00.000-05:00</published><updated>2014-01-22T13:39:57.457-05:00</updated><title type='text'>Be Selected To Attend GopherCon 2014</title><content type='html'>Gopher Academy &lt;a href=&quot;http://blog.gopheracademy.com/scholarship-for-women&quot; target=&quot;_blank&quot;&gt;announced&lt;/a&gt; a great program today.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;Today I&#39;d like to announce the GopherCon Scholarship Program. It&#39;s goal is to increase the visibility of women in the Go community through the most direct path I can imagine: sponsoring their attendance to GopherCon 2014.&lt;/i&gt;&lt;br /&gt;&lt;i&gt;&lt;br /&gt;&lt;/i&gt;The program works by you purchasing one of these special tickets. There will be a selection/nomination process and those woman selected will be able to attend GopherCon thanks to you. It is designed to make GopherCon the most inclusive and welcoming place for all people to get together and learn about Go based technologies.&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://www.outcast.io/&quot; target=&quot;_blank&quot;&gt;OutCast.io&lt;/a&gt;&amp;nbsp;and&amp;nbsp;&lt;a href=&quot;http://www.ardanstudios.com/&quot; target=&quot;_blank&quot;&gt;Ardan Studios&lt;/a&gt;&amp;nbsp;recognizes the need to find ways to engage more women and girls to become technology creators. We have daughters that we would love to see have more opportunity. There is a great organization called &lt;a href=&quot;http://www.chicktech.org/&quot; target=&quot;_blank&quot;&gt;ChickTech&lt;/a&gt;. They are leading the way in creating local programs to get more women and girls involved in technology. ChickTech is dedicated to:&lt;br /&gt;&lt;b&gt;&lt;i&gt;&lt;br /&gt;&lt;/i&gt;&lt;/b&gt;&quot;&lt;i style=&quot;font-weight: bold;&quot;&gt;retaining women in the technology workforce and increasing the number of women and girls pursuing technology-based careers.&quot;&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;If you&#39;re interested, ChickTech is always looking for local mentors and volunteers. They have a way for you to make a difference that fits your schedule and interests. This is a chance for you to give back to the woman and girls in your life, it just takes an email to get started.&lt;br /&gt;&lt;br /&gt;We really&amp;nbsp;want to help and do something special. I will be speaking at &lt;a href=&quot;http://www.gophercon.com/&quot; target=&quot;_blank&quot;&gt;GopherCon 2014&lt;/a&gt; in Denver this April and speakers get their flight and hotel room for free. We wanted to give that to some deserving woman who is passionate about technology and otherwise would not be able to attend the conference.&lt;br /&gt;&lt;br /&gt;If you&#39;re interested in receiving this free trip to GopherCon or want to nominate someone you know, write a post about yourself or that person and why you/they would like to attend GopherCon. You can also write a post about something cool you are doing with Go. Write your post in Google Docs and share it with me at bill@thekennedyclan.net. GoingGo.net will publish your post and we, with the GopherCon team, will select a winner on February 15th.﻿&lt;br /&gt;&lt;br /&gt;We hope to get a great response and are very excited that we can be involved in this great scholarship program. It is important to get more women and girls active in technology and this is a great way to start.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/2436560613180939967/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/01/gophercon-2014-scholarship-for-women.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/2436560613180939967'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/2436560613180939967'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/01/gophercon-2014-scholarship-for-women.html' title='Be Selected To Attend GopherCon 2014'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-485932027969196416</id><published>2014-01-16T11:15:00.000-05:00</published><updated>2014-01-17T09:07:10.825-05:00</updated><title type='text'>Go Package Management For 2014</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;In October 2013 I sent out a call to action to the Go community. I wanted to form a group of Gophers that would come together and help write a specification and build a working implementation of a package management tool. We are not there yet, but the group did accomplish a few things:&lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;We started a mailing list called &lt;a href=&quot;https://groups.google.com/forum/#!forum/go-package-management&quot; target=&quot;_blank&quot;&gt;Go package management&lt;/a&gt; [go-pm] where people could discuss ideas and get feedback on existing and new tools.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;We wrote a &lt;a href=&quot;https://docs.google.com/document/d/1k-3mwBqAdTIKGcilWZPuKSMy3DWtfNRFDs9o98lcwHY&quot; target=&quot;_blank&quot;&gt;goals document&lt;/a&gt; that outlined what we wanted to accomplish along with guidelines and help for package management tool authors.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;We identified and categorized the existing set of tools that are available for use.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;We developed a set of user stories that describe the different scenarios people were facing.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;We started a list of packages that tool developers can use to test their tools against.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;We helped some of the tool developers find and fix bugs.&lt;/li&gt;&lt;/ul&gt;Overall I think the last 3 months have been productive and I am pleased with the results.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Building Tools&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;I have come to appreciate that there isn&#39;t going to be a silver bullet or a one tool fits all solution. I believe a majority of the use-cases that have been defined in the &lt;a href=&quot;https://docs.google.com/document/d/1k-3mwBqAdTIKGcilWZPuKSMy3DWtfNRFDs9o98lcwHY&quot; target=&quot;_blank&quot;&gt;goals document&lt;/a&gt; can be solved and building tools to handle these use-cases is worth the time and effort. If you&#39;re thinking about building a tool, please consider these guidelines which are outlined in the goals document: &lt;br /&gt;&lt;br /&gt;&lt;b&gt;Work with the Go language as defined in the Go 1 spec of March 28, 2012.&lt;/b&gt;&lt;br /&gt;Don’t implement solutions that require feature changes or build tools that change the way Go works.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Provide backwards compatibility with go get and the convention of using VCS repositories in the import paths.&lt;/b&gt;&lt;br /&gt;The existing set of programs, build processes and workflows can’t break. You must respect the existing environments and allow them to continue to function.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Prevent version skewing.&lt;/b&gt;&lt;br /&gt;Don’t build into the solution the potential for version skewing to occur. Such as requiring semantic versioning in the import path urls. Imports should not need to be changed to access the latest or different versions of a package.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Work on all operating systems and architectures that Go currently supports.&lt;/b&gt;&lt;br /&gt;One of the great things about Go is that programs can be built on all these different operating systems and architectures. Your tool should not exclude a platform or make use of a specific operating system construct like symlinks.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Interoperate in such a way that ‘go get’ continues to work for package authors who do not wish to participate, or for existing Go source code that cannot be changed. Also, do not force package authors to choose between making their code go getable or using the proposed solution.&lt;/b&gt;&lt;br /&gt;No one should be required to use a tool in order to share or import a repository. The tooling must continue to work for everyone.&lt;br /&gt;&lt;br /&gt;All these guidelines are important because they will allow others to try and use your tools without the need to refactor any existing code. They also guarantee that existing projects continue to build and install with the Go tooling on all platforms. &lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Choices&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;I would love to see the community rally around a few tools and help improve them. There are two classes of tools that I think work well with Go, Vendoring and Revision Locking. &lt;br /&gt;&lt;br /&gt;&lt;b&gt;Vendoring&lt;/b&gt; takes the 3rd party source code that is referenced in your project and makes a copy of that code inside a new folder within the project. All the code your project needs is inside the one project repository. Vendoring also provides a performance enhancement on getting the code because only one url call is required.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Revision Locking&lt;/b&gt; creates a dependency file that references specific commits in the different version control systems the code is located in. Just like vendoring, the RL tool is used to get, build and install your project. One advantage is that your project repository continues to only contain the specific project code.&lt;br /&gt;&lt;br /&gt;Choosing how to handle package management it is a matter of personal preference. The Go team recommends vendoring, which can be found in the Go &lt;a href=&quot;http://golang.org/doc/faq#get_version&quot; target=&quot;_blank&quot;&gt;FAQ&lt;/a&gt;. They mention Keith Rarick&#39;s tool &lt;a href=&quot;https://github.com/kr/goven&quot; target=&quot;_blank&quot;&gt;goven&lt;/a&gt; as an option. Keith has abandoned** goven for his other tool &lt;a href=&quot;https://github.com/kr/godep&quot; target=&quot;_blank&quot;&gt;godep&lt;/a&gt;, which provides both vendoring and revision locking. &lt;br /&gt;&lt;br /&gt;&lt;i&gt;** After talking with Keith he has stated that he has not totally abandoned goven, it is just &quot;finished&quot;. He continues to maintain the package and merge bug fixes when necessary.&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;New Call To Action&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;For 2014 I would like to see the Go community play a greater role in helping the package management tool authors. There are several ways I think this can be done: &lt;br /&gt;&lt;ul&gt;&lt;li style=&quot;color: black;&quot;&gt;Participate in the &lt;a href=&quot;https://groups.google.com/forum/#!forum/go-package-management&quot; target=&quot;_blank&quot;&gt;go-pm group&lt;/a&gt;. Give advice and help to those who have questions.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;Submit packages that the tool authors can use to help test their tools.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;Report bugs and feature requests.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;Continue to add user stories that are missing in the goals document.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;Submit your new tools and ideas to the go-pm group.&lt;/li&gt;&lt;li style=&quot;color: black;&quot;&gt;Work with the existing tool authors to improve the tools that we have today.&lt;/li&gt;&lt;/ul&gt;I hope to see all of you participating in the go-pm mailing list this year. I love Go and only want to see it improve for everyone.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/485932027969196416/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2014/01/go-package-management-for-2014.html#comment-form' title='1 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/485932027969196416'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/485932027969196416'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2014/01/go-package-management-for-2014.html' title='Go Package Management For 2014'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-557198743267416805</id><published>2013-12-31T19:39:00.000-05:00</published><updated>2015-02-03T20:42:50.148-05:00</updated><title type='text'>Macro View of Map Internals In Go</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;There are lots of posts that talk about the internals of slices, but when it comes to maps, we are left in the dark. I was wondering why and then I found the code for maps and it all made sense.&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;https://golang.org/src/runtime/hashmap.go&quot; target=&quot;_blank&quot;&gt;https://golang.org/src/runtime/hashmap.go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;At least for me, this code is complicated. That being said, I think we can create a macro view of how maps are structured and grow. This should explain why they are unordered, efficient and fast.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Creating and Using Maps&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Let&#39;s look at how we can use a map literal to create a map and store a few values:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;// Create an empty map with a key and value of type string&lt;br /&gt;colors := map[string]string{}&lt;br /&gt;&lt;br /&gt;// Add a few keys/value pairs to the map&lt;br /&gt;colors[&quot;AliceBlue&quot;] = &quot;#F0F8FF&quot;&lt;br /&gt;colors[&quot;Coral&quot;] &amp;nbsp; &amp;nbsp; = &quot;#FF7F50&quot;&lt;br /&gt;colors[&quot;DarkGray&quot;] &amp;nbsp;= &quot;#A9A9A9&quot; &lt;/div&gt;&lt;br /&gt;When we add values to a map, we always specify a key that is associated with the value. This key is used to find this value again without the need to iterate through the entire collection:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;fmt.Printf(&quot;Value: %s&quot;, colors[&quot;Coral&quot;])&lt;/div&gt;&lt;br /&gt;If we do iterate through the map, we will not necessarily get the keys back in the same order. In fact, every time you run the code, the order could change:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;colors := map[string]string{}&lt;br /&gt;colors[&quot;AliceBlue&quot;] &amp;nbsp; = &quot;#F0F8FF&quot;&lt;br /&gt;colors[&quot;Coral&quot;] &amp;nbsp; &amp;nbsp; &amp;nbsp; = &quot;#FF7F50&quot;&lt;br /&gt;colors[&quot;DarkGray&quot;] &amp;nbsp; &amp;nbsp;= &quot;#A9A9A9&quot;&lt;br /&gt;colors[&quot;ForestGreen&quot;] = &quot;#228B22&quot;&lt;br /&gt;colors[&quot;Indigo&quot;] &amp;nbsp; &amp;nbsp; &amp;nbsp;= &quot;#4B0082&quot;&lt;br /&gt;colors[&quot;Lime&quot;] &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;= &quot;#00FF00&quot;&lt;br /&gt;colors[&quot;Navy&quot;] &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;= &quot;#000080&quot;&lt;br /&gt;colors[&quot;Orchid&quot;] &amp;nbsp; &amp;nbsp; &amp;nbsp;= &quot;#DA70D6&quot;&lt;br /&gt;colors[&quot;Salmon&quot;] &amp;nbsp; &amp;nbsp; &amp;nbsp;= &quot;#FA8072&quot;&lt;br /&gt;&lt;br /&gt;for key, value := range colors {&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Printf(&quot;%s:%s, &quot;, key, value)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;Output:&lt;br /&gt;AliceBlue:#F0F8FF, DarkGray:#A9A9A9, Indigo:#4B0082, Coral:#FF7F50,&lt;br /&gt;ForestGreen:#228B22, Lime:#00FF00, Navy:#000080, Orchid:#DA70D6,&lt;br /&gt;Salmon:#FA8072&lt;/div&gt;&lt;br /&gt;Now that we know how to create, set key/value pairs and iterate over a map, we can peek under the hood.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;How Maps Are Structured&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Maps in Go are implemented as a hash table. If you need to learn what a hash table is, there are lots of articles and posts about the subject. This is the Wikipedia page to get you started:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Hash_table&quot; target=&quot;_blank&quot;&gt;http://en.wikipedia.org/wiki/Hash_table&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;The hash table for a Go map is structured as an array of buckets. The number of buckets is always equal to a power of 2. When a map operation is performed, such as (&lt;b&gt;colors[&quot;Black&quot;] = &quot;#000000&quot;)&lt;/b&gt;, a hash key is generated against the key that is specified. In this case the string &quot;Black&quot; is used to generate the hash key. The&amp;nbsp;low order bits (LOB) of the generated hash key is used to select a bucket.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://1.bp.blogspot.com/-oViOhYEG52M/UsNU778YUcI/AAAAAAAANR4/OKxPPhQwmDo/s1600/Screen+Shot+2013-12-31+at+6.35.43+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://1.bp.blogspot.com/-oViOhYEG52M/UsNU778YUcI/AAAAAAAANR4/OKxPPhQwmDo/s640/Screen+Shot+2013-12-31+at+6.35.43+PM.png&quot; height=&quot;124&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;Once a bucket is selected, the key/value pair needs to be stored, removed or looked up, depending on the type of operation. If we look inside any bucket, we will find two data structures. First, there is an array with the top 8 high order bits (HOB) from the same hash key that was used to select the bucket. This array distinguishes each individual key/value pair stored in the respective bucket. Second, there is an array of bytes that store the key/value pairs. The byte array packs all the keys and then all the values together for the respective bucket.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/-Cod-uUUJfyM/UsNa36ufFeI/AAAAAAAANSU/k-a3-k7594g/s1600/Screen+Shot+2013-12-31+at+7.01.15+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-Cod-uUUJfyM/UsNa36ufFeI/AAAAAAAANSU/k-a3-k7594g/s640/Screen+Shot+2013-12-31+at+7.01.15+PM.png&quot; height=&quot;416&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;When we are iterating through a map, the iterator walks through the array of buckets and then return the key/value pairs in the order they are laid out in the byte array. This is why maps are unsorted collections. The hash keys determines the walk order of the map because they determine which buckets each key/value pair will end up in.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Memory and Bucket Overflow&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;There is a reason the key/value pairs are packed like this in a single byte array. If the keys and values were stored like key/value/key/value, padding allocations between each key/value pair would be needed to maintain proper alignment boundaries. An example where this would apply is with a map that looks like this:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;map[int64]int8 &lt;/div&gt;&lt;br /&gt;The 1 byte value in this map would result in 7 extra bytes of padding per key/value pair.&amp;nbsp;By packing the&amp;nbsp;key/value pairs as key/key/value/value, the padding only has to be appended to the end of the byte array and not in between.&amp;nbsp;Eliminating the padding bytes saves the bucket and the map a good amount of memory. To learn more about alignment boundaries, read this post:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://www.goinggo.net/2013/07/understanding-type-in-go.html&quot; target=&quot;_blank&quot;&gt;http://www.goinggo.net/2013/07/understanding-type-in-go.html&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;A bucket is configured to store only 8 key/value pairs. If a ninth key needs to be added to a bucket that is full, an overflow bucket is created and reference from inside the respective bucket.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/-DgyZ53dIqxo/UsNdawR9PsI/AAAAAAAANSg/tiMNkkr6vxU/s1600/Screen+Shot+2013-12-31+at+7.12.06+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-DgyZ53dIqxo/UsNdawR9PsI/AAAAAAAANSg/tiMNkkr6vxU/s640/Screen+Shot+2013-12-31+at+7.12.06+PM.png&quot; height=&quot;202&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;How Maps Grow&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;As we continue to add or remove key/value pairs from the map, the efficiency of the map lookups begin to deteriorate. The load threshold values that determine when to grow the hash table are based on these four factors:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;% overflow &amp;nbsp;: Percentage of buckets which have an overflow bucket&lt;br /&gt;bytes/entry :&amp;nbsp;Number of overhead bytes used per key/value pair&lt;br /&gt;hitprobe &amp;nbsp; &amp;nbsp;:&amp;nbsp;Number of entries that need to be checked when looking up a key&lt;br /&gt;missprobe &amp;nbsp; :&amp;nbsp;Number of entries that need to be checked when looking up an absent key &lt;/div&gt;&lt;br /&gt;Currently, the code uses the following load threshold values:&lt;br /&gt;&lt;br /&gt;&lt;table border=&quot;1&quot; cellpadding=&quot;5&quot; style=&quot;width: 100%;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;LOAD&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;%overflow&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;bytes/entry&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;hitprobe&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;missprobe&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6.50&lt;/td&gt;&lt;td&gt;20.90&lt;/td&gt;&lt;td&gt;10.79&lt;/td&gt;&lt;td&gt;4.25&lt;/td&gt;&lt;td&gt;6.50&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br /&gt;Growing the hash table starts with assigning a pointer called the &quot;old bucket&quot; pointer to the current bucket array. Then a new bucket array is allocated to hold twice the number of existing buckets. This could result in large allocations, but the memory is not initialized so the allocation is fast.&lt;br /&gt;&lt;br /&gt;Once the memory for the new bucket array is available, the key/value pairs from the old bucket array can be moved or &quot;evacuated&quot; to the new bucket array. Evacuations happen as key/value pairs are added or removed from the map. The key/value pairs that are together in an old bucket could be moved to different buckets inside the new bucket array. The evacuation algorithm attempts to distribute the key/value pairs evenly across the new bucket array.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://2.bp.blogspot.com/-FcohbDEo8PI/UsNf35ZiDZI/AAAAAAAANSs/XBN_wbBlsYs/s1600/Screen+Shot+2013-12-31+at+7.22.39+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://2.bp.blogspot.com/-FcohbDEo8PI/UsNf35ZiDZI/AAAAAAAANSs/XBN_wbBlsYs/s640/Screen+Shot+2013-12-31+at+7.22.39+PM.png&quot; height=&quot;250&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;/div&gt;This is a very delicate dance because iterators still need to run through the old buckets until every old bucket has been evacuated. This also affects how key/value pairs are returned during iteration operations. A lot of care has been taken to make sure iterators work as the map grows and expands.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;As I stated in the beginning, this is just a macro view of how maps are structured and grow. The code is written in C and performs a lot of memory and pointer manipulation to keep things fast, efficient and safe.&lt;br /&gt;&lt;br /&gt;Obviously, this implementation can be changed at any time and having this understanding doesn&#39;t affect our ability, one way or the other, to use maps. It does show that if you know how many keys you need ahead of time, it is best to allocated that space during initialization. It also explains why maps are unsorted collections and why iterators seem random when walking through maps.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Special Thanks&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;I would like to thank Stephen McQuay and Keith Randall for their review, input and corrections for the post.&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/557198743267416805/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2013/12/macro-view-of-map-internals-in-go.html#comment-form' title='4 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/557198743267416805'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/557198743267416805'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2013/12/macro-view-of-map-internals-in-go.html' title='Macro View of Map Internals In Go'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://1.bp.blogspot.com/-oViOhYEG52M/UsNU778YUcI/AAAAAAAANR4/OKxPPhQwmDo/s72-c/Screen+Shot+2013-12-31+at+6.35.43+PM.png" height="72" width="72"/><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-4325301115831693055</id><published>2013-12-20T15:30:00.000-05:00</published><updated>2013-12-23T21:08:09.067-05:00</updated><title type='text'>Queue Your Way To Scalability</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The first thing I did when I started programming in Go was begin porting my Windows utilities classes and service frameworks over to Linux. This is what I did when I moved from C++ to C#. Thank goodness, I soon learned about &lt;a href=&quot;http://www.iron.io/&quot; target=&quot;_blank&quot;&gt;Iron.IO&lt;/a&gt; and the services they offered. Then it hit me, if I wanted true scalability, I needed to start building worker tasks that could be queued to run anywhere at any time. It was not about how many machines I needed, it was about how much compute time I needed.&lt;br /&gt;&lt;br /&gt;&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;tr-caption-container&quot; style=&quot;float: right; margin-left: 1em; text-align: right;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;&quot;&gt;&lt;a href=&quot;http://www.outcast.io/&quot; target=&quot;_blank&quot;&gt;&lt;img border=&quot;0&quot; height=&quot;320&quot; src=&quot;http://1.bp.blogspot.com/-1O5BR9TS4bs/Urbe8C5aaGI/AAAAAAAANMI/6GbvP7Df0oo/s320/photo.PNG&quot; width=&quot;180&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;tr-caption&quot; style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.outcast.io/&quot; target=&quot;_blank&quot;&gt;Outcast Marine Forecast&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;The freedom that comes with architecting a solution around web services and worker tasks is refreshing. If I need 1,000 instances of a task to run, I can just queue it up. I don&#39;t need to worry about capacity, resources, or any other IT related issues. If my service becomes an instant hit overnight, the architecture is ready, the capacity is available.&lt;br /&gt;&lt;br /&gt;My mobile weather application &lt;a href=&quot;http://www.outcast.io/&quot; target=&quot;_blank&quot;&gt;Outcast&lt;/a&gt; is a prime example. I currently have a single scheduled task that runs in Iron.IO every 10 minutes. This task updates marine forecast areas for the United States and downloads and parses 472 web pages from the NOAA website. We are about to add Canada and eventually we want to move into Europe and Australia. At that point a single scheduled task is not a scalable or redundant architecture for this process.&lt;br /&gt;&lt;br /&gt;Thanks to the &lt;a href=&quot;https://github.com/iron-io/iron_go&quot; target=&quot;_blank&quot;&gt;Go Client&lt;/a&gt;&amp;nbsp;from Iron.IO, I can build a task that wakes up on a schedule and queues up as many marine forecast area worker tasks as needed. I can use this architecture to process each marine forecast area independently, in their own worker task, providing incredible scalability and redundancy. The best part, I don&#39;t have to think about hardware or IT related capacity issues.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Create a Worker Task&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Back in September I wrote a post about building and uploading an Iron.IO worker task using Go:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://www.goinggo.net/2013/09/running-go-programs-in-ironworker.html&quot; target=&quot;_blank&quot;&gt;http://www.goinggo.net/2013/09/running-go-programs-in-ironworker.html&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;This task simulated 60 seconds of work and ran experiments to understand some of the capabilities of the worker task container. We are going to use this worker task to demonstrate how to use the Go Client to queue a task. If you want to follow along, go ahead and walk through the post and create the worker task.&lt;br /&gt;&lt;br /&gt;I am going to assume you walked through the post and created the worker called &quot;task&quot; as depicted in the image below:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://4.bp.blogspot.com/-6IxgoVvaDbc/Ui0NYLBSl6I/AAAAAAAAM20/_JDyJSuQRLY/s640/Screen+Shot+2013-09-08+at+7.50.29+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em; text-align: center;&quot;&gt;&lt;img border=&quot;0&quot; height=&quot;164&quot; src=&quot;http://4.bp.blogspot.com/-6IxgoVvaDbc/Ui0NYLBSl6I/AAAAAAAAM20/_JDyJSuQRLY/s640/Screen+Shot+2013-09-08+at+7.50.29+PM.png&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Download The Go Client&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Download the &lt;a href=&quot;https://github.com/iron-io/iron_go&quot; target=&quot;_blank&quot;&gt;Go Client&lt;/a&gt;&amp;nbsp;from Iron.IO:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;go get github.com/iron-io/iron_go &lt;/div&gt;&lt;br /&gt;Now navigate to the examples folder:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://2.bp.blogspot.com/-wwRuukh9a9E/UrSLUS-QzuI/AAAAAAAANLM/b4hGLpQd-wg/s1600/Screen+Shot+2013-12-20+at+1.23.58+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;clear: left; float: left; margin-bottom: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; height=&quot;193&quot; src=&quot;http://2.bp.blogspot.com/-wwRuukh9a9E/UrSLUS-QzuI/AAAAAAAANLM/b4hGLpQd-wg/s200/Screen+Shot+2013-12-20+at+1.23.58+PM.png&quot; width=&quot;200&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The examples leverage the API that can be found here:&lt;br /&gt;&lt;a href=&quot;http://dev.iron.io/worker/reference/api/&quot; target=&quot;_blank&quot;&gt;http://dev.iron.io/worker/reference/api/&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Not all the API calls are represented in these examples, but from these examples the rest of the API can be easily implemented.&lt;br /&gt;&lt;br /&gt;In this post we are going to focus on the task API calls. These are API&#39;s that you will most likely be able to leverage in your own programs and architectures. &lt;br /&gt;&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Queue a Task&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Open up the queue example from the examples/tasks folder. We will walk through the more important aspects of the code.&lt;br /&gt;&lt;br /&gt;In order to queue a task with the Go client, we need to create this document which will be posted with the request:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;tasks&quot;: [&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;code_name&quot;: &quot;MyWorker&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;timeout&quot; : 60,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;payload&quot;: &quot;{\&quot;x\&quot;: \&quot;abc\&quot;, \&quot;y\&quot;: \&quot;def\&quot;}&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; ]&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;In the case of our worker task, the payload document in Go should look like this:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;var payload = `{&quot;tasks&quot;:[&lt;br /&gt;{&lt;br /&gt;&amp;nbsp; &quot;code_name&quot; : &quot;&lt;b&gt;task&lt;/b&gt;&quot;,&lt;br /&gt;&amp;nbsp; &quot;timeout&quot; : &lt;b&gt;120&lt;/b&gt;,&lt;br /&gt;&amp;nbsp; &quot;payload&quot; : &quot;&quot;&lt;br /&gt;}]}` &lt;/div&gt;&lt;br /&gt;Now let&#39;s look at the code that will request our task to be queued. The first thing we need to do is set our project id and token.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;config := config.Config(&quot;iron_worker&quot;)&lt;br /&gt;config.ProjectId = &quot;your_project_id&quot;&lt;br /&gt;config.Token = &quot;your_token&quot; &lt;/div&gt;&lt;br /&gt;As described in the post from September, this information can be found inside our project configuration:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://1.bp.blogspot.com/-IZMVVKhb4TY/UitNaTY7nvI/AAAAAAAAMyQ/qw2pp94Co_I/s640/Screen+Shot+2013-09-07+at+11.59.12+AM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; height=&quot;385&quot; src=&quot;http://1.bp.blogspot.com/-IZMVVKhb4TY/UitNaTY7nvI/AAAAAAAAMyQ/qw2pp94Co_I/s640/Screen+Shot+2013-09-07+at+11.59.12+AM.png&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;Now we can use the Go Client to build the url and prepare the payload for the request:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;url := api.ActionEndpoint(config, &quot;tasks&quot;)&lt;br /&gt;postData := bytes.NewBufferString(payload) &lt;/div&gt;&lt;br /&gt;Using the url object, we can send the request to Iron.IO and capture the response:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;resp, err := url.Request(&quot;POST&quot;, postData)&lt;br /&gt;defer resp.Body.Close()&lt;br /&gt;if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; log.Println(err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; return&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;body, err := ioutil.ReadAll(resp.Body)&lt;br /&gt;if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; log.Println(err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; return&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;We want to check the response to make sure everything was successful. This is the response we will get back:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;msg&quot;: &quot;Queued up&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;tasks&quot;: [&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;id&quot;: &quot;4eb1b471cddb136065000010&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; ]&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;To unmarshal the result, we need these data structures:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type (&lt;br /&gt;&amp;nbsp; &amp;nbsp; TaskResponse struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Message string `json:&quot;msg&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Tasks &amp;nbsp; []Task `json:&quot;tasks&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; Task struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Id string `json:&quot;id&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;) &lt;/div&gt;&lt;br /&gt;Now let&#39;s unmarshal the results:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;taskResponse := &amp;amp;TaskResponse{}&lt;br /&gt;err = json.Unmarshal(body, taskResponse)&lt;br /&gt;if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; log.Printf(&quot;%v\n&quot;, err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; return&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;If we want to use a map instead to reduce the code base, we can do this:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;results := map[string]interface{}{}&lt;br /&gt;err = json.Unmarshal(body, &amp;amp;results)&lt;br /&gt;if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; log.Printf(&quot;%v\n&quot;, err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; return&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;When we run the example code and everything works, we should see the following output:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Url: https://worker-aws-us-east-1.iron.io:443/2/projects/522b4c518a0c960009000007/tasks&lt;br /&gt;&lt;br /&gt;&quot;msg&quot;: Queued up&lt;br /&gt;{&lt;br /&gt;&amp;nbsp; &amp;nbsp; &quot;id&quot;: &quot;52b4721726d9410296012cc8&quot;,&lt;br /&gt;}, &lt;/div&gt;&lt;br /&gt;If we navigate to the Iron.IO HUD, we should see the task was queued and completed successfully:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://1.bp.blogspot.com/-AYxpRShtTq4/UrSbuQbSelI/AAAAAAAANLc/CrGqKgbFHs4/s1600/Screen+Shot+2013-12-20+at+2.33.30+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://1.bp.blogspot.com/-AYxpRShtTq4/UrSbuQbSelI/AAAAAAAANLc/CrGqKgbFHs4/s640/Screen+Shot+2013-12-20+at+2.33.30+PM.png&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The Go client is doing a lot of the boilerplate work for us behind the scenes. We just need to make sure we have all the configuration parameters that are required. Queuing a task is one of the more complicated API calls. Look at the other examples to see how to get information for the tasks we queue and even get the logs.&lt;br /&gt;&lt;br /&gt;Queuing a task like this gives you the flexibility to schedule work on specific intervals or based on events. There are a lot of use cases where different types of web requests could leverage queuing a task. Leveraging this type of architecture provides a nice separation of concerns with scalability and redundancy built in. It keeps our web applications focused and optimized for handling user requests and pushes the asynchronous and background tasks to a cloud environment designed and architected to handle things at scale.&lt;br /&gt;&lt;br /&gt;As Outcast grows we will continue to leverage all the services that Iron.IO and the cloud has to offer. &amp;nbsp;There is a lot of data that needs to be downloaded, processing and then delivered to users through the mobile application. By building a scalable architecture today, we can handle what happens tomorrow.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/4325301115831693055/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2013/12/queue-your-way-to-scalability.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/4325301115831693055'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/4325301115831693055'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2013/12/queue-your-way-to-scalability.html' title='Queue Your Way To Scalability'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://1.bp.blogspot.com/-1O5BR9TS4bs/Urbe8C5aaGI/AAAAAAAANMI/6GbvP7Df0oo/s72-c/photo.PNG" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-5239519374669728372</id><published>2013-12-17T14:22:00.000-05:00</published><updated>2013-12-23T18:48:14.827-05:00</updated><title type='text'>Three-Index Slices in Go 1.2</title><content type='html'>With the release of Go 1.2, slices gained the ability to specify the capacity when performing a slicing operation. This doesn&#39;t mean we can use this index to extend the capacity of the underlying array. It means we can create a new slice whose capacity is restricted. Restricting the capacity provides a level of protection to the underlying array and gives us more control over append operations.&lt;br /&gt;&lt;br /&gt;Here are the release notes and design document for the feature request:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://tip.golang.org/doc/go1.2#three_index&quot; target=&quot;_blank&quot;&gt;http://tip.golang.org/doc/go1.2#three_index&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://docs.google.com/document/d/1GKKdiGYAghXRxC2BFrSEbHBZZgAGKQ-yXK-hRKBo0Kk/pub&quot; target=&quot;_blank&quot;&gt;https://docs.google.com/document/d/1GKKdiGYAghXRxC2BFrSEbHBZZgAGKQ-yXK-hRKBo0Kk/pub&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Let&#39;s write some code to explore using the new capacity index. As with all my slice posts, I am going to use this InspectSlice function:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func InspectSlice(slice []string) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Capture the address to the slice structure&lt;br /&gt;&amp;nbsp; &amp;nbsp; address := unsafe.Pointer(&amp;amp;slice)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Capture the address where the length and cap size is stored&lt;br /&gt;&amp;nbsp; &amp;nbsp; lenAddr := uintptr(address) + uintptr(8)&lt;br /&gt;&amp;nbsp; &amp;nbsp; capAddr := uintptr(address) + uintptr(16)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Create pointers to the length and cap size&lt;br /&gt;&amp;nbsp; &amp;nbsp; lenPtr := (*int)(unsafe.Pointer(lenAddr))&lt;br /&gt;&amp;nbsp; &amp;nbsp; capPtr := (*int)(unsafe.Pointer(capAddr))&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Create a pointer to the underlying array&lt;br /&gt;&amp;nbsp; &amp;nbsp; addPtr := (*[8]string)(unsafe.Pointer(*(*uintptr)(address)))&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Printf(&quot;Slice Addr[%p] Len Addr[0x%x] Cap Addr[0x%x]\n&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; address,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; lenAddr,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; capAddr)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Printf(&quot;Slice Length[%d] Cap[%d]\n&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; *lenPtr,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; *capPtr)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; for index := 0; index &amp;lt; *lenPtr; index++ {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&quot;[%d] %p %s\n&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; index,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;amp;(*addPtr)[index],&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (*addPtr)[index])&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Printf(&quot;\n\n&quot;)&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;To start, let&#39;s create a slice we will use as our source:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;source := []string{&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &quot;Banana&quot;, &quot;Grape&quot;}&lt;br /&gt;InspectSlice(source)&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Output:&lt;br /&gt;Slice Addr[0x210231000] Len Addr[0x210231008] Cap Addr[0x210231010]&lt;br /&gt;Slice Length[5] Cap[5]&lt;br /&gt;[0] 0x21020e140 Apple&lt;br /&gt;[1] 0x21020e150 Orange&lt;br /&gt;&lt;b&gt;[2] 0x21020e160 Plum&lt;/b&gt;&lt;br /&gt;[3] 0x21020e170 Banana&lt;br /&gt;[4] 0x21020e180 Grape &lt;/div&gt;&lt;br /&gt;We start with a slice of strings with a length and capacity of 5. This means the underlying array has 5 elements and we have access to the entire array.&lt;br /&gt;&lt;br /&gt;Next, let&#39;s take a traditional slice of the &lt;i&gt;&lt;b&gt;source&lt;/b&gt;&lt;/i&gt; and inspect the contents:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;takeOne := source[2:3]&lt;br /&gt;InspectSlice(takeOne)&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Output:&lt;br /&gt;Slice Addr[0x210231040] Len Addr[0x210231048] Cap Addr[0x210231050]&lt;br /&gt;Slice Length[1] Cap[3]&lt;br /&gt;&lt;b&gt;[0] 0x21020e160 Plum &lt;/b&gt;&lt;/div&gt;&lt;br /&gt;With this slice operation we only take the third element from the &lt;i&gt;&lt;b&gt;source&lt;/b&gt;&lt;/i&gt;. You can see the first element of the &lt;i&gt;&lt;b&gt;takeOne&lt;/b&gt;&lt;/i&gt; slice has the same address as the third element of the &lt;i&gt;&lt;b&gt;source&lt;/b&gt;&lt;/i&gt; slice. The &lt;i&gt;&lt;b&gt;takeOne&lt;/b&gt;&lt;/i&gt;&amp;nbsp;slice has a length of one and a capacity of three. This is because there are three elements left in the underlying array that are available for use.&lt;br /&gt;&lt;br /&gt;What if we didn&#39;t want the new slice to have access to the remaining capacity? Prior to version 1.2, this was not possible. Let&#39;s take the slice again, but this time restrict the capacity to one:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;takeOneCapOne := source[2:3:3] &amp;nbsp;// Use the third index position to&lt;br /&gt;InspectSlice(takeOneCapOne) &amp;nbsp; &amp;nbsp; // set the capacity&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Output:&lt;br /&gt;Slice Addr[0x210231060] Len Addr[0x210231068] Cap Addr[0x210231070]&lt;br /&gt;Slice Length[1] Cap[1]&lt;br /&gt;[0] 0x21020e160 Plum &lt;/div&gt;&lt;br /&gt;After creating the &lt;i&gt;&lt;b&gt;takeOneCapOne&lt;/b&gt;&lt;/i&gt; slice, the length and capacity are now one. The&amp;nbsp;&lt;i&gt;&lt;b&gt;takeOneCapOne&lt;/b&gt;&lt;/i&gt;&amp;nbsp;slice no longer has access to the remaining capacity in the underlying array.&lt;br /&gt;&lt;br /&gt;Length and capacity is calculated using this formula:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;For slice[ i : j : k ] the&lt;br /&gt;&lt;br /&gt;Length: &amp;nbsp; j - i&lt;br /&gt;Capacity: k - i &lt;/div&gt;&lt;br /&gt;If we attempt to set the capacity greater than the underlying array, the code will panic.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;takeOneCapFour := source[2:3:6] &amp;nbsp;// (6 - 2) attempts to set the capacity&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// to 4. This is greater than what is&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// available.&lt;br /&gt;&lt;br /&gt;Runtime Error:&lt;br /&gt;panic: runtime error: slice bounds out of range&lt;br /&gt;&lt;br /&gt;goroutine 1 [running]:&lt;br /&gt;runtime.panic(0x9ad20, 0x1649ea)&lt;br /&gt;&amp;nbsp; &amp;nbsp; /Users/bill/go/src/pkg/runtime/panic.c:266 +0xb6&lt;br /&gt;main.main()&lt;br /&gt;&amp;nbsp; &amp;nbsp; /Users/bill/Spaces/Test/src/test/main.go:15 +0x24f&lt;/div&gt;&lt;br /&gt;So what happens if we append an element to the&amp;nbsp;&lt;i&gt;&lt;b&gt;takeOneCapOne&lt;/b&gt;&lt;/i&gt;&amp;nbsp;slice?&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;source := []string{&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &quot;Banana&quot;, &quot;Grape&quot;}&lt;br /&gt;InspectSlice(source)&lt;br /&gt;&lt;br /&gt;takeOneCapOne := source[2:3:3]&lt;br /&gt;InspectSlice(takeOneCapOne)&lt;br /&gt;&lt;br /&gt;takeOneCapOne = append(takeOneCapOne, &quot;Kiwi&quot;)&lt;br /&gt;InspectSlice(takeOneCapOne) &lt;/div&gt;&lt;br /&gt;Here is the output:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Slice Addr[0x210231000] Len Addr[0x210231008] Cap Addr[0x210231010]&lt;br /&gt;Slice Length[5] Cap[5]&lt;br /&gt;[0] 0x21020e140 Apple&lt;br /&gt;[1] 0x21020e150 Orange&lt;br /&gt;&lt;b&gt;[2] 0x21020e160 Plum&lt;/b&gt;&lt;br /&gt;[3] 0x21020e170 Banana&lt;br /&gt;[4] 0x21020e180 Grape&lt;br /&gt;&lt;br /&gt;-- Before Append --&lt;br /&gt;&lt;br /&gt;Slice Addr[0x210231040] Len Addr[0x210231048] Cap Addr[0x210231050]&lt;br /&gt;Slice Length[1] Cap[1]&lt;br /&gt;&lt;b&gt;[0] 0x21020e160 Plum&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;-- After Append --&lt;br /&gt;&lt;br /&gt;Slice Addr[0x210231080] Len Addr[0x210231088] Cap Addr[0x210231090]&lt;br /&gt;Slice Length[2] Cap[2]&lt;br /&gt;&lt;b&gt;[0] 0x210231060 Plum&lt;/b&gt;&lt;br /&gt;[1] 0x210231070 Kiwi &lt;/div&gt;&lt;br /&gt;When we append an element to the&amp;nbsp;&lt;i&gt;&lt;b&gt;takeOneCapOne&lt;/b&gt;&lt;/i&gt;&amp;nbsp;slice, a new underlying array is created for the slice. This new underlying array contains a copy of the elements being referenced from the &lt;i&gt;&lt;b&gt;source&lt;/b&gt;&lt;/i&gt; and then is extended to add the new element. This is because the capacity of the&amp;nbsp;&lt;i&gt;&lt;b&gt;takeOneCapOne&lt;/b&gt;&lt;/i&gt;&amp;nbsp;slice was reached and append needed to grow the capacity. Notice how the address changes in the&amp;nbsp;&lt;i&gt;&lt;b&gt;takeOneCapOne&lt;/b&gt;&lt;/i&gt;&amp;nbsp;slice after the append.&lt;br /&gt;&lt;br /&gt;How is this different from not setting the capacity?&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;source := []string{&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &quot;Banana&quot;, &quot;Grape&quot;}&lt;br /&gt;InspectSlice(source)&lt;br /&gt;&lt;br /&gt;&lt;b&gt;takeOne := source[2:3] &amp;nbsp;// Don&#39;t specify capacity&lt;/b&gt;&lt;br /&gt;InspectSlice(takeOne)&lt;br /&gt;&lt;br /&gt;takeOne = append(takeOne, &quot;Kiwi&quot;)&lt;br /&gt;InspectSlice(takeOne)&lt;br /&gt;&lt;br /&gt;InspectSlice(source)&lt;/div&gt;&lt;br /&gt;Here is the output:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Slice Addr[0x210231000] Len Addr[0x210231008] Cap Addr[0x210231010]&lt;br /&gt;Slice Length[5] Cap[5]&lt;br /&gt;[0] 0x21020e140 Apple&lt;br /&gt;[1] 0x21020e150 Orange&lt;br /&gt;&lt;b&gt;[2] 0x21020e160 Plum&lt;/b&gt;&lt;br /&gt;&lt;b&gt;[3] 0x21020e170 Banana&lt;/b&gt;&lt;br /&gt;[4] 0x21020e180 Grape&lt;br /&gt;&lt;br /&gt;-- Before Append --&lt;br /&gt;&lt;br /&gt;Slice Addr[0x210231040] Len Addr[0x210231048] Cap Addr[0x210231050]&lt;br /&gt;Slice Length[1] Cap[3]&lt;br /&gt;&lt;b&gt;[0] 0x21020e160 Plum&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;-- After Append --&lt;br /&gt;&lt;br /&gt;Slice Addr[0x210231060] Len Addr[0x210231068] Cap Addr[0x210231070]&lt;br /&gt;Slice Length[2] Cap[3]&lt;br /&gt;&lt;b&gt;[0] 0x21020e160 Plum&lt;/b&gt;&lt;br /&gt;&lt;b&gt;[1] 0x21020e170 Kiwi&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Slice Addr[0x210231080] Len Addr[0x210231088] Cap Addr[0x210231090]&lt;br /&gt;Slice Length[5] Cap[5]&lt;br /&gt;[0] 0x21020e140 Apple&lt;br /&gt;[1] 0x21020e150 Orange&lt;br /&gt;&lt;b&gt;[2] 0x21020e160 Plum&lt;/b&gt;&lt;br /&gt;&lt;b&gt;[3] 0x21020e170 Kiwi&lt;/b&gt;&lt;br /&gt;[4] 0x21020e180 Grape &lt;/div&gt;&lt;br /&gt;This time the append uses the existing capacity and overwrites the value at element 4 in the underlying array. This could be a disaster if this was not our intent.&lt;br /&gt;&lt;br /&gt;This new feature of setting the capacity can really help protect us and our data from unwanted overwrites. The more we can leverage the built-in functions and runtime to handle these types of operations the better. These types of bugs are very difficult to find so this is going to help immeasurably.&lt;br /&gt;&lt;br /&gt;Here are other posts about slices:&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;http://www.goinggo.net/2013/08/understanding-slices-in-go-programming.html&quot; target=&quot;_blank&quot;&gt;Understanding Slices In Go Programming&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://www.goinggo.net/2013/08/collections-of-unknown-length-in-go.html&quot; target=&quot;_blank&quot;&gt;Collections Of Unknown Length In Go&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://www.goinggo.net/2013/09/slices-of-slices-of-slices-in-go.html&quot; target=&quot;_blank&quot;&gt;Slices Of Slices Of Slices In Go&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;http://www.goinggo.net/2013/09/iterating-over-slices-in-go.html&quot; target=&quot;_blank&quot;&gt;Iterating Over Slices In Go&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/5239519374669728372/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2013/12/three-index-slices-in-go-12.html#comment-form' title='4 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/5239519374669728372'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/5239519374669728372'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2013/12/three-index-slices-in-go-12.html' title='Three-Index Slices in Go 1.2'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-6298089572270107210.post-4403044012444977298</id><published>2013-12-11T18:27:00.000-05:00</published><updated>2014-03-07T09:38:17.412-05:00</updated><title type='text'>Sample Web Application Using Beego and Mgo</title><content type='html'>&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Introduction&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;I am very excited about the Beego web framework. I wanted to share with you how I use the framework to build real world web sites and web services. Here is a picture of the sample website the post is going to showcase:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://2.bp.blogspot.com/-Hjmz_0kp3CQ/UvaxtPf0eaI/AAAAAAAANWg/6GKEXPsfgzM/s1600/Screen+Shot+2014-02-08+at+5.37.01+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://2.bp.blogspot.com/-Hjmz_0kp3CQ/UvaxtPf0eaI/AAAAAAAANWg/6GKEXPsfgzM/s1600/Screen+Shot+2014-02-08+at+5.37.01+PM.png&quot; height=&quot;222&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The sample web application:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;Implements a traditional grid view of data calling into MongoDB&lt;/li&gt;&lt;li&gt;Provides a modal dialog box to view details using a partial view to generate the HTML&lt;/li&gt;&lt;li&gt;Implements a web service that returns a JSON document&lt;/li&gt;&lt;li&gt;Takes configuration parameters from the environment using &lt;a href=&quot;https://github.com/kelseyhightower/envconfig&quot; target=&quot;_blank&quot;&gt;envconfig&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Implements tests via &lt;a href=&quot;http://smartystreets.github.io/goconvey/&quot; target=&quot;_blank&quot;&gt;goconvey&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Leverages my &lt;a href=&quot;https://github.com/goinggo/tracelog&quot; target=&quot;_blank&quot;&gt;logging&lt;/a&gt; package&lt;/li&gt;&lt;/ol&gt;The code for the sample can be found in the GoingGo repository up on Github:&lt;br /&gt;&lt;a href=&quot;https://github.com/goinggo/beego-mgo&quot; target=&quot;_blank&quot;&gt;https://github.com/goinggo/beego-mgo&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;You can bring the code down and run it. It uses a public MongoDB database I created at MongoLab. You will need &lt;a href=&quot;https://help.github.com/articles/set-up-git&quot; target=&quot;_blank&quot;&gt;git&lt;/a&gt; and &lt;a href=&quot;http://bazaar.canonical.com/en/&quot; target=&quot;_blank&quot;&gt;bazaar&lt;/a&gt; installed on your system before running go get.&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;go get github.com/goinggo/beego-mgo&lt;/div&gt;&lt;br /&gt;To quickly run or test the web application, use the scripts located in the zscripts folder.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Web Application Code Structure&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Let&#39;s take a look at the project structure and the different folders that exist: &lt;br /&gt;&lt;br /&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;controllers&lt;/td&gt;&lt;td&gt;Entry point for each Web call. Controllers process the requests.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;localize&lt;/td&gt;&lt;td&gt;Provides localization support for different languages and cultures&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;models&lt;/td&gt;&lt;td&gt;Models are data structures used by the business and service layers&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;routes&lt;/td&gt;&lt;td&gt;Mappings between URL&#39;s and the controller code that handles those calls.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;services&lt;/td&gt;&lt;td&gt;Services provide primitive functions for the different services that exist. These could be database or web calls that perform a specific function.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;static&lt;/td&gt;&lt;td&gt;Resource files such as scripts, stylesheets and images&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;test&lt;/td&gt;&lt;td&gt;Tests that can be run through the go test tool.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;utilities&lt;/td&gt;&lt;td&gt;Code that supports the web application. Boilerplate and abstraction layers for accessing the database and handling panics.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;views&lt;/td&gt;&lt;td&gt;Code related to rendering views&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;zscripts&lt;/td&gt;&lt;td&gt;Support scripts to help make it easier to build, run and test the web application&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Controllers, Models and Services&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;These layers make up the bulk of the code that implement the web application. The idea behind the framework is to hide and abstract as much boilerplate code as possible. This is accomplished by implementing a base controller package and a base services package.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;Base Controller Package&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The base controller package uses composition to abstract default controller behavior required by all controllers:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type (&lt;br /&gt;&amp;nbsp; &amp;nbsp; BaseController struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; beego.Controller&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; services.Service&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;func (this *BaseController) Prepare() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.UserId = this.GetString(&quot;userId&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; if this.UserId == &quot;&quot; {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.UserId = this.GetString(&quot;:userId&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; err := this.Service.Prepare()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.ServeError(err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;func (this *BaseController) Finish() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; defer func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if this.MongoSession != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mongo.CloseSession(this.UserId, this.MongoSession)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.MongoSession = nil&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; }()&lt;br /&gt;}&lt;/div&gt;&lt;br /&gt;A new type called BaseController is declared with the Beego Controller type and the base Service type embedded directly. This composes the fields and methods of these types directly into the BaseController type and makes them directly accessible through an object of the BaseController type.&lt;br /&gt;&lt;br /&gt;Beego Controller framework will execute the Prepare and Finish functions on any Controller object that implements these interfaces. The Prepare function is executed prior to the Controller function being called. These functions will belong to every Controller type&amp;nbsp;by default, allowing this boilerplate code to be implemented once.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;Services Package&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The Service package maintains state and implements boilerplate code required by all services:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;type (&lt;br /&gt;&amp;nbsp; &amp;nbsp; // Services contains common properties&lt;br /&gt;&amp;nbsp; &amp;nbsp; Service struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; MongoSession *mgo.Session&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; UserId       string&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;func (this *Service) Prepare() (err error) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.MongoSession, err = mongo.CopyMonotonicSession(this.UserId)&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return err&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; return err&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;func (this *Service) Finish() (err error) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; defer helper.CatchPanic(&amp;amp;err, this.UserId, &quot;Service.Finish&quot;)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; if this.MongoSession != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mongo.CloseSession(this.UserId, this.MongoSession)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.MongoSession = nil&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; return err&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;func (this *Service) DBAction(databaseName string, collectionName string, mongoCall mongo.MongoCall) (err error) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; return mongo.Execute(this.UserId, this.MongoSession, databaseName, collectionName, mongoCall)&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;In the Service type, the Mongo session and the id of the user is maintained.&amp;nbsp;This version of Prepare handles creating a MongoDB session for use. Finish closes the session which releases the underlying connection back into the pool.&amp;nbsp;&amp;nbsp;The function DBAction provides an abstraction layer for running MongoDB commands and queries.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;Buoy Service&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;This Buoy Service package implements the calls to MongoDB. Let&#39;s look at the FindStation function that is called by the controller methods:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func FindStation(service *services.Service, stationId string) (buoyStation *buoyModels.BuoyStation, err error) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; defer helper.CatchPanic(&amp;amp;err, service.UserId, &quot;FindStation&quot;)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; queryMap := bson.M{&quot;station_id&quot;: stationId}&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; buoyStation = &amp;amp;buoyModels.BuoyStation{}&lt;br /&gt;&amp;nbsp; &amp;nbsp; err = service.DBAction(Config.Database, &quot;buoy_stations&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; func(collection *mgo.Collection) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return collection.Find(queryMap).One(buoyStation)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; })&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if strings.Contains(err.Error(), &quot;not found&quot;) == false {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return buoyStation, err&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; err = nil&lt;br /&gt;&amp;nbsp; &amp;nbsp; } &lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; return buoyStation, err&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;The FindStation function prepares the query and then using the DBAction function to execute the query against MongoDB.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Implementing Web Calls&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;With the base types, boilerplate code and service functionality in place, we can now implement the web calls.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;Buoy Controller&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;The BuoyController type is composed solely from the BaseController. By composing the BuoyController in this way, it immediately satisfies the Prepare and Finish interfaces and contains all the fields of a Beego Controller.&lt;br /&gt;&lt;br /&gt;The controller functions are bound to routes. The routes specify the urls to the different web calls that the application supports. In our sample application we have three routes:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;beego.Router(&quot;/&quot;, &amp;amp;controllers.BuoyController{}, &quot;get:Index&quot;)&lt;br /&gt;beego.Router(&quot;/buoy/retrievestation&quot;, &amp;amp;controllers.BuoyController{}, &quot;post:RetrieveStation&quot;)&lt;br /&gt;beego.Router(&quot;/buoy/station/:stationId&quot;, &amp;amp;controllers.BuoyController{}, &quot;get,post:RetrieveStationJson&quot;)&lt;/div&gt;&lt;br /&gt;The route specifies a url path, an instance of the controller used to handle the call and the name of the method from the controller to use. A prefix of which verb is accepted can be specified as well.&lt;br /&gt;&lt;br /&gt;The Index controller method is used to deliver the initial html to the browser. This will include the javascript, style sheets and anything else needed to get the web application going:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func (this *BuoyController) Index() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; region := &quot;Gulf Of Mexico&quot;&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; buoyStations, err := buoyService.FindRegion(&amp;amp;this.Service, region)&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.ServeError(err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.Data[&quot;Stations&quot;] = buoyStations&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.Layout = &quot;shared/basic-layout.html&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.TplNames = &quot;buoy/content.html&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.LayoutSections = map[string]string{}&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.LayoutSections[&quot;PageHead&quot;] = &quot;buoy/page-head.html&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.LayoutSections[&quot;Header&quot;] = &quot;shared/header.html&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.LayoutSections[&quot;Modal&quot;] = &quot;shared/modal.html&quot;&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;A call is made into the service layer to retrieve the list of regions. Then the slice of stations are passed into the view system. Since this is setting up the initial view of the application, layouts and the template are specified. When the controller method returns, the beego framework will generate the html for the response and deliver it to the browser.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/-uZ1MOYZrbTo/Uvaji2e8_3I/AAAAAAAANWE/s09xvHHZaj4/s1600/Screen+Shot+2014-02-08+at+4.36.44+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-uZ1MOYZrbTo/Uvaji2e8_3I/AAAAAAAANWE/s09xvHHZaj4/s1600/Screen+Shot+2014-02-08+at+4.36.44+PM.png&quot; height=&quot;104&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;To generate that grid of stations, we need to be able to iterate over the slice of stations. Go templates support iterating over a slice. Here we use the .Stations variable which was passed into the view system:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;{{range $index, $val := .Stations}}&lt;br /&gt;&amp;lt;tr&amp;gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;br /&gt;&amp;nbsp; &amp;lt;td&amp;gt;&amp;lt;a class=&quot;detail&quot; data=&quot;{{$val.StationId}}&quot; href=&quot;#&quot;&amp;gt;{{$val.StationId}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;&lt;br /&gt;&amp;nbsp; &amp;lt;td&amp;gt;{{$val.Name}}&amp;lt;/td&amp;gt;&lt;br /&gt;&amp;nbsp; &amp;lt;td&amp;gt;{{$val.LocDesc}}&amp;lt;/td&amp;gt;&lt;br /&gt;&amp;nbsp; &amp;lt;td&amp;gt;{{$val.Condition.DisplayWindSpeed}}&amp;lt;/td&amp;gt;&lt;br /&gt;&amp;nbsp; &amp;lt;td&amp;gt;{{$val.Condition.WindDirection}}&amp;lt;/td&amp;gt;&lt;br /&gt;&amp;nbsp; &amp;lt;td&amp;gt;{{$val.Condition.DisplayWindGust}}&amp;lt;/td&amp;gt;&lt;br /&gt;&amp;lt;/tr&amp;gt;&lt;br /&gt;{{end}} &lt;/div&gt;&lt;br /&gt;Each station id is a link that brings up a modal dialog box with the details for each station. The RetrieveStation controller method generates the html for the modal dialog:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func (this *BuoyController) RetrieveStation() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; params := struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; StationId string `form:&quot;stationId&quot; valid:&quot;Required; MinSize(4)&quot; error:&quot;invalid_station_id&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; }{}&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; if this.ParseAndValidate(&amp;amp;params) == false {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; buoyStation, err := buoyService.FindStation(&amp;amp;this.Service, params.StationId)&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.ServeError(err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.Data[&quot;Station&quot;] = buoyStation&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.Layout = &quot;&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.TplNames = &quot;buoy/pv_station.html&quot;&lt;br /&gt;&amp;nbsp; &amp;nbsp; view, _ := this.RenderString()&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.AjaxResponse(0, &quot;SUCCESS&quot;, view)&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;RetrieveStation gets the details for the specified station and then uses the view system to generate the html for the dialog box. The partial view is passed back to the requesting ajax call and placed into the browser document:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;function ShowDetail(result) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; try {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var postData = {};&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; postData[&quot;stationId&quot;] = $(result).attr(&#39;data&#39;);&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var service = new ServiceResult();&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; service.getJSONData(&quot;/buoy/retrievestation&quot;,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; postData,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ShowDetail_Callback,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Standard_ValidationCallback,&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Standard_ErrorCallback&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; catch (e) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; alert(e);&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;function ShowDetail_Callback() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; try {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $(&#39;#system-modal-title&#39;).html(&quot;Buoy Details&quot;);&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $(&#39;#system-modal-content&#39;).html(this.ResultObject);&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $(&quot;#systemModal&quot;).modal(&#39;show&#39;);&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; catch (e) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; alert(e);&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;Once the call to modal.(&#39;show&#39;) is performed, the following modal diaglog appears.&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/-NnBxqehcFA4/Uvamd2bwg1I/AAAAAAAANWQ/S1xN3VbP8BI/s1600/Screen+Shot+2014-02-08+at+4.49.16+PM.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-NnBxqehcFA4/Uvamd2bwg1I/AAAAAAAANWQ/S1xN3VbP8BI/s1600/Screen+Shot+2014-02-08+at+4.49.16+PM.png&quot; height=&quot;362&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The RetrieveStationJson function implements a web service call that returns a JSON document:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func (this *BuoyController) RetrieveStationJson() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; params := struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; StationId string `form:&quot;:stationId&quot; valid:&quot;Required; MinSize(4)&quot; error:&quot;invalid_station_id&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; }{}&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; if this.ParseAndValidate(&amp;amp;params) == false {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; } &lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; buoyStation, err := buoyService.FindStation(&amp;amp;this.Service, params.StationId)&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.ServeError(err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.Data[&quot;json&quot;] = &amp;amp;buoyStation&lt;br /&gt;&amp;nbsp; &amp;nbsp; this.ServeJson()&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;You can see how it calls into the service layer and uses the JSON support to return the response.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Testing The Endpoint&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;In order to make sure the application is always working, it needs to have tests: &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;func TestStation(t *testing.T) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; r, _ := http.NewRequest(&quot;GET&quot;, &quot;/station/42002&quot;, nil)&lt;br /&gt;&amp;nbsp; &amp;nbsp; w := httptest.NewRecorder()&lt;br /&gt;&amp;nbsp; &amp;nbsp; beego.BeeApp.Handlers.ServeHTTP(w, r)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; response := struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; StationId string `json:&quot;station_id&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Name      string `json:&quot;name&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; LocDesc   string `json:&quot;location_desc&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Condition struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Type        string    `json:&quot;type&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Coordinates []float64 `json:&quot;coordinates&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } `json:&quot;condition&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Location struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; WindSpeed     float64 `json:&quot;wind_speed_milehour&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; WindDirection int     `json:&quot;wind_direction_degnorth&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; WindGust      float64 `json:&quot;gust_wind_speed_milehour&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } `json:&quot;location&quot;`&lt;br /&gt;&amp;nbsp; &amp;nbsp; }{}&lt;br /&gt;&amp;nbsp; &amp;nbsp; json.Unmarshal(w.Body.Bytes(), &amp;amp;response)&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; Convey(&quot;Subject: Test Station Endpoint\n&quot;, t, func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Convey(&quot;Status Code Should Be 200&quot;, func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; So(w.Code, ShouldEqual, 200)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; })&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Convey(&quot;The Result Should Not Be Empty&quot;, func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; So(w.Body.Len(), ShouldBeGreaterThan, 0)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; })&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Convey(&quot;There Should Be A Result For Station 42002&quot;, func() {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; So(response.StationId, ShouldEqual, &quot;42002&quot;)&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; })&lt;br /&gt;&amp;nbsp; &amp;nbsp; })&lt;br /&gt;} &lt;/div&gt;&lt;br /&gt;This test creates a fake call through the Beego handler for the specified route. This is awesome because we don&#39;t need to run the web application to test. By using goconvey we can create tests that produce nice output that is logical and easy to read.&lt;br /&gt;&lt;br /&gt;Here is a sample when the test fails:&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Subject: Test Station Endpoint&lt;br /&gt;&lt;br /&gt;&amp;nbsp; Status Code Should Be 200 ✘&lt;br /&gt;&amp;nbsp; The Result Should Not Be Empty ✔&lt;br /&gt;&amp;nbsp; There Should Be A Result For Station 42002 ✘&lt;br /&gt;&lt;br /&gt;Failures:&lt;br /&gt;&lt;br /&gt;* /Users/bill/Spaces/Go/Projects/src/github.com/goinggo/beego-mgo/test/endpoints/buoyEndpoints_test.go &lt;br /&gt;Line 35:&lt;br /&gt;Expected: &#39;200&#39;&lt;br /&gt;Actual:   &#39;400&#39;&lt;br /&gt;(Should be equal)&lt;br /&gt;&lt;br /&gt;* /Users/bill/Spaces/Go/Projects/src/github.com/goinggo/beego-mgo/test/endpoints/buoyEndpoints_test.go &lt;br /&gt;Line 37:&lt;br /&gt;Expected: &#39;0&#39;&lt;br /&gt;Actual:   &#39;9&#39;&lt;br /&gt;(Should be equal)&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;3 assertions thus far&lt;br /&gt;&lt;br /&gt;--- FAIL: TestStation-8 (0.03 seconds) &lt;/div&gt;&lt;br /&gt;Here is a sample when it is successful: &lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #efefef; font-family: &#39;Courier New&#39;, Courier, monospace; font-size: small; overflow-x: scroll; padding: 10px; white-space: nowrap;&quot;&gt;Subject: Test Station Endpoint&lt;br /&gt;&lt;br /&gt;&amp;nbsp; Status Code Should Be 200 ✔&lt;br /&gt;&amp;nbsp; The Result Should Not Be Empty ✔&lt;br /&gt;&amp;nbsp; There Should Be A Result For Station 42002 ✔&lt;br /&gt;&lt;br /&gt;3 assertions thus far&lt;br /&gt;&lt;br /&gt;--- PASS: TestStation-8 (0.05 seconds) &lt;/div&gt;&lt;br /&gt;&lt;b&gt;&lt;span style=&quot;font-size: large;&quot;&gt;Conclusion&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;Take the time to download the project and look around. I have attempted to show you the major points of the sample and how things are put together. The Beego framework makes it easy to implement your own ways to abstract and implement boilerplate code, leverage the go testing harness and run and deploy the code using Go standard mechanisms.</content><link rel='replies' type='application/atom+xml' href='http://www.goinggo.net/feeds/4403044012444977298/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.goinggo.net/2013/12/sample-web-application-using-beego-and.html#comment-form' title='7 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/4403044012444977298'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/6298089572270107210/posts/default/4403044012444977298'/><link rel='alternate' type='text/html' href='http://www.goinggo.net/2013/12/sample-web-application-using-beego-and.html' title='Sample Web Application Using Beego and Mgo'/><author><name>William Kennedy</name><uri>https://plus.google.com/107537752159279043170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-9BjFGDE07Ao/AAAAAAAAAAI/AAAAAAAANus/G8JP6mKiasQ/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://2.bp.blogspot.com/-Hjmz_0kp3CQ/UvaxtPf0eaI/AAAAAAAANWg/6GKEXPsfgzM/s72-c/Screen+Shot+2014-02-08+at+5.37.01+PM.png" height="72" width="72"/><thr:total>7</thr:total></entry></feed>